[
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Algebraic diagrammatic construction theory (ADC) is a post-Hartree-Fock\napproach for computing excited electronic states. [ 36 , 37 , 38 , 39 ] This is done by approximating a linear-response function\n(so-called propagator) to the \\(n\\) -th order in perturbation theory,\ndefining the hierarchy of ADC"
      }
    ],
    "parent_section": "adc",
    "description": "Algebraic diagrammatic construction theory (ADC) is a post-Hartree-Fock\napproach for computing excited electronic states. [ 36 , 37 , 38 , 39 ] This is done by approximating a linear-response function\n(so-called propagator) to the \\(n\\) -th order in perturbation theory,\ndefining the hierarchy of ADC(n) methods.\nDepending on the property being investigated, propagators can be of different\ntypes. Some common examples include the polarization propagator for neutral\nelectronic excitations, the one-particle Green’s function for charged excitations,\nand the two-electron propagator for Auger electron spectroscopy.\nThe different propagators lead to different variants of the ADC methods. At present, the adc module in PySCF can be used to calculate neutral electronic\nexcitations from the polarizatio"
  },
  {
    "name": "Spin_restricted_and_spin_unrestricted_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_restricted_and_spin_unrestricted_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The adc module can be used to compute EE’s, IP’s, and EA’s\nfor closed- and open-shell molecules starting with the restricted (RHF) or\nunrestricted (UHF) Hartree-Fock reference wavefunctions using the RADC or UADC\nmodules.\nAdditionally, open-shell ADC calculations can be carried out using the\nrestric"
      }
    ],
    "parent_section": "adc",
    "description": "The adc module can be used to compute EE’s, IP’s, and EA’s\nfor closed- and open-shell molecules starting with the restricted (RHF) or\nunrestricted (UHF) Hartree-Fock reference wavefunctions using the RADC or UADC\nmodules.\nAdditionally, open-shell ADC calculations can be carried out using the\nrestricted open-shell (ROHF) reference wavefunction, which are supported by\nthe UADC module.\nSee Self-consistent field (SCF) methods to learn more about the different reference wavefunctions. Shown below is an example of the IP- and EA-UADC(2) calculations for the\nopen-shell OH radical: from pyscf import gto , scf , adc mol = gto . Mole () mol . atom = [ [ 'O' , ( 0. , 0. , 0. )], [ 'H' , ( 0. , 0. , 0.969 )],] mol . basis = 'aug-cc-pvdz' mol . spin = 1 mol . build () mf = scf . UHF ( mol ) . run () #I"
  },
  {
    "name": "Excited_state_properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Excited_state_properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The adc module supports computing transition and excited-state properties.\nFor EE, oscillator strengths are available (currently, only in the UADC\nimplementation). [ 38 ] The IP- and EA-ADC methods provide spectroscopic factors, which measure the\nprobabilities of charged excitations in photoelectron"
      }
    ],
    "parent_section": "adc",
    "description": "The adc module supports computing transition and excited-state properties.\nFor EE, oscillator strengths are available (currently, only in the UADC\nimplementation). [ 38 ] The IP- and EA-ADC methods provide spectroscopic factors, which measure the\nprobabilities of charged excitations in photoelectron spectra. [ 39 ] Computation of transition properties is performed by default and can be switched\noff by setting compute_properties = False myadc . compute_properties = False myadc . method = \"adc(3)\" myadc . method_type = \"ip\" myadc . kernel ( nroots = 3 ) Open-shell calculations using EE-UADC further support evaluating the spin\nsquare operator expectation values for the excited states (<S^2>).\nThe <S^2> values are not computed by default, they can be requested using\nthe compute_spin_square = T"
  },
  {
    "name": "Analysis_of_excited_state_properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Analysis_of_excited_state_properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The adc module allows to analyze the ADC(n) eigenvectors\nfor characterizing the nature of electronic transitions. When compute_properties = True is set, this analysis will also display the largest\ncontributions to the spectroscopic factors (IP, EA) or amplitudes (EE) for singly\nexcited states. The a"
      }
    ],
    "parent_section": "adc",
    "description": "The adc module allows to analyze the ADC(n) eigenvectors\nfor characterizing the nature of electronic transitions. When compute_properties = True is set, this analysis will also display the largest\ncontributions to the spectroscopic factors (IP, EA) or amplitudes (EE) for singly\nexcited states. The analysis of ADC(n) eigenvectors\nand spectroscopic factors can be invoked using the analyze() function: myadc . kernel ( nroots = 3 ) myadc . analyze ()"
  },
  {
    "name": "Core_excitation_energies_and_spectra",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Core_excitation_energies_and_spectra {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The IP-ADC code supports calculating core ionization energies and\nX-ray photoelectron spectra (XPS) using the core-valence separation technique\n(CVS). To invoke CVS, specify the ncvs parameter\nof IP-ADC object before running the kernel() function.\nThe ncvs parameter should be set to an integer defin"
      }
    ],
    "parent_section": "adc",
    "description": "The IP-ADC code supports calculating core ionization energies and\nX-ray photoelectron spectra (XPS) using the core-valence separation technique\n(CVS). To invoke CVS, specify the ncvs parameter\nof IP-ADC object before running the kernel() function.\nThe ncvs parameter should be set to an integer defining the index of the core\norbital that is expected to be ionized first in the XPS spectrum.\nFor example, probing the 1s orbital of C in CO can be done by setting ncvs = 2 since the C 1s orbitals are higher in energy than O 1s."
  },
  {
    "name": "Algorithms_and_job_control",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Algorithms_and_job_control {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The current capabilities of the adc module are summarized in the\nfollowing table: Method Reference Available properties EE-ADC(2) RHF, UHF, ROHF EEs, osc. strengths (UADC), spin square (UADC) EE-ADC(2)-X RHF, UHF, ROHF EEs, osc. strengths (UADC), spin square (UADC) EE-ADC(3) RHF, UHF, ROHF EEs, osc."
      }
    ],
    "parent_section": "adc",
    "description": "The current capabilities of the adc module are summarized in the\nfollowing table: Method Reference Available properties EE-ADC(2) RHF, UHF, ROHF EEs, osc. strengths (UADC), spin square (UADC) EE-ADC(2)-X RHF, UHF, ROHF EEs, osc. strengths (UADC), spin square (UADC) EE-ADC(3) RHF, UHF, ROHF EEs, osc. strengths (UADC), spin square (UADC) IP-ADC(2) RHF, UHF, ROHF IPs, core IPs, spec. factors, Dyson orb IP-ADC(2)-X RHF, UHF, ROHF IPs, core IPs, spec. factors, Dyson orb IP-ADC(3) RHF, UHF, ROHF IPs, core IPs, spec. factors, Dyson orb EA-ADC(2) RHF, UHF, ROHF EAs, spec. factors, Dyson orb EA-ADC(2)-X RHF, UHF, ROHF EAs, spec. factors, Dyson orb EA-ADC(3) RHF, UHF, ROHF EAs, spec. factors, Dyson orb The ADC(n) calculations are performed using one of the three algorithms for\nhandling the two-elect"
  },
  {
    "name": "Current_limitations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Current_limitations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Some limitations of current implementation are listed below: The EE-RADC code does not support calculating oscillator strengths.\nThis property can be computed using the EE-UADC code (i.e., by using\nthe UHF reference) for a closed- or open-shell molecule. The EE- and IP/EA-RADC codes compute only the"
      }
    ],
    "parent_section": "adc",
    "description": "Some limitations of current implementation are listed below: The EE-RADC code does not support calculating oscillator strengths.\nThis property can be computed using the EE-UADC code (i.e., by using\nthe UHF reference) for a closed- or open-shell molecule. The EE- and IP/EA-RADC codes compute only the states of lowest spin:\nS = 0 (singlet) and S = 1/2 (doublet), respectively. Using the\ncorresponding UADC code allows to compute excitations with ΔS = 0,\n±1 for EE and ΔS = ±1/2, ±3/2 for IP and EA. Computing spin square expectation values is currently only available for\nEE-UADC. The reference and excited-state 1-RDMs are not implemented for EE-RADC.\nAlso, the reference 1-RDMs are not available for any UADC method. The EE-UADC(3) calculations of excited-state one-particle reduced density\nmatrice"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "adc",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Auxiliary second-order Green’s function perturbation theory (AGF2) [ 42 , 43 ] is an iterative, \\(\\mathcal{O}[N^5]\\) scaling post-Hartree–Fock method primarily intended for the calculation of\ncharged excitation spectra, ionisation potentials (IPs) and electron affinities\n(EAs), with energetics and s"
      }
    ],
    "parent_section": "agf2",
    "description": "Auxiliary second-order Green’s function perturbation theory (AGF2) [ 42 , 43 ] is an iterative, \\(\\mathcal{O}[N^5]\\) scaling post-Hartree–Fock method primarily intended for the calculation of\ncharged excitation spectra, ionisation potentials (IPs) and electron affinities\n(EAs), with energetics and single-particle static properties also available.\nIt can also be considered loosely as an iterative approximate ADC(2) method.\nOne advantage is that the entire spectrum of charged excitations is found\nsimultaneously, as the full Green’s function is self-consistently optimised.\nAGF2 calculations can be performed with or without density fitting, and for\nrestricted or unrestricted Hartree–Fock references, and is available with\nhybrid parallelism capabilities. Basic usage of AGF2 as given in examples"
  },
  {
    "name": "Theory",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Theory {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In AGF2, one iteratively solves the Dyson equation \\[G(\\omega) = G_0(\\omega) + G_0(\\omega) \\Sigma(\\omega) G(\\omega),\\] using the self-energy correct through second-order perturbation theory, which\ncan be written as \\[\\begin{split}\\Sigma_{xy}(\\omega)\n&= \\sum_{ija} \\frac{ (xi|ja) [ 2 (yi|ja) - (yj|ia)"
      }
    ],
    "parent_section": "agf2",
    "description": "In AGF2, one iteratively solves the Dyson equation \\[G(\\omega) = G_0(\\omega) + G_0(\\omega) \\Sigma(\\omega) G(\\omega),\\] using the self-energy correct through second-order perturbation theory, which\ncan be written as \\[\\begin{split}\\Sigma_{xy}(\\omega)\n&= \\sum_{ija} \\frac{ (xi|ja) [ 2 (yi|ja) - (yj|ia) ] }\n                   { \\omega - (E_i + E_j - E_a) } \\\\\n&+ \\sum_{abi} \\frac{ (xa|bi) [ 2 (ya|bi) - (yb|ai) ] }\n                   { \\omega - (E_a + E_b - E_i) }.\\end{split}\\] In AGF2, the first two spectral moments of the MP2 self-energy, \\[\\begin{split}T_{xy}^{(0)} &= \\sum_{ija} (xi|ja) [ 2 (yi|ja) - (yj|ia) ] \\\\\n             &+ \\sum_{abi} (xa|bi) [ 2 (ya|bi) - (yb|ai) ] \\\\\nT_{xy}^{(1)} &= \\sum_{ija} (xi|ja) [ 2 (yi|ja) - (yj|ia) ]\n                (E_i + E_j - E_a) \\\\\n             &+ \\sum_{ab"
  },
  {
    "name": "Photoemission_spectra",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Photoemission_spectra {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The compression of the effective dynamics performed in AGF2 permits the\ncalculation of the full spectrum of charged excitations, as no additional\ncomputational effort is required for this (in contrast to iterative eigensolvers\nof effective hamiltonians), and the computational effort is therefore\nind"
      }
    ],
    "parent_section": "agf2",
    "description": "The compression of the effective dynamics performed in AGF2 permits the\ncalculation of the full spectrum of charged excitations, as no additional\ncomputational effort is required for this (in contrast to iterative eigensolvers\nof effective hamiltonians), and the computational effort is therefore\nindependent of the number of excitations requested.\nAn example of a calculation which provides the full spectral function can be\nfound in examples/agf2/03-photoemission_spectra.py : #!/usr/bin/env python # # Author: Oliver J. Backhouse <olbackhouse@gmail.com> #         George H. Booth <george.booth@kcl.ac.uk> # ''' Use a converged AGF2 calculation to build the full photoemission (quasiparticle) spectrum Default AGF2 corresponds to the AGF2(1,0) method outlined in the papers: - O. J. Backhouse, M. N"
  },
  {
    "name": "Restart_a_calculation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Restart_a_calculation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The contents of an AGF2 calculation can be dumped to the disk via the familiar\nPySCF chkfile utilities.\nBy default, an AGF2 method will inherit the chkfile attribute of the\nunderlying Hartree–Fock reference object.\nAn example of restoring an AGF2 calculation from a checkpoint file can be found\nin ex"
      }
    ],
    "parent_section": "agf2",
    "description": "The contents of an AGF2 calculation can be dumped to the disk via the familiar\nPySCF chkfile utilities.\nBy default, an AGF2 method will inherit the chkfile attribute of the\nunderlying Hartree–Fock reference object.\nAn example of restoring an AGF2 calculation from a checkpoint file can be found\nin examples/agf2/04-restart.py : #!/usr/bin/env python # # Author: Oliver J. Backhouse <olbackhouse@gmail.com> #         George H. Booth <george.booth@kcl.ac.uk> # ''' An example of restarting an AGF2 calculation. The agf2.chkfile module provides similar functionality to the existing chkfile utilities in pyscf, but prevents failure during MPI runs. ''' import numpy from pyscf import gto , scf , agf2 , lib mol = gto . M ( atom = 'O 0 0 0; H 0 0 1; H 0 1 0' , basis = 'cc-pvdz' , verbose = 5 ) mf = scf "
  },
  {
    "name": "Parallelisation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Parallelisation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The AGF2 module supports both MPI an OpenMP parallelisation in an aim to provide\na scalable method applicable to interesting problems in quantum chemistry.\nFurthermore, the dominant scaling step is embarrassingly parallel.\nDistribution of computational load is handled by the optional dependency mpi4"
      }
    ],
    "parent_section": "agf2",
    "description": "The AGF2 module supports both MPI an OpenMP parallelisation in an aim to provide\na scalable method applicable to interesting problems in quantum chemistry.\nFurthermore, the dominant scaling step is embarrassingly parallel.\nDistribution of computational load is handled by the optional dependency mpi4py , and will run without MPI using OpenMP threads if an installation\ncannot be found."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "agf2",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Coupled-cluster (CC) theory is a post-Hartree-Fock method capable of describing\nelectron correlation in the ground state.  It is size extensive but not\nvariational.\nPySCF has extensive support for CC calculations with single and double excitations (CCSD).\nIt can also include a perturbative treatment"
      }
    ],
    "parent_section": "cc",
    "description": "Coupled-cluster (CC) theory is a post-Hartree-Fock method capable of describing\nelectron correlation in the ground state.  It is size extensive but not\nvariational.\nPySCF has extensive support for CC calculations with single and double excitations (CCSD).\nIt can also include a perturbative treatment of triple excitations (CCSD(T)),\nwhich is a very accurate method for single-reference quantum chemistry.\nCC calculations can be performed with or without density fitting,\ndepending on the initial SCF calculation.\nCorrelated excited states are\naccessible through the equation-of-motion (EOM) CCSD framework, described below. A minimal example of a CCSD and CCSD(T) calculation is as follows: from pyscf import gto , scf , cc mol = gto . M ( atom = 'H 0 0 0; F 0 0 1.1' , # in Angstrom basis = 'ccpvdz"
  },
  {
    "name": "Spin_symmetry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The CC module in PySCF supports a number of reference wave functions with\nbroken spin symmetry.  In particular, CC can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RCCSD, UCCSD, and GCCSD methods. The module-level cc.CCSD(mf) "
      }
    ],
    "parent_section": "cc",
    "description": "The CC module in PySCF supports a number of reference wave functions with\nbroken spin symmetry.  In particular, CC can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RCCSD, UCCSD, and GCCSD methods. The module-level cc.CCSD(mf) constructor can infer the correct method based\non the level of symmetry-breaking in the mean-field argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in ccsd.py (restricted with real orbitals), rccsd.py (restricted with\npotentially complex orbitals), uccsd.py (unrestricted), and gccsd.py (general). For example, a spin-unrestricted calculation on triplet oxygen can be performed\nas follows: from pyscf import gto , scf , cc mol = gto . M ( atom = '"
  },
  {
    "name": "Properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A number of properties are available at the CCSD level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = mycc . make_rdm1 () dm2 = mycc . make_rdm2 () Analytical nuclear gradients can be calculated: mygrad = mycc . nuc_grad_method () . "
      }
    ],
    "parent_section": "cc",
    "description": "A number of properties are available at the CCSD level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = mycc . make_rdm1 () dm2 = mycc . make_rdm2 () Analytical nuclear gradients can be calculated: mygrad = mycc . nuc_grad_method () . run () The CCSD Lambda equations can be solved: l1 , l2 = mycc . solve_lambda ()"
  },
  {
    "name": "Frozen_orbitals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Frozen_orbitals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "By default, CCSD calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals,\nuse the frozen keyword argument: mycc = cc . CCSD ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a list of\n0-based orbi"
      }
    ],
    "parent_section": "cc",
    "description": "By default, CCSD calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals,\nuse the frozen keyword argument: mycc = cc . CCSD ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a list of\n0-based orbital indices can be provided as the frozen keyword argument: # freeze 2 core orbitals mycc = cc . CCSD ( mf , frozen = [ 0 , 1 ]) . run () # freeze 2 core orbitals and 3 unoccupied orbitals mycc = cc . CCSD ( mf , frozen = [ 0 , 1 , 16 , 17 , 18 ]) . run () The number of core orbitals to be frozen can be generated automatically: mycc = cc . CCSD ( mf ) . set_frozen () . run () See also Frozen orbitals for more information on the rule of freezing orbitals."
  },
  {
    "name": "Equation_of_motion_coupled_cluster_theory",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Equation_of_motion_coupled_cluster_theory {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "EOM-CCSD can be used to calculate neutral excitation energies (EE-EOM-CCSD),\nspin-flip excitations (SF-EOM-CCSD),\nor charged excitations, i.e. ionization potentials (IP-EOM-CCSD) or electron affinities\n(EA-EOM-CCSD).  The EOM functions return the requested number of\neigenvalues and right-hand eigenv"
      }
    ],
    "parent_section": "cc",
    "description": "EOM-CCSD can be used to calculate neutral excitation energies (EE-EOM-CCSD),\nspin-flip excitations (SF-EOM-CCSD),\nor charged excitations, i.e. ionization potentials (IP-EOM-CCSD) or electron affinities\n(EA-EOM-CCSD).  The EOM functions return the requested number of\neigenvalues and right-hand eigenvectors. For example: mycc . kernel () e_ip , c_ip = mycc . ipccsd ( nroots = 1 ) e_ea , c_ea = mycc . eaccsd ( nroots = 1 ) e_ee , c_ee = mycc . eeccsd ( nroots = 1 ) e_sf , c_sf = mycc . eomsf_ccsd ( nroots = 1 ) The eecsd() function returns neutral excitations with all possible spin\nmultiplicities.  For closed-shell calculations (RHF and RCCSD), singlet and triplet\nexcitations can be requested explicitly: e_s , c_s = mycc . eomee_ccsd_singlet ( nroots = 1 ) e_t , c_t = mycc . eomee_ccsd_triple"
  },
  {
    "name": "Job_control",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Job_control {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Saving and restarting # To allow for future restarts, the SCF information\nand the CCSD DIIS information must be saved: mf = scf . HF ( mol ) mf . chkfile = 'hf.chk' mf . kernel () mycc = cc . CCSD ( mf ) mycc . diis_file = 'ccdiis.h5' mycc . kernel () To restart a CCSD calculation, first the molecul"
      }
    ],
    "parent_section": "cc",
    "description": "Saving and restarting # To allow for future restarts, the SCF information\nand the CCSD DIIS information must be saved: mf = scf . HF ( mol ) mf . chkfile = 'hf.chk' mf . kernel () mycc = cc . CCSD ( mf ) mycc . diis_file = 'ccdiis.h5' mycc . kernel () To restart a CCSD calculation, first the molecule and SCF information must\nbe restored: mol = lib . chkfile . load_mol ( 'hf.chk' ) mf = scf . HF ( mol ) mf . __dict__ . update ( lib . chkfile . load ( 'hf.chk' , 'scf' )) Next, the CCSD calculation can be restarted by using the previous\nCCSD amplitudes as the initial guess: mycc = cc . CCSD ( mf ) mycc . restore_from_diis_ ( 'ccdiis.h5' ) mycc . kernel ( mycc . t1 , mycc . t2 ) Modifying DIIS # The parameters of the DIIS algorithm can be tuned in cases where\nconvergence is difficult.  To incr"
  },
  {
    "name": "Saving_and_restarting",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Saving_and_restarting {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To allow for future restarts, the SCF information\nand the CCSD DIIS information must be saved: mf = scf . HF ( mol ) mf . chkfile = 'hf.chk' mf . kernel () mycc = cc . CCSD ( mf ) mycc . diis_file = 'ccdiis.h5' mycc . kernel () To restart a CCSD calculation, first the molecule and SCF information mu"
      }
    ],
    "parent_section": "cc",
    "description": "To allow for future restarts, the SCF information\nand the CCSD DIIS information must be saved: mf = scf . HF ( mol ) mf . chkfile = 'hf.chk' mf . kernel () mycc = cc . CCSD ( mf ) mycc . diis_file = 'ccdiis.h5' mycc . kernel () To restart a CCSD calculation, first the molecule and SCF information must\nbe restored: mol = lib . chkfile . load_mol ( 'hf.chk' ) mf = scf . HF ( mol ) mf . __dict__ . update ( lib . chkfile . load ( 'hf.chk' , 'scf' )) Next, the CCSD calculation can be restarted by using the previous\nCCSD amplitudes as the initial guess: mycc = cc . CCSD ( mf ) mycc . restore_from_diis_ ( 'ccdiis.h5' ) mycc . kernel ( mycc . t1 , mycc . t2 )"
  },
  {
    "name": "Modifying_DIIS",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Modifying_DIIS {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The parameters of the DIIS algorithm can be tuned in cases where\nconvergence is difficult.  To increase the size of the DIIS space: mycc = cc . CCSD ( mf ) mycc . diis_space = 10 mycc . kernel () By default, DIIS is activated on the first CCSD iteration.  Sometimes\nit can be helpful to postpone the "
      }
    ],
    "parent_section": "cc",
    "description": "The parameters of the DIIS algorithm can be tuned in cases where\nconvergence is difficult.  To increase the size of the DIIS space: mycc = cc . CCSD ( mf ) mycc . diis_space = 10 mycc . kernel () By default, DIIS is activated on the first CCSD iteration.  Sometimes\nit can be helpful to postpone the use of DIIS: mycc = cc . CCSD ( mf ) mycc . diis_start_cycle = 4 mycc . kernel ()"
  },
  {
    "name": "Integral_direct_CCSD",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Integral_direct_CCSD {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In order to avoid large memory requirements, the default behavior in CCSD calculations\nis to store most two-electron integral tensors on disk.  This leads to a\npotential I/O bottleneck.  For medium-sized molecules, an integral-direct\nAO-driven implementation can be more efficient.  The user must man"
      }
    ],
    "parent_section": "cc",
    "description": "In order to avoid large memory requirements, the default behavior in CCSD calculations\nis to store most two-electron integral tensors on disk.  This leads to a\npotential I/O bottleneck.  For medium-sized molecules, an integral-direct\nAO-driven implementation can be more efficient.  The user must manually\nrequest an integral-direct CCSD calculation: mycc = cc . CCSD ( mf ) mycc . direct = True e_corr , t1 , t2 = mycc . kernel ()"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "cc",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Configuration interaction (see e.g. [ 31 , 32 , 33 ] )\nis a post-Hartree–Fock method, diagonalising\nthe many-electron Hamiltonian matrix. FCI includes all Slater determinants of\nappropriate symmetry in the eigenvector basis. CISD includes only those\nthat differ from the Hartree–Fock determinant by a"
      }
    ],
    "parent_section": "ci",
    "description": "Configuration interaction (see e.g. [ 31 , 32 , 33 ] )\nis a post-Hartree–Fock method, diagonalising\nthe many-electron Hamiltonian matrix. FCI includes all Slater determinants of\nappropriate symmetry in the eigenvector basis. CISD includes only those\nthat differ from the Hartree–Fock determinant by at most two occupied\nspinorbitals."
  },
  {
    "name": "Configuration_interaction_singles_and_doubles_CISD",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Configuration_interaction_singles_and_doubles_CISD {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A simple example (see examples/ci/00-simple_cisd.py ) of running\na restricted and an unrestricted CISD calculation is #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' A simple example to run CISD calculation. ''' import pyscf mol = pyscf . M ( atom = 'H 0 0 0; F 0 0 1.1' , b"
      }
    ],
    "parent_section": "ci",
    "description": "A simple example (see examples/ci/00-simple_cisd.py ) of running\na restricted and an unrestricted CISD calculation is #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' A simple example to run CISD calculation. ''' import pyscf mol = pyscf . M ( atom = 'H 0 0 0; F 0 0 1.1' , basis = 'ccpvdz' ) mf = mol . HF () . run () mycc = mf . CISD () . run () print ( 'RCISD correlation energy' , mycc . e_corr ) mf = mol . UHF () . run () mycc = mf . CISD () . run () print ( 'UCISD correlation energy' , mycc . e_corr ) which outputs converged SCF energy = - 99.9873974403488 E ( RCISD ) = - 100.196182975762 E_corr = - 0.2087855354132202 RCISD correlation energy - 0.2087855354132202 namely, the (restricted) Hartree–Fock energy, the RCISD energy and their\ndifference, the RCISD corre"
  },
  {
    "name": "Spin_symmetry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The CISD module in PySCF supports a number of reference wavefunctions with\nbroken spin symmetry.  In particular, CISD can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RCISD, UCISD, and GCISD methods. The small\nexample above sh"
      }
    ],
    "parent_section": "ci",
    "description": "The CISD module in PySCF supports a number of reference wavefunctions with\nbroken spin symmetry.  In particular, CISD can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RCISD, UCISD, and GCISD methods. The small\nexample above shows this for RCISD and UCISD. The module-level ci.CISD(mf) constructor can infer the correct method based\non the level of symmetry-breaking in the mean-field argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in cisd.py (restricted), ucisd.py (unrestricted), and gcisd.py (general). For example, a spin-unrestricted calculation on triplet oxygen can be performed\nas follows: from pyscf import gto , scf , ci mol = gto . M ( atom = 'O 0 0 0; O 0 0 1."
  },
  {
    "name": "Properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A number of properties are available at the CISD level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = myci . make_rdm1 () dm2 = myci . make_rdm2 () Analytical nuclear gradients can be calculated\n(see [ 34 , 35 ] and references therei"
      }
    ],
    "parent_section": "ci",
    "description": "A number of properties are available at the CISD level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = myci . make_rdm1 () dm2 = myci . make_rdm2 () Analytical nuclear gradients can be calculated\n(see [ 34 , 35 ] and references therein): mygrad = myci . nuc_grad_method () . run ()"
  },
  {
    "name": "Frozen_orbitals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Frozen_orbitals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "By default, CISD calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals,\nuse the frozen keyword argument: myci = ci . CISD ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a list of\n0-based orbi"
      }
    ],
    "parent_section": "ci",
    "description": "By default, CISD calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals,\nuse the frozen keyword argument: myci = ci . CISD ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a list of\n0-based orbital indices can be provided as the frozen keyword argument: # freeze 2 core orbitals myci = ci . CISD ( mf , frozen = [ 0 , 1 ]) . run () # freeze 2 core orbitals and 3 unoccupied orbitals myci = ci . CISD ( mf , frozen = [ 0 , 1 , 16 , 17 , 18 ]) . run ()"
  },
  {
    "name": "Wavefunction_overlap",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Wavefunction_overlap {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The following example shows how to evaluate the overlap of two different\nCISD wavefunctions. #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Overlap of two CISD wave functions (they can be obtained from different geometries). ''' from functools import reduce import numpy fr"
      }
    ],
    "parent_section": "ci",
    "description": "The following example shows how to evaluate the overlap of two different\nCISD wavefunctions. #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Overlap of two CISD wave functions (they can be obtained from different geometries). ''' from functools import reduce import numpy from pyscf import gto , scf , ci # # RCISD wavefunction overlap # myhf1 = gto . M ( atom = 'H 0 0 0; F 0 0 1.1' , basis = '6-31g' , verbose = 0 ) . apply ( scf . RHF ) . run () ci1 = ci . CISD ( myhf1 ) . run () print ( 'CISD energy of mol1' , ci1 . e_tot ) myhf2 = gto . M ( atom = 'H 0 0 0; F 0 0 1.2' , basis = '6-31g' , verbose = 0 ) . apply ( scf . RHF ) . run () ci2 = ci . CISD ( myhf2 ) . run () print ( 'CISD energy of mol2' , ci2 . e_tot ) s12 = gto . intor_cross ( 'cint1e_ovlp_sph' , myhf1 "
  },
  {
    "name": "Full_configuration_interaction_FCI",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Full_configuration_interaction_FCI {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A simple example (see examples/fci/00-simple-fci.py ) of running\na restricted and an unrestricted FCI calculation is: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' A simple example to run FCI ''' import pyscf mol = pyscf . M ( atom = 'H 0 0 0; F 0 0 1.1' , # in Angstrom b"
      }
    ],
    "parent_section": "ci",
    "description": "A simple example (see examples/fci/00-simple-fci.py ) of running\na restricted and an unrestricted FCI calculation is: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' A simple example to run FCI ''' import pyscf mol = pyscf . M ( atom = 'H 0 0 0; F 0 0 1.1' , # in Angstrom basis = '6-31g' , symmetry = True , ) myhf = mol . RHF () . run () # # create an FCI solver based on the SCF object # cisolver = pyscf . fci . FCI ( myhf ) print ( 'E(FCI) = %.12f ' % cisolver . kernel ()[ 0 ]) # # create an FCI solver based on the SCF object # myuhf = mol . UHF () . run () cisolver = pyscf . fci . FCI ( myuhf ) print ( 'E(UHF-FCI) = %.12f ' % cisolver . kernel ()[ 0 ]) # # create an FCI solver based on the given orbitals and the num. electrons and # spin of the mol object # ciso"
  },
  {
    "name": "Setting_Spin_and_Symmetry_of_Wavefunction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Setting_Spin_and_Symmetry_of_Wavefunction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The following example discusses how to set the spin for an FCI calculations: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Assign spin state for FCI wavefunction. By default, the FCI solver will take Mole attribute spin for the spin state. It can be overwritten by passing"
      }
    ],
    "parent_section": "ci",
    "description": "The following example discusses how to set the spin for an FCI calculations: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Assign spin state for FCI wavefunction. By default, the FCI solver will take Mole attribute spin for the spin state. It can be overwritten by passing kwarg ``nelec`` to the kernel function of FCI solver.  The nelec argument is a two-element tuple.  The first is the number of alpha electrons; the second is the number of beta electrons. If spin-contamination is observed on FCI wavefunction, we can use the decoration function :func:`fci.addons.fix_spin_` to level shift the energy of states which do not have the target spin. ''' import numpy from pyscf import gto , scf , fci mol = gto . M ( atom = 'Ne 0 0 0' , basis = '631g' , spin = 2 ) m = scf"
  },
  {
    "name": "Properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Reduced density matrices can be evaluated, see the following example: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Compute FCI 1,2,3,4-particle density matrices ''' # # Note: Environment variable LD_PRELOAD=...libmkl_def.so may cause this script # crashing # import numpy"
      }
    ],
    "parent_section": "ci",
    "description": "Reduced density matrices can be evaluated, see the following example: #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' Compute FCI 1,2,3,4-particle density matrices ''' # # Note: Environment variable LD_PRELOAD=...libmkl_def.so may cause this script # crashing # import numpy from pyscf import gto , scf , fci mol = gto . Mole () mol . build ( atom = 'H 0 0 0; F 0 0 1.1' , # in Angstrom basis = '6-31g' , spin = 2 , ) myhf = scf . RHF ( mol ) myhf . kernel () # # First create FCI solver with function fci.FCI and solve the FCI problem # cisolver = fci . FCI ( mol , myhf . mo_coeff ) e , fcivec = cisolver . kernel () # # Spin-traced 1-particle density matrix # norb = myhf . mo_coeff . shape [ 1 ] # 6 alpha electrons, 4 beta electrons because spin = nelec_a-nelec_b = 2 n"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "ci",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Density fitting (DF), sometimes also called the resolution of identity (RI) approximation, is a method to approximate the four-index electron repulsion integrals (ERIs) by two- and three-index tensors. [ 62 ] In DF, the atomic orbital (AO) product space is expanded in terms of an auxiliary basis set"
      }
    ],
    "parent_section": "df",
    "description": "Density fitting (DF), sometimes also called the resolution of identity (RI) approximation, is a method to approximate the four-index electron repulsion integrals (ERIs) by two- and three-index tensors. [ 62 ] In DF, the atomic orbital (AO) product space is expanded in terms of an auxiliary basis set. PySCF has extensive support for using DF in both molecular and crystalline calculations. This section covers the basic usage of DF in molecular applications. See Density fitting for crystalline calculations for the use of DF in periodic calculations."
  },
  {
    "name": "Using_DF_in_SCF_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_DF_in_SCF_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "DF is not used by default when initializing a SCF or MCSCF object, but can be invoked via the density_fit() method as follows: from pyscf import gto , scf , mcscf mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvp' ) mf = scf . RHF ( mol ) . density_fit () . run () # output: -108.94377"
      }
    ],
    "parent_section": "df",
    "description": "DF is not used by default when initializing a SCF or MCSCF object, but can be invoked via the density_fit() method as follows: from pyscf import gto , scf , mcscf mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvp' ) mf = scf . RHF ( mol ) . density_fit () . run () # output: -108.943773290737 mc = mcscf . CASSCF ( mf , 8 , 10 ) . density_fit () . run () # output: -109.077600181849 Alternatively, one can initialize a DF object and overwrite the with_df attribute of the SCF object: from pyscf import gto , scf , df mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvp' ) mydf = df . DF ( mol ) . build () mf = scf . RHF ( mol ) . density_fit () mf . with_df = mydf mf . kernel () # output: -108.943773290737 Setting with_df to None turns DF off."
  },
  {
    "name": "Using_DF_in_post_SCF_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_DF_in_post_SCF_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A post-SCF calculation will use DF automatically if the preceding SCF calculation is performed using DF. The example below performs a TDDFT/TDA calculation using DF: from pyscf import gto , dft , tddft mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvp' ) mf = dft . RKS ( mol , xc = \"b"
      }
    ],
    "parent_section": "df",
    "description": "A post-SCF calculation will use DF automatically if the preceding SCF calculation is performed using DF. The example below performs a TDDFT/TDA calculation using DF: from pyscf import gto , dft , tddft mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvp' ) mf = dft . RKS ( mol , xc = \"b3lyp\" ) . density_fit () . run () td = tddft . TDA ( mf ) . run () print ( td . e ) # output: [0.27294247 0.28837975 0.2883798 ] Alternatively, one can use the density_fit() method provided by most post-SCF classes in the same way as in a SCF calculation described above. This is useful when one wants to use DF to accelerate only the post-SCF calculations or to use a different auxiliary basis for the post-SCF calculations than that used by SCF. The example below performs a DF-MP2 calculation usin"
  },
  {
    "name": "Choice_of_auxiliary_basis",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Choice_of_auxiliary_basis {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "General considerations # The choice of auxiliary basis depends on the AO basis.\nBy default, PySCF uses a pre-defined auxiliary basis set optimized for the used AO basis set, if one exists.\nThis includes many commonly used AO basis sets in electronic structure calculations, e.g., the Ahlrichs def2 fa"
      }
    ],
    "parent_section": "df",
    "description": "General considerations # The choice of auxiliary basis depends on the AO basis.\nBy default, PySCF uses a pre-defined auxiliary basis set optimized for the used AO basis set, if one exists.\nThis includes many commonly used AO basis sets in electronic structure calculations, e.g., the Ahlrichs def2 family, [ 64 , 65 ] and the Dunning cc family, [ 66 ] . When a pre-defined auxiliary basis set is not available, an even-tempered basis (ETB) set is generated by the following rule \\[\\varphi_i\n    = r^l \\exp(-\\alpha_l \\beta^i r^2), \\quad i = 0, 1, \\cdots, n_l\\] where both \\(\\alpha_l\\) and \\(n_l\\) are determined automatically from the AO basis. Specifically, \\(\\alpha_l\\) is set to the smallest exponent of the AO products with angular momentum \\(l\\) , and \\(n_l\\) is chosen so that the largest expone"
  },
  {
    "name": "General_considerations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "General_considerations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The choice of auxiliary basis depends on the AO basis.\nBy default, PySCF uses a pre-defined auxiliary basis set optimized for the used AO basis set, if one exists.\nThis includes many commonly used AO basis sets in electronic structure calculations, e.g., the Ahlrichs def2 family, [ 64 , 65 ] and the"
      }
    ],
    "parent_section": "df",
    "description": "The choice of auxiliary basis depends on the AO basis.\nBy default, PySCF uses a pre-defined auxiliary basis set optimized for the used AO basis set, if one exists.\nThis includes many commonly used AO basis sets in electronic structure calculations, e.g., the Ahlrichs def2 family, [ 64 , 65 ] and the Dunning cc family, [ 66 ] . When a pre-defined auxiliary basis set is not available, an even-tempered basis (ETB) set is generated by the following rule \\[\\varphi_i\n    = r^l \\exp(-\\alpha_l \\beta^i r^2), \\quad i = 0, 1, \\cdots, n_l\\] where both \\(\\alpha_l\\) and \\(n_l\\) are determined automatically from the AO basis. Specifically, \\(\\alpha_l\\) is set to the smallest exponent of the AO products with angular momentum \\(l\\) , and \\(n_l\\) is chosen so that the largest exponent of the AO products wit"
  },
  {
    "name": "Special_considerations_for_DFT",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Special_considerations_for_DFT {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For DFT calculations with pure exchange-correlation functionals (i.e., LDA and GGA), the default auxiliary basis, which is designed for fitting both the Coulomb and the Hartree-Fock exchange integrals, may be unnecessarily large. We recommend using the def2-universal-jfit basis [ 67 ] for a more cos"
      }
    ],
    "parent_section": "df",
    "description": "For DFT calculations with pure exchange-correlation functionals (i.e., LDA and GGA), the default auxiliary basis, which is designed for fitting both the Coulomb and the Hartree-Fock exchange integrals, may be unnecessarily large. We recommend using the def2-universal-jfit basis [ 67 ] for a more cost-effective choice as shown in the following example: from pyscf import gto , dft mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'def2-tzvpp' ) mf = dft . RKS ( mol , xc = \"pbe\" ) . density_fit () . run () # -109.432329411505 print ( mf . with_df . auxmol . basis ) # default: def2-tzvpp-jkfit print ( mf . with_df . auxmol . nao_nr ()) # 154 aux basis functions mf . with_df . auxbasis = \"def2-universal-jfit\" # same as \"weigend\" mf . kernel () # -109.432334646585 print ( mf . with_df . auxm"
  },
  {
    "name": "Saving_and_reusing_DF_tensors",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Saving_and_reusing_DF_tensors {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A key result of the DF class is the Cholesky decomposition of the ERIs (CDERIs) in terms of the 3-index tensor \\(d_{L\\mu\\nu}\\) , \\[(\\mu\\nu|\\lambda\\sigma)\n    = \\sum_{L} d^*_{L\\mu\\nu} d_{L\\lambda\\sigma}\\] The build() method of DF computes the CDERIs.\nBy default, the 3-index tensor defining the CDERIs"
      }
    ],
    "parent_section": "df",
    "description": "A key result of the DF class is the Cholesky decomposition of the ERIs (CDERIs) in terms of the 3-index tensor \\(d_{L\\mu\\nu}\\) , \\[(\\mu\\nu|\\lambda\\sigma)\n    = \\sum_{L} d^*_{L\\mu\\nu} d_{L\\lambda\\sigma}\\] The build() method of DF computes the CDERIs.\nBy default, the 3-index tensor defining the CDERIs is discarded once the calculation finishes. Sometimes it is useful to save it to disk for re-use in later calculations. This can be achieved by specifying a HDF5 file by setting _cderi_to_save either at the SCF stage: mf = scf . RHF ( mol ) . density_fit () mf . with_df . _cderi_to_save = 'saved_cderi.h5' mf . kernel () or by initializing a DF object separately: mydf = df . DF ( mol ) mydf . auxbasis = df . make_auxbasis ( mol ) mydf . _cderi_to_save = 'saved_cderi.h5' mydf . build () The saved"
  },
  {
    "name": "Advanced_examples",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Advanced_examples {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "More advanced examples of using the df module include Computing the \\(\\mathbf{J}\\) -matrix of DFT in an I/O-free manner: examples/df/11-get_j_io_free.py . Using DF integrals to define the Hamiltonian of a CASSCF calculation: examples/df/40-custom_df_hamiltonian.py . Generating analytical gradients f"
      }
    ],
    "parent_section": "df",
    "description": "More advanced examples of using the df module include Computing the \\(\\mathbf{J}\\) -matrix of DFT in an I/O-free manner: examples/df/11-get_j_io_free.py . Using DF integrals to define the Hamiltonian of a CASSCF calculation: examples/df/40-custom_df_hamiltonian.py . Generating analytical gradients for DF integrals: examples/df/41-df_integrals_gradients.py . Customizing the get_jk() method of a SCF class using DF: examples/df/42-overwrite_get_jk.py ."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "df",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Kohn-Sham density functional theory (KS-DFT) has been implemented through derived classes of the pyscf.scf.hf.SCF parent class. As such, the methods and capabilities introduced in Self-consistent field (SCF) methods are also available to the dft module, e.g., the efficient second-order Newton-Raphso"
      }
    ],
    "parent_section": "dft",
    "description": "Kohn-Sham density functional theory (KS-DFT) has been implemented through derived classes of the pyscf.scf.hf.SCF parent class. As such, the methods and capabilities introduced in Self-consistent field (SCF) methods are also available to the dft module, e.g., the efficient second-order Newton-Raphson algorithm. A minimal example of using the dft module reads, cf. dft/22-newton.py : >>> from pyscf import gto , dft >>> mol_hf = gto . M ( atom = 'H 0 0 0; F 0 0 1.1' , basis = 'ccpvdz' , symmetry = True ) >>> mf_hf = dft . RKS ( mol_hf ) >>> mf_hf . xc = 'lda,vwn' # default >>> mf_hf = mf_hf . newton () # second-order algortihm >>> mf_hf . kernel () This will run a restricted, closed-shell Kohn-Sham DFT calculation with the default LDA functional."
  },
  {
    "name": "Theory",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Theory {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In KS-DFT, as first proposed by Kohn and Sham [ 18 ] , the electron density of a reference noninteracting system is used to represent the density of the true interacting system. As a result, the computational formulation of KS-DFT resembles that of Hartree-Fock (HF) theory, but with a different effe"
      }
    ],
    "parent_section": "dft",
    "description": "In KS-DFT, as first proposed by Kohn and Sham [ 18 ] , the electron density of a reference noninteracting system is used to represent the density of the true interacting system. As a result, the computational formulation of KS-DFT resembles that of Hartree-Fock (HF) theory, but with a different effective Fock potential. In KS-DFT, the total electronic energy is defined as follows: \\[E = T_s + E_{\\rm ext} + E_J + E_{\\rm xc} \\ .\\] Here, \\(T_s\\) is the noninteracting kinetic energy, \\(E_{\\rm ext}\\) is the energy due to the external potential, \\(E_J\\) is the Coulomb energy, and \\(E_{\\rm xc}\\) is the exchange-correlation ( xc ) energy. In practice, \\(E_{\\rm xc}\\) is approximated by a density functional approximation, which themselves may be divided into several classes along different rungs of "
  },
  {
    "name": "Predefined_xc_Functionals_and_Functional_Aliases",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Predefined_xc_Functionals_and_Functional_Aliases {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The choice of xc functional is assigned via the attribute DFT.xc . This is a comma separated string (precise grammar discussed below , e.g., xc = 'pbe,pbe' denotes PBE exchange plus PBE correlation. In common usage, a single name (alias) is often used to refer to the combination of a particular exch"
      }
    ],
    "parent_section": "dft",
    "description": "The choice of xc functional is assigned via the attribute DFT.xc . This is a comma separated string (precise grammar discussed below , e.g., xc = 'pbe,pbe' denotes PBE exchange plus PBE correlation. In common usage, a single name (alias) is often used to refer to the combination of a particular exchange and correlation approximation instead. To support this, PySCF will first examine a lookup table to see if DFT.xc corresponds to a common compound name, and if so, the implementation dispatches to the appropriate exchange and correlation forms, e.g., xc = 'pbe' directly translates to xc = 'pbe,pbe' . However, if the name is not found in the compound functional table, and only a single string is given, it will be treated as an exchange functional only, e.g., xc = 'b86' leads to B86 exchange o"
  },
  {
    "name": "Customizing_xc_functionals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Customizing_xc_functionals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The xc functional of choice can be customized. The simplest way to customize to achieve this is to assign a string expression to the DFT.xc attribute: >>> HF_X , LDA_X = .6 , .08 >>> B88_X = 1. - HF_X - LDA_X >>> LYP_C = .81 >>> VWN_C = 1. - LYP_C >>> mf_hf . xc = f ' { HF_X :} * HF + { LDA_X :} * L"
      }
    ],
    "parent_section": "dft",
    "description": "The xc functional of choice can be customized. The simplest way to customize to achieve this is to assign a string expression to the DFT.xc attribute: >>> HF_X , LDA_X = .6 , .08 >>> B88_X = 1. - HF_X - LDA_X >>> LYP_C = .81 >>> VWN_C = 1. - LYP_C >>> mf_hf . xc = f ' { HF_X :} * HF + { LDA_X :} * LDA + { B88_X :} * B88, { LYP_C :} * LYP + { VWN_C :} * VWN' >>> mf_hf . kernel () >>> mf_hf . xc = 'hf' >>> mf_hf . kernel () The XC functional string is parsed against a set of rules, as described below. The given functional description must be a one-line string The functional description is case-insensitive The functional description string has two parts, separated by a , .  The first part describes the exchange functional, the second part sets the correlation functional (as for aliases ) If a"
  },
  {
    "name": "Numerical_integration_grids",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Numerical_integration_grids {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF implements several numerical integration grids, which can be tuned in KS-DFT calculations following the examples in dft/11-grid_scheme.py . For instance, predefined grids (identical to those used in TURBOMOLE ) may be set by using levels from 0 (very sparse) to 9 (very dense), with a default v"
      }
    ],
    "parent_section": "dft",
    "description": "PySCF implements several numerical integration grids, which can be tuned in KS-DFT calculations following the examples in dft/11-grid_scheme.py . For instance, predefined grids (identical to those used in TURBOMOLE ) may be set by using levels from 0 (very sparse) to 9 (very dense), with a default values of 3 , cf. pyscf/dft/gen_grid.py for more details. Likewise, the default integration grids use Bragg radii for atoms, Treutler-Ahlrichs radial grids, Becke partitioning for grid weights, the pruning scheme of NWChem, and mesh grids, which are all setting that may be overwritten: >>> mf_hf . grids . level = 5 >>> mf_hf . radi_method = dft . gauss_chebeshev >>> mf_hf . grids . prune = None # disabling pruning of grids near core regions In addition, these grids can be used for the general num"
  },
  {
    "name": "Dispersion_corrections",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Dispersion_corrections {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Adding dispersion (van der Waals) corrections to KS-DFT calculations requires the pyscf-dispersion extension,\nwhich implements a simplified interface to simple-dftd3 and dftd4 libraries. It is recommended to enable D3 [ 23 ] , D4 dispersion corrections through the KS class instantiation.\nThe values "
      }
    ],
    "parent_section": "dft",
    "description": "Adding dispersion (van der Waals) corrections to KS-DFT calculations requires the pyscf-dispersion extension,\nwhich implements a simplified interface to simple-dftd3 and dftd4 libraries. It is recommended to enable D3 [ 23 ] , D4 dispersion corrections through the KS class instantiation.\nThe values of attributes nlc, disp, and xc of KS object are automatically configured in this way.\nBoth the mol.KS method or dft.RKS function can be used,\ncf. dft/16-dft_d3.py : >>> mf_d3 = mol_hf . KS ( xc = 'wb97x-d4' ) >>> #mf_d3 = mol_hf.KS(xc='b3lyp-d3bj') >>> #mf_d3 = mol_hf.KS(xc='b3lyp-d3zero') >>> mf_d3 . kernel () Alternatively, non-local correlation may be added through the VV10 functional [ 24 ] ,\ncf. dft/33-nlc_functionals.py : >>> mf_nlc = dft . RKS ( mol_hf ) >>> mf_nlc . xc = 'wb97m_v' >>> m"
  },
  {
    "name": "Generalized_KS_and_collinearity",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Generalized_KS_and_collinearity {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "When the Hamiltonian does not commute with \\(\\hat{S}_z\\) , e.g. in the presence of spin-orbit coupling, generalized Kohn-Sham theory (GKS) can be invoked by mf = dft.GKS(mol) , cf. generalized calculations and examples/dft/02-gks.py . A molecular orbital from GKS may contain both spin-up and spin-do"
      }
    ],
    "parent_section": "dft",
    "description": "When the Hamiltonian does not commute with \\(\\hat{S}_z\\) , e.g. in the presence of spin-orbit coupling, generalized Kohn-Sham theory (GKS) can be invoked by mf = dft.GKS(mol) , cf. generalized calculations and examples/dft/02-gks.py . A molecular orbital from GKS may contain both spin-up and spin-down components. As a result, the spin magnetization vector may no longer be in the collinear form \\(\\mathbf{m} = (0,0,m_z)\\) that an unrestricted calculation yields and which widely used collinear xc functionals assume. To handle any spin configuration, PySCF supports the non-collinear xc functionals from mcfun [ 25 ] via setting the DFT attribute collinear = 'mcol' , cf. examples/dft/14-collinear_gks.py . Such a non-collinear functional generalizes the widely used collinear functionals that depe"
  },
  {
    "name": "Periodic_Boundary_Conditions",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Periodic_Boundary_Conditions {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Besides finite-sized systems, PySCF further supports KS-DFT calculations with PBCs for performing solid-state calculations. The APIs for molecular and crystalline KS-DFT calculations have deliberately been made to align to the greatest extent possible, and an all-electron KS-DFT calculation for an i"
      }
    ],
    "parent_section": "dft",
    "description": "Besides finite-sized systems, PySCF further supports KS-DFT calculations with PBCs for performing solid-state calculations. The APIs for molecular and crystalline KS-DFT calculations have deliberately been made to align to the greatest extent possible, and an all-electron KS-DFT calculation for an initialized Cell object at either the \\(\\Gamma\\) -point or with k-point sampling may be run through dft and pbc.dft , respectively. For more details on PBC functionalities, please see the dedicated sections on PBC-KS-DFT ."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "dft",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Because nuclei are much heavier than the electrons, one usually assumes the Born-Oppenheimer (BO) approximation, which\ndefines an adiabatic electronic wavefunction for fixed nuclear positions. However, this approximation breaks down when the electronic states both change very rapidly with nuclear po"
      }
    ],
    "parent_section": "eph",
    "description": "Because nuclei are much heavier than the electrons, one usually assumes the Born-Oppenheimer (BO) approximation, which\ndefines an adiabatic electronic wavefunction for fixed nuclear positions. However, this approximation breaks down when the electronic states both change very rapidly with nuclear position and approach each other in energy. To move beyond the BO approximation, one can assume that the electrons experience the moving nuclei as a perturbation of the external potential. Carrying out an expansion to linear order in nuclear positions and assuming quadratic nuclear motion around the minimum leads to an approximate Hamiltonian for the electron and nuclear motion\nknown as the linear electron-phonon coupling approximation. When deriving this Hamiltonian, the electronic degrees of fre"
  },
  {
    "name": "Spin_symmetry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The eph module in PySCF supports mean field methods including Hartree Fock and DFT using either spin-restricted or spin-unrestricted reference. Analytical eph matrix elements # The module-level eph.EPH(mf) constructor can infer the correct method based\non the type of the mf argument.  For more expli"
      }
    ],
    "parent_section": "eph",
    "description": "The eph module in PySCF supports mean field methods including Hartree Fock and DFT using either spin-restricted or spin-unrestricted reference. Analytical eph matrix elements # The module-level eph.EPH(mf) constructor can infer the correct method based\non the type of the mf argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in rhf.py , uhf.py , rks.py and uks.py . For example, a spin-unrestricted calculation can be performed\nas follows: mf = scf . UHF ( mol ) . run () myeph = eph . uhf . EPH ( mf ) ephmat , omega = myeph . kernel () print ( 'eph matrix' , ephmat ) print ( 'phonon frequencies' , omega ) Finite difference # The finite difference kernel function eph.eph_fd.kernel can handle all the supported mean field methods above."
  },
  {
    "name": "Analytical_eph_matrix_elements",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Analytical_eph_matrix_elements {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The module-level eph.EPH(mf) constructor can infer the correct method based\non the type of the mf argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in rhf.py , uhf.py , rks.py and uks.py . For example, a spin-unrestricted calculation can be perform"
      }
    ],
    "parent_section": "eph",
    "description": "The module-level eph.EPH(mf) constructor can infer the correct method based\non the type of the mf argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in rhf.py , uhf.py , rks.py and uks.py . For example, a spin-unrestricted calculation can be performed\nas follows: mf = scf . UHF ( mol ) . run () myeph = eph . uhf . EPH ( mf ) ephmat , omega = myeph . kernel () print ( 'eph matrix' , ephmat ) print ( 'phonon frequencies' , omega )"
  },
  {
    "name": "Finite_difference",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Finite_difference {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The finite difference kernel function eph.eph_fd.kernel can handle all the supported mean field methods above."
      }
    ],
    "parent_section": "eph",
    "description": "The finite difference kernel function eph.eph_fd.kernel can handle all the supported mean field methods above."
  },
  {
    "name": "Output_control",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Output_control {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Filtering noisy frequencies # The diagonalization of the mass-weighted hessian can sometimes yield unphysical vibrational modes that correspond to imaginary frequencies or to non-zero frequencies which should strictly vanish. These unphysical modes may arise either from the use of not fully relaxed "
      }
    ],
    "parent_section": "eph",
    "description": "Filtering noisy frequencies # The diagonalization of the mass-weighted hessian can sometimes yield unphysical vibrational modes that correspond to imaginary frequencies or to non-zero frequencies which should strictly vanish. These unphysical modes may arise either from the use of not fully relaxed geometries, the use of insufficiently accurate density functional quadrature, or simply numerical noise. By default, modes below 80 cm-1 are filtered out in PySCF; note that this also includes any negative frequencies. One can specify a different cutoff frequency (in cm-1) when constructing the EPH object as follows: myeph = eph . EPH ( mf , cutoff_frequency = 60 ) ephmat , omega = myeph . kernel () Similarly, to keep the imaginary frequencies, one can set keep_imag_frequency to True when initia"
  },
  {
    "name": "Filtering_noisy_frequencies",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Filtering_noisy_frequencies {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The diagonalization of the mass-weighted hessian can sometimes yield unphysical vibrational modes that correspond to imaginary frequencies or to non-zero frequencies which should strictly vanish. These unphysical modes may arise either from the use of not fully relaxed geometries, the use of insuffi"
      }
    ],
    "parent_section": "eph",
    "description": "The diagonalization of the mass-weighted hessian can sometimes yield unphysical vibrational modes that correspond to imaginary frequencies or to non-zero frequencies which should strictly vanish. These unphysical modes may arise either from the use of not fully relaxed geometries, the use of insufficiently accurate density functional quadrature, or simply numerical noise. By default, modes below 80 cm-1 are filtered out in PySCF; note that this also includes any negative frequencies. One can specify a different cutoff frequency (in cm-1) when constructing the EPH object as follows: myeph = eph . EPH ( mf , cutoff_frequency = 60 ) ephmat , omega = myeph . kernel () Similarly, to keep the imaginary frequencies, one can set keep_imag_frequency to True when initializing the object: myeph = eph"
  },
  {
    "name": "Matrix_element_representation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Matrix_element_representation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The eph matrix is computed in the atomic orbital (AO) basis by default. One can also request it in the MO basis as follows: myeph = eph . EPH ( mf ) ephmat , omega = myeph . kernel ( mo_rep = True )"
      }
    ],
    "parent_section": "eph",
    "description": "The eph matrix is computed in the atomic orbital (AO) basis by default. One can also request it in the MO basis as follows: myeph = eph . EPH ( mf ) ephmat , omega = myeph . kernel ( mo_rep = True )"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "eph",
    "description": "Show Source"
  },
  {
    "name": "How_to_install_extensions",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "How_to_install_extensions {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Many extension modules (e.g., the semiempirical module) can be\ninstalled using pip’s extra dependency mechanism, pip install pyscf [ semiempirical ] Although not recommended, all extension modules can be installed, pip install pyscf [ all ]"
      }
    ],
    "parent_section": "extensions",
    "description": "Many extension modules (e.g., the semiempirical module) can be\ninstalled using pip’s extra dependency mechanism, pip install pyscf [ semiempirical ] Although not recommended, all extension modules can be installed, pip install pyscf [ all ]"
  },
  {
    "name": "How_to_install_extensions_advanced",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "How_to_install_extensions_advanced {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Based on the technique of namespace packages specified in PEP\n420 , PySCF has developed a couple\nof methods to install the extension modules. Pip command # For pip version newer than 19.0, projects hosted on GitHub can be installed on\nthe command line, pip install git+https://github.com/pyscf/semiem"
      }
    ],
    "parent_section": "extensions",
    "description": "Based on the technique of namespace packages specified in PEP\n420 , PySCF has developed a couple\nof methods to install the extension modules. Pip command # For pip version newer than 19.0, projects hosted on GitHub can be installed on\nthe command line, pip install git+https://github.com/pyscf/semiempirical A particular release on GitHub can be installed with the release URL you can\nlook up on GitHub, pip install https://github.com/pyscf/semiempirical/archive/v0.1.0.tar.gz Pip command for local paths # If you wish to load an extension module developed in a local directory, you can\nuse the local install mode of pip. Use of a Python virtual environment is\nrecommended to avoid polluting the system default Python runtime environment,\nfor example, python -m venv /home/abc/pyscf-local-env source "
  },
  {
    "name": "Pip_command",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Pip_command {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For pip version newer than 19.0, projects hosted on GitHub can be installed on\nthe command line, pip install git+https://github.com/pyscf/semiempirical A particular release on GitHub can be installed with the release URL you can\nlook up on GitHub, pip install https://github.com/pyscf/semiempirical/a"
      }
    ],
    "parent_section": "extensions",
    "description": "For pip version newer than 19.0, projects hosted on GitHub can be installed on\nthe command line, pip install git+https://github.com/pyscf/semiempirical A particular release on GitHub can be installed with the release URL you can\nlook up on GitHub, pip install https://github.com/pyscf/semiempirical/archive/v0.1.0.tar.gz"
  },
  {
    "name": "Pip_command_for_local_paths",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Pip_command_for_local_paths {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If you wish to load an extension module developed in a local directory, you can\nuse the local install mode of pip. Use of a Python virtual environment is\nrecommended to avoid polluting the system default Python runtime environment,\nfor example, python -m venv /home/abc/pyscf-local-env source /home/a"
      }
    ],
    "parent_section": "extensions",
    "description": "If you wish to load an extension module developed in a local directory, you can\nuse the local install mode of pip. Use of a Python virtual environment is\nrecommended to avoid polluting the system default Python runtime environment,\nfor example, python -m venv /home/abc/pyscf-local-env source /home/abc/pyscf-local-env/bin/activate\ngit clone https://github.com/pyscf/semiempirical /home/abc/semiempirical\npip install -e /home/abc/semiempirical"
  },
  {
    "name": "Environment_variable_PYSCF_EXT_PATH",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Environment_variable_PYSCF_EXT_PATH {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "You can place the location of each extension module (or a file that contains\nthese locations) in this environment variable. The PySCF library will parse the\npaths defined in this environment variable, and load the relevant submodules.\nFor example, git clone https://github.com/pyscf/semiempirical /ho"
      }
    ],
    "parent_section": "extensions",
    "description": "You can place the location of each extension module (or a file that contains\nthese locations) in this environment variable. The PySCF library will parse the\npaths defined in this environment variable, and load the relevant submodules.\nFor example, git clone https://github.com/pyscf/semiempirical /home/abc/semiempirical\ngit clone https://github.com/pyscf/doci /home/abc/doci\ngit clone https://github.com/pyscf/dftd3 /home/abc/dftd3 echo /home/abc/doci > /home/abc/.pyscf_ext_modules echo /home/abc/dftd3 >> /home/abc/.pyscf_ext_modules export PYSCF_EXT_PATH = /home/abc/semiempirical:/home/abc/.pyscf_ext_modules Using this definition of PYSCF_EXT_PATH , the three extension\nsubmodules (semiempirical, doci, dftd3) are loaded when PySCF is\nimported, and you don’t have to use a Python virtual enviro"
  },
  {
    "name": "Examples",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Examples {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Installing DMRG solvers # The Density Matrix Renormalization Group (DMRG) theory is a method for solving ab initio quantum chemistry problems.\nPySCF can be used with three implementations of DMRG: Block , block2 , and CheMPS2 . Installing Block requires a C++11\ncompiler. Alternatively, you can downl"
      }
    ],
    "parent_section": "extensions",
    "description": "Installing DMRG solvers # The Density Matrix Renormalization Group (DMRG) theory is a method for solving ab initio quantum chemistry problems.\nPySCF can be used with three implementations of DMRG: Block , block2 , and CheMPS2 . Installing Block requires a C++11\ncompiler. Alternatively, you can download the precompiled Block binary from https://sanshar.github.io/Block/build.html . block2 can be easily installed via pip install block2 or pip install block2-mpi .\nTo building block2 from source, please refer to the installation guide https://block2.readthedocs.io/en/latest/user/installation.html . Before using Block or CheMPS2, you need create a configuration file pyscf/dmrgscf/settings.py (as shown by the settings.py.example ) to\nstore the path where the DMRG solver was installed. Installing "
  },
  {
    "name": "Installing_DMRG_solvers",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Installing_DMRG_solvers {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The Density Matrix Renormalization Group (DMRG) theory is a method for solving ab initio quantum chemistry problems.\nPySCF can be used with three implementations of DMRG: Block , block2 , and CheMPS2 . Installing Block requires a C++11\ncompiler. Alternatively, you can download the precompiled Block "
      }
    ],
    "parent_section": "extensions",
    "description": "The Density Matrix Renormalization Group (DMRG) theory is a method for solving ab initio quantum chemistry problems.\nPySCF can be used with three implementations of DMRG: Block , block2 , and CheMPS2 . Installing Block requires a C++11\ncompiler. Alternatively, you can download the precompiled Block binary from https://sanshar.github.io/Block/build.html . block2 can be easily installed via pip install block2 or pip install block2-mpi .\nTo building block2 from source, please refer to the installation guide https://block2.readthedocs.io/en/latest/user/installation.html . Before using Block or CheMPS2, you need create a configuration file pyscf/dmrgscf/settings.py (as shown by the settings.py.example ) to\nstore the path where the DMRG solver was installed."
  },
  {
    "name": "Installing_TBLIS",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Installing_TBLIS {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "TBLIS provides a native algorithm for\nperforming tensor contraction for arbitrarily high-dimensional tensors. Unlike\nthe implementation in numpy.einsum , which transforms tensors into matrices by\npermuting the indices, invokes BLAS for matrix contractions, and then\nback-permutes the results, TBLIS e"
      }
    ],
    "parent_section": "extensions",
    "description": "TBLIS provides a native algorithm for\nperforming tensor contraction for arbitrarily high-dimensional tensors. Unlike\nthe implementation in numpy.einsum , which transforms tensors into matrices by\npermuting the indices, invokes BLAS for matrix contractions, and then\nback-permutes the results, TBLIS eliminates the need for tensor transpositions\nand data movements. TBLIS eliminates the need to transpose tensors and data\nmovements. This results in improved performance in various correlated quantum\nchemistry methods in PySCF, such as the coupled cluster methods. The tblis-einsum extension provides an interface to TBLIS, which offers an\nefficient implementation for tensor contractions in the style of numpy.einsum .\nThe tblis-einsum plugin can be installed using the command: $ pip install pyscf-t"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "extensions",
    "description": "Show Source"
  },
  {
    "name": "Basics",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Basics {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF implements geometry optimization via\ninterfaces to geomeTRIC and PyBerny , and through PySCF extension qsdopt <https://github.com/pyscf/qsdopt>`_(see :ref:`installing for installation instructions). There are two ways to invoke geometry optimization.\nThe first is to import the optimize() funct"
      }
    ],
    "parent_section": "geomopt",
    "description": "PySCF implements geometry optimization via\ninterfaces to geomeTRIC and PyBerny , and through PySCF extension qsdopt <https://github.com/pyscf/qsdopt>`_(see :ref:`installing for installation instructions). There are two ways to invoke geometry optimization.\nThe first is to import the optimize() function\nfrom the respective modules, i.e., pyscf.geomopt.geometric_solver and pyscf.geomopt.berny_solver : from pyscf import gto , scf mol = gto . M ( atom = 'N 0 0 0; N 0 0 1.2' , basis = 'ccpvdz' ) mf = scf . RHF ( mol ) # geometric from pyscf.geomopt.geometric_solver import optimize mol_eq = optimize ( mf , maxsteps = 100 ) print ( mol_eq . tostring ()) # pyberny from pyscf.geomopt.berny_solver import optimize mol_eq = optimize ( mf , maxsteps = 100 ) print ( mol_eq . tostring ()) The second way "
  },
  {
    "name": "Constraints",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Constraints {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "geomeTRIC supports user defined constraints. The constraints can\nbe specified in a text file. Its format can be found\nin the online documentation or in the template file .\nThen the name of the constraints file needs to be passed to PySCF: params = { \"constraints\" : \"constraints.txt\" ,} mol_eq = opti"
      }
    ],
    "parent_section": "geomopt",
    "description": "geomeTRIC supports user defined constraints. The constraints can\nbe specified in a text file. Its format can be found\nin the online documentation or in the template file .\nThen the name of the constraints file needs to be passed to PySCF: params = { \"constraints\" : \"constraints.txt\" ,} mol_eq = optimize ( mf , ** params ) mol_eq = mf . Gradients () . optimizer ( solver = 'geomeTRIC' ) . kernel ( params ) The geometry optimization can also be carried out based on\ncustom energy and gradient functions: #!/usr/bin/env python ''' For the customized energy and gradients function (e.g. adding DFT-D3 correction), a fake pyscf method need to be created before passing to berny_solver. ''' import numpy as np from pyscf import gto , scf from pyscf.geomopt import berny_solver , geometric_solver , as_py"
  },
  {
    "name": "Transition_state_optimization",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Transition_state_optimization {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Transition state optimization are available in geomeTRIC and qsdopt . The PySCF extension qsdopt performs transition\nstate optimizations through quadratic steepest descent method This is a second order method that requires computation of the hessian at some steps during\nthe optimization process. The"
      }
    ],
    "parent_section": "geomopt",
    "description": "Transition state optimization are available in geomeTRIC and qsdopt . The PySCF extension qsdopt performs transition\nstate optimizations through quadratic steepest descent method This is a second order method that requires computation of the hessian at some steps during\nthe optimization process. The following is a minimal usage example: from pyscf imort gto , scf from pyscf.qsdopt.qsd_optimizer import QSD mol = gto . M ( atom = ''' O 0 0 0 H 0 0 1.2 H 0, 0.5, -1.2''' , basis = 'minao' , verbose = 0 , unit = \"Bohr\" ) mf = scf . RHF ( mol ) optimizer = QSD ( mf , stationary_point = \"TS\" ) optimizer . kernel () Several keyword arguments can be passed to kernel : hess_update_freq: Frequency for numerical reevaluation of hessian. = 0 evaluates the numerical\nhessian in the first iteration and is"
  },
  {
    "name": "Excited_states",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Excited_states {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For excited-state geometry optimizations, the state to be optimized\nneeds to be specified in the respective Gradients objects: #!/usr/bin/env python ''' Optimize the geometry of the excited states Note when optiming the excited states, states may flip and this may cause convergence issue in geometry"
      }
    ],
    "parent_section": "geomopt",
    "description": "For excited-state geometry optimizations, the state to be optimized\nneeds to be specified in the respective Gradients objects: #!/usr/bin/env python ''' Optimize the geometry of the excited states Note when optiming the excited states, states may flip and this may cause convergence issue in geometry optimizer. ''' from pyscf import gto from pyscf import scf from pyscf import ci , tdscf , mcscf from pyscf import geomopt mol = gto . Mole () mol . atom = \"N; N 1, 1.1\" mol . basis = \"6-31g\" mol . build () mol1 = mol . copy () mf = scf . RHF ( mol ) . run () mc = mcscf . CASCI ( mf , 4 , 4 ) mc . fcisolver . nstates = 3 excited_grad = mc . nuc_grad_method () . as_scanner ( state = 2 ) mol1 = excited_grad . optimizer () . kernel () # or #mol1 = geomopt.optimize(excited_grad) td = tdscf . TDHF ( "
  },
  {
    "name": "Callback",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Callback {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Callback functions can be invoked at each optimization step.\nThe following example shows how to add charge analysis for each\ngeometry during the optimization. #!/usr/bin/env python ''' Optimize molecular geometry within the environment of QM/MM charges. ''' from pyscf import gto , scf from pyscf.geo"
      }
    ],
    "parent_section": "geomopt",
    "description": "Callback functions can be invoked at each optimization step.\nThe following example shows how to add charge analysis for each\ngeometry during the optimization. #!/usr/bin/env python ''' Optimize molecular geometry within the environment of QM/MM charges. ''' from pyscf import gto , scf from pyscf.geomopt import berny_solver from pyscf.geomopt import geometric_solver mol = gto . M ( atom = ''' C        0.000000    0.000000             -0.542500 O        0.000000    0.000000              0.677500 H        0.000000    0.9353074360871938   -1.082500 H        0.000000   -0.9353074360871938   -1.082500 ''' , basis = '3-21g' ) mf = scf . RHF ( mol ) # Run analyze function in callback def cb ( envs ): mf = envs [ 'g_scanner' ] . base mf . analyze ( verbose = 4 ) # # Method 1: Pass callback to optim"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "geomopt",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Modern GPUs accelerate quantum chemistry calculation significantly, but also have an advantage in cost saving [1] [2] .\nSome of basic PySCF modules, such as SCF and DFT, are accelerated with GPU via a plugin package\nGPU4PySCF (See the end of this page for the supported functionalities). For the dens"
      }
    ],
    "parent_section": "gpu",
    "description": "Modern GPUs accelerate quantum chemistry calculation significantly, but also have an advantage in cost saving [1] [2] .\nSome of basic PySCF modules, such as SCF and DFT, are accelerated with GPU via a plugin package\nGPU4PySCF (See the end of this page for the supported functionalities). For the density fitting scheme,\nGPU4PySCF on A100-80G can be 1000x faster than PySCF on single-core CPU. The speedup of direct SCF scheme is relatively low."
  },
  {
    "name": "Installation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Installation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The binary package of GPU4PySCF is released based on the CUDA version. CUDA version GPU4PySCF cuTensor CUDA 11.x pip3 install gpu4pyscf-cuda11x pip3 install cutensor-cu11 CUDA 12.x pip3 install gpu4pyscf-cuda12x pip3 install cutensor-cu12"
      }
    ],
    "parent_section": "gpu",
    "description": "The binary package of GPU4PySCF is released based on the CUDA version. CUDA version GPU4PySCF cuTensor CUDA 11.x pip3 install gpu4pyscf-cuda11x pip3 install cutensor-cu11 CUDA 12.x pip3 install gpu4pyscf-cuda12x pip3 install cutensor-cu12"
  },
  {
    "name": "Usage_of_GPU4PySCF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Usage_of_GPU4PySCF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The GPU4PySCF APIs are designed to maintain compatibility with PySCF. The\nclasses and methods in GPU4PySCF are named identically to those in PySCF,\nensuring a familiar interface for users. However, GPU4PySCF classes do not\ndirectly inherit from PySCF classes. PySCF objects and GPU4PySCF objects can "
      }
    ],
    "parent_section": "gpu",
    "description": "The GPU4PySCF APIs are designed to maintain compatibility with PySCF. The\nclasses and methods in GPU4PySCF are named identically to those in PySCF,\nensuring a familiar interface for users. However, GPU4PySCF classes do not\ndirectly inherit from PySCF classes. PySCF objects and GPU4PySCF objects can be converted to each other using the to_gpu() and to_cpu() methods.\nThe conversion process can automatically, recursively translate all attributes between GPU and CPU instances.\nFor example, numpy arrays on the CPU are converted into CuPy arrays on the GPU, and vice versa.\nIf certain attributes are exclusive to either the CPU or GPU, these attributes will be appropriately handled.\nThey are omitted or specifically converted, depending on the target platform. There are two approaches to execute th"
  },
  {
    "name": "GPU4PySCF_and_PySCF_Hybrid_Programming",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "GPU4PySCF_and_PySCF_Hybrid_Programming {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "GPU4PySCF allows for seamless integration with existing PySCF programs, enabling\na hybrid approach that leverages both CPU and GPU resources in the program. This\nintegration is facilitated through the use of to_gpu() and to_cpu() functions, which convert PySCF instances between CPU and GPU. For inst"
      }
    ],
    "parent_section": "gpu",
    "description": "GPU4PySCF allows for seamless integration with existing PySCF programs, enabling\na hybrid approach that leverages both CPU and GPU resources in the program. This\nintegration is facilitated through the use of to_gpu() and to_cpu() functions, which convert PySCF instances between CPU and GPU. For instance, we can perform DFT calculations on GPU to obtain a set of DFT\norbitals followed by orbital localization using the Boys method on the CPU: import pyscf from pyscf import lo mol = pyscf . M ( atom = ''' O       0.0000000000    -0.0000000000     0.1174000000 H      -0.7570000000    -0.0000000000    -0.4696000000 H       0.7570000000     0.0000000000    -0.4696000000 ''' , basis = 'def2-tzvpp' ) # Perform DFT computation on GPU mf = mol . RKS ( xc = 'b3lyp' ) . to_gpu () . run () # Transfer th"
  },
  {
    "name": "Functionalities_supported_by_GPU4PySCF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Functionalities_supported_by_GPU4PySCF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Method SCF Gradient Hessian direct SCF O GPU CPU density fitting O O O LDA O O O GGA O O O mGGA O O O hybrid O O O unrestricted O O O PCM solvent GPU GPU FD SMD solvent GPU GPU FD dispersion correction CPU* CPU* FD nonlocal correlation O O NA ECP CPU CPU CPU MP2 GPU CPU CPU CCSD GPU CPU NA ‘O’: care"
      }
    ],
    "parent_section": "gpu",
    "description": "Method SCF Gradient Hessian direct SCF O GPU CPU density fitting O O O LDA O O O GGA O O O mGGA O O O hybrid O O O unrestricted O O O PCM solvent GPU GPU FD SMD solvent GPU GPU FD dispersion correction CPU* CPU* FD nonlocal correlation O O NA ECP CPU CPU CPU MP2 GPU CPU CPU CCSD GPU CPU NA ‘O’: carefully optimized for GPU. ‘CPU’: only cpu implementation. ‘GPU’: drop-in replacement or naive implementation. ‘FD’: use finite-difference gradient to approximate the exact Hessian matrix. ’NA’: not available. ‘CPU*’: DFTD3 [100]/DFTD4 [101] on CPU."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "gpu",
    "description": "Show Source"
  },
  {
    "name": "Initializing_a_molecule",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initializing_a_molecule {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "There are three ways to define and initialize a molecule. The first is to use\nthe keyword arguments of the Mole.build() method to initialize a molecule: >>> from pyscf import gto >>> mol = gto . Mole () >>> mol . build ( ... atom = '''O 0 0 0; H  0 1 0; H 0 0 1''' , ... basis = 'sto-3g' ) The second"
      }
    ],
    "parent_section": "gto",
    "description": "There are three ways to define and initialize a molecule. The first is to use\nthe keyword arguments of the Mole.build() method to initialize a molecule: >>> from pyscf import gto >>> mol = gto . Mole () >>> mol . build ( ... atom = '''O 0 0 0; H  0 1 0; H 0 0 1''' , ... basis = 'sto-3g' ) The second way is to assign the geometry, basis etc., to the Mole object, followed by calling the build() method: >>> from pyscf import gto >>> mol = gto . Mole () >>> mol . atom = '''O 0 0 0; H  0 1 0; H 0 0 1''' >>> mol . basis = 'sto-3g' >>> mol . build () The third way is to use the shortcut functions pyscf.M() or Mole.M() .\nThese functions pass all the arguments to the build() method: >>> import pyscf >>> mol = pyscf . M ( ... atom = '''O 0 0 0; H  0 1 0; H 0 0 1''' , ... basis = 'sto-3g' ) >>> from "
  },
  {
    "name": "Geometry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Geometry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The molecular geometry can be input in Cartesian format\nwith the default unit being Angstrom\n(one can specify the unit by setting the attribute unit to either 'Angstrom' or 'Bohr' ): mol = gto . Mole () mol . atom = ''' O   0. 0. 0. H   0. 1. 0. H   0. 0. 1. ''' mol . unit = 'B' # case insensitive, "
      }
    ],
    "parent_section": "gto",
    "description": "The molecular geometry can be input in Cartesian format\nwith the default unit being Angstrom\n(one can specify the unit by setting the attribute unit to either 'Angstrom' or 'Bohr' ): mol = gto . Mole () mol . atom = ''' O   0. 0. 0. H   0. 1. 0. H   0. 0. 1. ''' mol . unit = 'B' # case insensitive, any string not starts by 'B' or 'AU' is treated as 'Angstrom' The atoms in the molecule are represented by an element symbol plus\nthree numbers for coordinates.  Different atoms should be separated by ; or a line break. In the same atom, , can be used to separate\ndifferent items. Blank lines or lines started with # will be\nignored: >>> mol = pyscf . M ( ... atom = ''' ... #O 0 0 0 ... H 0 1 0 ... ... H 0 0 1 ... ''' ) >>> mol . natm 2 The input parser also supports the Z-matrix input\nformat: mol"
  },
  {
    "name": "Basis_set",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Basis_set {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The simplest way to define the basis set is to assign the name of the\nbasis as a string to Mole.basis : mol . basis = 'sto-3g' This input will apply the specified basis set to all atoms. The name\nof the basis set in the string is case insensitive. White spaces,\ndashes and underscores in the name are"
      }
    ],
    "parent_section": "gto",
    "description": "The simplest way to define the basis set is to assign the name of the\nbasis as a string to Mole.basis : mol . basis = 'sto-3g' This input will apply the specified basis set to all atoms. The name\nof the basis set in the string is case insensitive. White spaces,\ndashes and underscores in the name are all ignored. If different\nbasis sets are required for different elements, a Python dict can\nbe used: mol . basis = { 'O' : 'sto-3g' , 'H' : '6-31g' } One can also input custom basis sets with the helper functions.\nThe function gto.basis.parse() can parse a basis string in the NWChem format\n( https://bse.pnl.gov/bse/portal ): mol . basis = { 'O' : gto . basis . parse ( ''' C    S 71.6168370              0.15432897 13.0450960              0.53532814 3.5305122              0.44463454 C    SP 2.941"
  },
  {
    "name": "Basis_format",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Basis_format {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Basis data can be a text file or a python file. The text file should store the\nbasis data in NWChem format. Most basis in PySCF were downloaded from https://www.basissetexchange.org/ . Some basis (mostly the cc-pV*Z basis) were\ndownloaded with the option “optimize general contractions” checked. The "
      }
    ],
    "parent_section": "gto",
    "description": "Basis data can be a text file or a python file. The text file should store the\nbasis data in NWChem format. Most basis in PySCF were downloaded from https://www.basissetexchange.org/ . Some basis (mostly the cc-pV*Z basis) were\ndownloaded with the option “optimize general contractions” checked. The python basis format stores the basis in the internal format which looks: [[ angular , kappa , [[ exp , c_1 , c_2 , .. ], [ exp , c_1 , c_2 , .. ], ... ]], [ angular , kappa , [[ exp , c_1 , c_2 , .. ], [ exp , c_1 , c_2 , .. ] ... ]]] The list [angular, kappa, [[exp, c, …]]] defines the angular momentum of the\nbasis, the kappa value, the Gaussian exponents and basis contraction coefficients. kappa can have value \\(-l-1\\) (corresponding to spinors with \\(j=l+1/2\\) ), \\(l\\) (corresponding to spino"
  },
  {
    "name": "Ordering_of_basis_functions",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Ordering_of_basis_functions {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "GTO basis functions are stored in the following order: (1) atoms, (2) angular momentum, (3) shells, (4) spherical harmonics. This means that basis functions are first grouped in terms of the atoms they are assigned to. On each atom, basis\nfunctions are grouped according to their angular momentum.\nFo"
      }
    ],
    "parent_section": "gto",
    "description": "GTO basis functions are stored in the following order: (1) atoms, (2) angular momentum, (3) shells, (4) spherical harmonics. This means that basis functions are first grouped in terms of the atoms they are assigned to. On each atom, basis\nfunctions are grouped according to their angular momentum.\nFor each value of the angular momentum, the individual shells\nare sorted from inner shells to outer shells, that is, from large exponents to small exponents.\nA shell can be a real atomic shell, formed as a linear combination of many Gaussians,\nor just a single primitive Gaussian function that may have several angular components.\nIn each shell, the spherical parts of the GTO basis follow the\nCondon-Shortley convention, with the ordering (and phase) given in the Wikipedia table of spherical harmonic"
  },
  {
    "name": "ECP",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ECP {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Effective core potentials (ECPs) can be specified with the attribute Mole.ecp .\nScalar type ECPs are available for all molecular and crystal methods.\nThe built-in scalar ECP datasets include Keyword Comment bfd cc-pvdz-pp cc-pvtz-pp same to cc-pvdz-pp cc-pvqz-pp same to cc-pvdz-pp cc-pv5z-pp same to"
      }
    ],
    "parent_section": "gto",
    "description": "Effective core potentials (ECPs) can be specified with the attribute Mole.ecp .\nScalar type ECPs are available for all molecular and crystal methods.\nThe built-in scalar ECP datasets include Keyword Comment bfd cc-pvdz-pp cc-pvtz-pp same to cc-pvdz-pp cc-pvqz-pp same to cc-pvdz-pp cc-pv5z-pp same to cc-pvdz-pp crenbl crenbs def2-svp def2-svpd same to def2-svp def2-tzvp same to def2-svp def2-tzvpd same to def2-svp def2-tzvpp same to def2-svp def2-tzvppd same to def2-svp def2-qzvp same to def2-svp def2-qzvpd same to def2-svp def2-qzvpp same to def2-svp def2-qzvppd same to def2-svp lanl2dz lanl2tz lanl08 sbkjc stuttgart ECP parameters can be specified directly in input script using NWChem format.\nExamples of ECP input can be found in examples/gto/05-input_ecp.py . Spin-orbit (SO) ECP integral"
  },
  {
    "name": "Point_group_symmetry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Point_group_symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "You can also invoke point group symmetry for molecular calculations\nby setting the attribute Mole.symmetry to True : >>> mol = pyscf . M ( ... atom = 'B 0 0 0; H 0 1 1; H 1 0 1; H 1 1 0' , ... symmetry = True ... ) The point group symmetry information is held in the Mole object.\nThe symmetry module "
      }
    ],
    "parent_section": "gto",
    "description": "You can also invoke point group symmetry for molecular calculations\nby setting the attribute Mole.symmetry to True : >>> mol = pyscf . M ( ... atom = 'B 0 0 0; H 0 1 1; H 1 0 1; H 1 1 0' , ... symmetry = True ... ) The point group symmetry information is held in the Mole object.\nThe symmetry module ( symm ) of PySCF can detect arbitrary point groups.\nThe detected point group is saved in Mole.topgroup ,\nand the supported subgroup is saved in Mole.groupname : >>> print ( mol . topgroup ) C3v >>> print ( mol . groupname ) Cs Currently, PySCF supports linear molecular symmetries \\(D_{\\infty h}\\) (labelled as Dooh in the program) and \\(C_{\\infty v}\\) (labelled as Coov ), the \\(D_{2h}\\) group and its subgroups.\nSometimes it is necessary to use a lower symmetry instead of the detected\nsymmetry gr"
  },
  {
    "name": "Spin_and_charge",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_and_charge {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Charge and the number of unpaired electrons can be assigned to Mole object: mol . charge = 1 mol . spin = 1 Note Mole.spin is the number of unpaired electrons 2S ,\ni.e. the difference between the number of alpha and beta electrons. These two attributes do not affect any other parameters\nin the Mole."
      }
    ],
    "parent_section": "gto",
    "description": "Charge and the number of unpaired electrons can be assigned to Mole object: mol . charge = 1 mol . spin = 1 Note Mole.spin is the number of unpaired electrons 2S ,\ni.e. the difference between the number of alpha and beta electrons. These two attributes do not affect any other parameters\nin the Mole.build initialization function.\nThey can be set or modified after the Mole object is initialized: >>> mol = gto . Mole () >>> mol . atom = 'O 0 0 0; h 0 1 0; h 0 0 1' >>> mol . basis = 'sto-6g' >>> mol . spin = 2 >>> mol . build () >>> print ( mol . nelec ) (6, 4) >>> mol . spin = 0 >>> print ( mol . nelec ) (5, 5) The attribute Mole.charge is the parameter to define the total number of electrons in the\nsystem. For custom systems such as the Hubbard lattice model, the total number\nof electrons ne"
  },
  {
    "name": "Other_parameters",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Other_parameters {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "You can assign more information to the molecular object: mol . nucmod = { 'O1' : 1 } # nuclear charge model: 0-point charge, 1-Gaussian distribution mol . mass = { 'O1' : 18 , 'H' : 2 } # atomic mass See examples/gto/07-nucmod.py for more examples of nuclear charge models. The Mole class also define"
      }
    ],
    "parent_section": "gto",
    "description": "You can assign more information to the molecular object: mol . nucmod = { 'O1' : 1 } # nuclear charge model: 0-point charge, 1-Gaussian distribution mol . mass = { 'O1' : 18 , 'H' : 2 } # atomic mass See examples/gto/07-nucmod.py for more examples of nuclear charge models. The Mole class also defines some global parameters.  You can control the\nprint level globally with verbose : mol . verbose = 4 The print level can be 0 (quiet, no output) to 9 (very noisy).  The\nmost useful messages are printed at level 4 (info) and 5 (debug).  You\ncan also specify a place where to write the output messages: mol . output = 'path/to/log.txt' If this variable is not assigned, messages will be dumped to sys.stdout . The maximum memory usage can be controlled globally: mol . max_memory = 1000 # MB The defaul"
  },
  {
    "name": "Access_AO_integrals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Access_AO_integrals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF uses libcint library as the AO\nintegral engine. A simple interface function Mole.intor() is provided\nto obtain the one- and two-electron AO integrals: kin = mol . intor ( 'int1e_kin' ) vnuc = mol . intor ( 'int1e_nuc' ) overlap = mol . intor ( 'int1e_ovlp' ) eri = mol . intor ( 'int2e' ) For a"
      }
    ],
    "parent_section": "gto",
    "description": "PySCF uses libcint library as the AO\nintegral engine. A simple interface function Mole.intor() is provided\nto obtain the one- and two-electron AO integrals: kin = mol . intor ( 'int1e_kin' ) vnuc = mol . intor ( 'int1e_nuc' ) overlap = mol . intor ( 'int1e_ovlp' ) eri = mol . intor ( 'int2e' ) For a full list of supported AO integrals, see pyscf.gto.moleintor module ."
  },
  {
    "name": "Initializing_Mean_Field_and_Post_SCF_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initializing_Mean_Field_and_Post_SCF_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In PySCF, both mean-field and post-SCF methods are provided as classes (see also How to use PySCF ). These classes can be imported and instantiated just like standard\nPython modules and functions. However, this requires users to remember the\nspecific paths to these modules or classes. To simplify th"
      }
    ],
    "parent_section": "gto",
    "description": "In PySCF, both mean-field and post-SCF methods are provided as classes (see also How to use PySCF ). These classes can be imported and instantiated just like standard\nPython modules and functions. However, this requires users to remember the\nspecific paths to these modules or classes. To simplify the initialization\nprocess, PySCF provides a convenient shortcut for initializing a mean-field or\npost-SCF method instance directly from the Mole instance. Instantiating Mean-Field Methods # Mean-field methods can be easily instantiated as follows: mf = mol . HF () mf = mol . KS () This approach automatically determines the appropriate mean-field method to use,\nsuch as restricted closed-shell, open-shell, or symmetry-adapted methods. By\ndefault:\n* Restricted closed-shell methods are used for molec"
  },
  {
    "name": "Instantiating_Mean_Field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Instantiating_Mean_Field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Mean-field methods can be easily instantiated as follows: mf = mol . HF () mf = mol . KS () This approach automatically determines the appropriate mean-field method to use,\nsuch as restricted closed-shell, open-shell, or symmetry-adapted methods. By\ndefault:\n* Restricted closed-shell methods are use"
      }
    ],
    "parent_section": "gto",
    "description": "Mean-field methods can be easily instantiated as follows: mf = mol . HF () mf = mol . KS () This approach automatically determines the appropriate mean-field method to use,\nsuch as restricted closed-shell, open-shell, or symmetry-adapted methods. By\ndefault:\n* Restricted closed-shell methods are used for molecules without unpaired electrons ( mol.spin=0 ).\n* Unrestricted methods (UHF, UKS) are used for molecules with unpaired electrons ( mol.spin > 0 ).\n* Symmetry-adapted methods are used if mol.symmetry is enabled."
  },
  {
    "name": "Explicit_Mean_field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Explicit_Mean_field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For more specific method instantiation, such as RHF, UKS, or GKS, the following can be used: mol.RHF() and mol.RKS() creates restricted Hartree-Fock or Kohn-Sham\nmethods. It can be used for molecules with unpaired electrons, leading to ROHF\nand ROKS methods. mol.ROHF() and mol.ROKS() are applicable "
      }
    ],
    "parent_section": "gto",
    "description": "For more specific method instantiation, such as RHF, UKS, or GKS, the following can be used: mol.RHF() and mol.RKS() creates restricted Hartree-Fock or Kohn-Sham\nmethods. It can be used for molecules with unpaired electrons, leading to ROHF\nand ROKS methods. mol.ROHF() and mol.ROKS() are applicable to molecules with mol.spin=0 .\nThey create restricted open-shell HF or KS methods, even though these systems\ncan be modeled by restricted closed-shell methods. mol.UHF() and mol.UKS() create unrestricted Hartree-Fock or Kohn-Sham\nmethods, regardless of the number of unpaired electrons in the molecule. mol.GHF() and mol.GKS() create generalized mean-field methods, which\nallow for the mixing of alpha and beta spins in the spin-orbitals. mol.DHF() and mol.DKS() create four-component Dirac-Coulomb m"
  },
  {
    "name": "Keyword_Parameters_for_Mean_field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Keyword_Parameters_for_Mean_field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "When creating mean-field methods, their configuration parameters such as conv_tol and max_cycle can be specified through keyword arguments of the\ninstantiation methods. For example, in DFT methods, the exchange-correlation\n(XC) functional can be specified using the xc keyword argument: mf = mol . RK"
      }
    ],
    "parent_section": "gto",
    "description": "When creating mean-field methods, their configuration parameters such as conv_tol and max_cycle can be specified through keyword arguments of the\ninstantiation methods. For example, in DFT methods, the exchange-correlation\n(XC) functional can be specified using the xc keyword argument: mf = mol . RKS ( xc = 'b3lyp' , conv_tol = 1e-6 ) mf = mol . GKS ( xc = 'pbe,p86' )"
  },
  {
    "name": "Instantiating_Post_SCF_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Instantiating_Post_SCF_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Post-SCF methods can be instantiated on top of a mean-field instance: mf = mol . HF () . run () mycc = mf . CCSD () Alternatively, you can bypass the creation of the mean-field instance and\ndirectly apply the post-SCF method on the Mole instance: mycc = mol . CCSD ( frozen = 1 ) This approach automa"
      }
    ],
    "parent_section": "gto",
    "description": "Post-SCF methods can be instantiated on top of a mean-field instance: mf = mol . HF () . run () mycc = mf . CCSD () Alternatively, you can bypass the creation of the mean-field instance and\ndirectly apply the post-SCF method on the Mole instance: mycc = mol . CCSD ( frozen = 1 ) This approach automatically creates a mean-field instance and applies the\npost-SCF method. Any keyword arguments for the post-SCF methods will be passed\nto the mf.CCSD() method. It is important to note that, unlike the\ninitialization of mean-field methods, configurational parameters for post-SCF\nmethods cannot be set through keyword arguments. They must be explicitly\nassigned to the post-SCF instance. For example, the initialization statement mol.CCSD(conv_tol=1e-5) will fail."
  },
  {
    "name": "MCSCF_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "MCSCF_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The initialization of MCSCF methods is similar to that of post-SCF methods. You\ncan first create a mean-field instance and then apply a MCSCF method. Applying\nMCSCF methods directly on the Mole instance will also automatically\ncreate a mean-field instance and apply the MCSCF method: norb_cas , nelec"
      }
    ],
    "parent_section": "gto",
    "description": "The initialization of MCSCF methods is similar to that of post-SCF methods. You\ncan first create a mean-field instance and then apply a MCSCF method. Applying\nMCSCF methods directly on the Mole instance will also automatically\ncreate a mean-field instance and apply the MCSCF method: norb_cas , nelec_cas = 6 , 8 mycas = mol . CASSCF ( norb_cas , nelec_cas )"
  },
  {
    "name": "TDDFT_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "TDDFT_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Like post-SCF methods, TDDFT can be instantiated based on a mean-field instance.\nWhen creating a TDDFT method from the Mole instance, the XC functional can be\nspecified as a keyword argument: mytd = mol . TDA ( xc = 'pbe' ) mytd = mol . TDDFT ( xc = 'pbe' ) Alternatively, the XC functional can be sp"
      }
    ],
    "parent_section": "gto",
    "description": "Like post-SCF methods, TDDFT can be instantiated based on a mean-field instance.\nWhen creating a TDDFT method from the Mole instance, the XC functional can be\nspecified as a keyword argument: mytd = mol . TDA ( xc = 'pbe' ) mytd = mol . TDDFT ( xc = 'pbe' ) Alternatively, the XC functional can be specified as part of the TDDFT function name: mytd = mol.TDB3LYP() # == mol.TDA(xc=’B3LYP’)\nmytd = mol.TDPBE() # == mol.TDA(xc=’PBE’) This API will create a TDA method with the specified XC functional."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "gto",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The GW approximation is a Green’s function-based method that calculates charged\nexcitation energies, i.e. ionizations potentials (IPs) and electron affinities\n(EAs).  PySCF implements the G 0 W 0 approximation, in which the\nself-energy is built with mean-field orbitals and orbital energies.  Therefo"
      }
    ],
    "parent_section": "gw",
    "description": "The GW approximation is a Green’s function-based method that calculates charged\nexcitation energies, i.e. ionizations potentials (IPs) and electron affinities\n(EAs).  PySCF implements the G 0 W 0 approximation, in which the\nself-energy is built with mean-field orbitals and orbital energies.  Therefore,\nthe results depend on the mean-field starting point, which can be Hartree-Fock\nor density functional theory.  As described below, PySCF has three\nimplementations of the GW approximation, all of which are “full-frequency”. An example GW calculation is shown below: #!/usr/bin/env python ''' A simple example to run a GW calculation ''' from pyscf import gto , dft , gw mol = gto . M ( atom = 'H 0 0 0; F 0 0 1.1' , basis = 'ccpvdz' ) mf = dft . RKS ( mol ) mf . xc = 'pbe' mf . kernel () nocc = mo"
  },
  {
    "name": "Frequency_integration",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Frequency_integration {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The frequency integration needed for the GW approximation can be done in three\nways, controlled by the freq_int keyword argument: by analytic continuation\n(AC, freq_int='ac' ), contour deformation (CD, freq_int='cd' ), or\nexactly (Exact, freq_int='exact' ).  The first two are much more affordable\nan"
      }
    ],
    "parent_section": "gw",
    "description": "The frequency integration needed for the GW approximation can be done in three\nways, controlled by the freq_int keyword argument: by analytic continuation\n(AC, freq_int='ac' ), contour deformation (CD, freq_int='cd' ), or\nexactly (Exact, freq_int='exact' ).  The first two are much more affordable\nand typically provide sufficient accuracy.  GW-AC supports spin-restricted and\nspin-unrestricted calculations; GW-CD and GW-Exact only support spin-restricted\ncalculations. Details of the GW-AC and GW-CD implementations in PySCF can be\nfound in Ref. [ 30 ] . Analytic continuation # Integration via analytic continuation is implemented in the GWAC module\nthat is accessed with freq_int='ac' , which is also\nthe default GW module.  GW-AC has \\(N^4\\) scaling and is recommended for\nvalence states only.\nT"
  },
  {
    "name": "Analytic_continuation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Analytic_continuation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Integration via analytic continuation is implemented in the GWAC module\nthat is accessed with freq_int='ac' , which is also\nthe default GW module.  GW-AC has \\(N^4\\) scaling and is recommended for\nvalence states only.\nThe analytic continuation can be done using a Pade\napproximation (default, more re"
      }
    ],
    "parent_section": "gw",
    "description": "Integration via analytic continuation is implemented in the GWAC module\nthat is accessed with freq_int='ac' , which is also\nthe default GW module.  GW-AC has \\(N^4\\) scaling and is recommended for\nvalence states only.\nThe analytic continuation can be done using a Pade\napproximation (default, more reliable) or a two-pole model, controlled by the ac attribute.\nGW-AC supports frozen core orbitals for reducing computational cost,\ncontrolled by the frozen attribute (number of frozen core MOs neglected in GW-AC\ncalculation). Frozen core orbitals are not supported by other GW methods currently.\nThere are two ways to compute GW orbital energies, controlled by the linearized attribute: linearized=False (default) solves the quasiparticle equation through a Newton solver\nself-consistently, while line"
  },
  {
    "name": "Contour_deformation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Contour_deformation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Integration via contour deformation is implemented in the GWCD module\nthat is accessed with freq_int='cd' .\nGW-CD has \\(N^4\\) scaling and is slower, but more robust, than GW-AC.\nGW-CD is particularly recommended for accurate core and high-energy states: mygw = gw . GW ( mf , freq_int = 'cd' ) . run "
      }
    ],
    "parent_section": "gw",
    "description": "Integration via contour deformation is implemented in the GWCD module\nthat is accessed with freq_int='cd' .\nGW-CD has \\(N^4\\) scaling and is slower, but more robust, than GW-AC.\nGW-CD is particularly recommended for accurate core and high-energy states: mygw = gw . GW ( mf , freq_int = 'cd' ) . run ( orbs = [ 0 , 1 ])"
  },
  {
    "name": "Exact",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Exact {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Exact frequency integration can be carried out analytically and is implemented\nin the GWExact module that is accessed with freq_int='exact' .  Exact integration\nrequires complete diagonalization of the RPA matrix, which has \\(N^6\\) scaling.  However, all orbital energies can be readily obtained with"
      }
    ],
    "parent_section": "gw",
    "description": "Exact frequency integration can be carried out analytically and is implemented\nin the GWExact module that is accessed with freq_int='exact' .  Exact integration\nrequires complete diagonalization of the RPA matrix, which has \\(N^6\\) scaling.  However, all orbital energies can be readily obtained without error: mygw = gw . GW ( mf , freq_int = 'exact' ) . run () By default, GW-Exact, like the other GW implementations, use the direct random-phase\napproximation (dRPA) to screen the Coulomb interaction.\nWithin GW-Exact, any alternative time-dependent mean-field theory (TDHF, TDDFT, etc.) can\nbe also used.  The instance of an executed tdscf method can be provided as a\nkeyword argument: #!/usr/bin/env python ''' GW calculation with exact frequency integration and TDDFT screening instead of dRPA '"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "gw",
    "description": "Show Source"
  },
  {
    "name": "Install_with_pip",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Install_with_pip {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "This is the recommended way to install PySCF for non-developers, pip install --prefer-binary pyscf The pip package provides a precompiled PySCF code (python wheel) that\nworks on almost all Linux systems, most macOS systems, and\nthe Windows Subsystem for Linux. If you already have installed\nPySCF via"
      }
    ],
    "parent_section": "install",
    "description": "This is the recommended way to install PySCF for non-developers, pip install --prefer-binary pyscf The pip package provides a precompiled PySCF code (python wheel) that\nworks on almost all Linux systems, most macOS systems, and\nthe Windows Subsystem for Linux. If you already have installed\nPySCF via pip, you can upgrade it to the new version, pip install --upgrade pyscf See also Newly introduced features are available in the pyscf-forge package, which can be\ninstalled with pip , pip install pyscf-forge Some other features are only maintained as Extensions to PySCF. To achieve better performance, additional install options are described in Advanced build options"
  },
  {
    "name": "Build_from_source_with_pip",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Build_from_source_with_pip {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If you’re interested in a new feature that’s not included in the latest release or you simply\nwant the latest and greatest PySCF, you can build from source using pip, pip install git+https://github.com/pyscf/pyscf To install the features developed on a particular branch, pip install git+https://gith"
      }
    ],
    "parent_section": "install",
    "description": "If you’re interested in a new feature that’s not included in the latest release or you simply\nwant the latest and greatest PySCF, you can build from source using pip, pip install git+https://github.com/pyscf/pyscf To install the features developed on a particular branch, pip install git+https://github.com/pyscf/pyscf@<branch_name> This install method compiles and links C extensions against the\nlibraries in your system. See Build from source for a full\nlist of prerequisites. If you would like to tune the CMake compilation\nparameters, you can set them with the environment variable CMAKE_CONFIGURE_ARGS ,\nfor example, export CMAKE_CONFIGURE_ARGS = \"-DBUILD_MARCH_NATIVE=ON -DBLA_VENDOR=Intel10_64lp_seq\" See CMake options for more details about CMake configuration."
  },
  {
    "name": "Build_from_source",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Build_from_source {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "You can manually install PySCF by building it from source.\nPrerequisites for manual installation are C compiler C++ compiler (optional, but required for XCFun and some extensions) CMake >= 3.10 Python >= 3.7 Numpy >= 1.13 Scipy >= 1.3 h5py >= 2.7 You can download the latest version of PySCF (or the "
      }
    ],
    "parent_section": "install",
    "description": "You can manually install PySCF by building it from source.\nPrerequisites for manual installation are C compiler C++ compiler (optional, but required for XCFun and some extensions) CMake >= 3.10 Python >= 3.7 Numpy >= 1.13 Scipy >= 1.3 h5py >= 2.7 You can download the latest version of PySCF (or the development\nbranch) from GitHub, git clone https://github.com/pyscf/pyscf.git cd pyscf Next, you need to build the C extensions in pyscf/lib cd pyscf/lib\nmkdir build cd build\ncmake ..\nmake This will automatically download the analytical GTO integral library libcint and the DFT exchange\ncorrelation functional libraries Libxc and XCFun . Finally, to allow Python to\nfind the pyscf package, add the top-level pyscf directory (not the pyscf/pyscf subdirectory) to PYTHONPATH .  For example, if pyscf is"
  },
  {
    "name": "Install_with_conda",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Install_with_conda {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If you use Conda (or Anaconda , PySCF can be installed from the\nconda-forge channel on Linux and MacOS conda install -c conda-forge pyscf To avoid potential conflict problems, it is recommended to create a dedicated\nenvironment that uses conda-forge conda create -n pyscf-env -c conda-forge python = "
      }
    ],
    "parent_section": "install",
    "description": "If you use Conda (or Anaconda , PySCF can be installed from the\nconda-forge channel on Linux and MacOS conda install -c conda-forge pyscf To avoid potential conflict problems, it is recommended to create a dedicated\nenvironment that uses conda-forge conda create -n pyscf-env -c conda-forge python = 3 .12 pyscf\nconda activate pyscf-env The conda-forge build of PySCF is available for various platforms, including\nApple Silicon and other ARM64 systems. These builds are linked against OpenBLAS,\nwhich may be less efficient than the MKL library on x86 hardware. If you are\nusing an x86 CPU and prefer MKL for BLAS functions, an alternative release is\navailable from the pyscf channel conda install -c pyscf pyscf"
  },
  {
    "name": "Install_on_Fedora",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Install_on_Fedora {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If you are running Fedora Linux, you can install PySCF as a\ndistribution package, dnf install python3-pyscf If you are running on an x86-64 platform, dnf should automatically\ninstall the optimized integral library, qcint, instead of the\ncross-platform libcint library."
      }
    ],
    "parent_section": "install",
    "description": "If you are running Fedora Linux, you can install PySCF as a\ndistribution package, dnf install python3-pyscf If you are running on an x86-64 platform, dnf should automatically\ninstall the optimized integral library, qcint, instead of the\ncross-platform libcint library."
  },
  {
    "name": "Docker_image",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Docker_image {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The following command starts a container with a jupyter notebook\nserver that listens for HTTP connections on port 8888, docker run - it - p 8888 : 8888 pyscf / pyscf : latest Now you can visit https://localhost:8888 with your browser to use\nPySCF in the notebook. Another way to use PySCF in a docker"
      }
    ],
    "parent_section": "install",
    "description": "The following command starts a container with a jupyter notebook\nserver that listens for HTTP connections on port 8888, docker run - it - p 8888 : 8888 pyscf / pyscf : latest Now you can visit https://localhost:8888 with your browser to use\nPySCF in the notebook. Another way to use PySCF in a docker container is to start an Ipython\nshell, docker run -it pyscf/pyscf:latest start.sh ipython"
  },
  {
    "name": "Advanced_build_options",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Advanced_build_options {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "CMake options # A full build of PySCF may take a long time to finish, and the CMake options\nlisted below can be used to speed up compilation or omit packages that fail to compile\n(e.g., XCFun may fail to build if a proper C++ compiler is not available). Warning If both -DENABLE_LIBXC=OFF and -DENABL"
      }
    ],
    "parent_section": "install",
    "description": "CMake options # A full build of PySCF may take a long time to finish, and the CMake options\nlisted below can be used to speed up compilation or omit packages that fail to compile\n(e.g., XCFun may fail to build if a proper C++ compiler is not available). Warning If both -DENABLE_LIBXC=OFF and -DENABLE_XCFUN=OFF are set, importing the\ndft module will lead to an ImportError . Flags Default Comments ENABLE_LIBXC ON Whether to use Libxc library in PySCF. If -DENABLE_LIBXC=OFF is appended to cmake command, Libxc will not be compiled. ENABLE_XCFUN ON Whether to use XCFun library in PySCF. If -DENABLE_XCFUN=OFF is appended to cmake command, XCFun will not be compiled. BUILD_LIBXC ON Set it to OFF to skip compiling Libxc . The dft module still calls Libxc library by default. The dft module will be "
  },
  {
    "name": "CMake_options",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "CMake_options {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A full build of PySCF may take a long time to finish, and the CMake options\nlisted below can be used to speed up compilation or omit packages that fail to compile\n(e.g., XCFun may fail to build if a proper C++ compiler is not available). Warning If both -DENABLE_LIBXC=OFF and -DENABLE_XCFUN=OFF are "
      }
    ],
    "parent_section": "install",
    "description": "A full build of PySCF may take a long time to finish, and the CMake options\nlisted below can be used to speed up compilation or omit packages that fail to compile\n(e.g., XCFun may fail to build if a proper C++ compiler is not available). Warning If both -DENABLE_LIBXC=OFF and -DENABLE_XCFUN=OFF are set, importing the\ndft module will lead to an ImportError . Flags Default Comments ENABLE_LIBXC ON Whether to use Libxc library in PySCF. If -DENABLE_LIBXC=OFF is appended to cmake command, Libxc will not be compiled. ENABLE_XCFUN ON Whether to use XCFun library in PySCF. If -DENABLE_XCFUN=OFF is appended to cmake command, XCFun will not be compiled. BUILD_LIBXC ON Set it to OFF to skip compiling Libxc . The dft module still calls Libxc library by default. The dft module will be linked against t"
  },
  {
    "name": "Environment_variables_and_global_configurations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Environment_variables_and_global_configurations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Env variable Comment PYSCF_MAX_MEMORY Maximum memory to use in MB PYSCF_TMPDIR Directory for temporary files PYSCF_CONFIG_FILE File where various PySCF default settings are stored PYSCF_EXT_PATH Path for finding external extensions PYSCF_MAX_MEMORY sets the default maximum memory in MB when creating"
      }
    ],
    "parent_section": "install",
    "description": "Env variable Comment PYSCF_MAX_MEMORY Maximum memory to use in MB PYSCF_TMPDIR Directory for temporary files PYSCF_CONFIG_FILE File where various PySCF default settings are stored PYSCF_EXT_PATH Path for finding external extensions PYSCF_MAX_MEMORY sets the default maximum memory in MB when creating Mole (or Cell ) object. It corresponds to the attribute max_memory``of Mole (or Cell ) object. The environment variable PYSCF_TMPDIR controls which directory is\nused to store intermediate files and temporary data when PySCF is run;\nit is also commonly known as the scratch directory. If this\nenvironment variable is not set, the system-wide temporary directory TMPDIR will be used as the temp directory, instead. It is highly\nrecommended to set this variable to a directory with enough disk\nspace, a"
  },
  {
    "name": "Install_without_internet",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Install_without_internet {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In typical installations, all external libraries (libcint, Libxc, XCFun) are\ndownloaded and installed when the C extensions are compiled, thus requiring\ninternet access. In this section, we show how to install the external libraries\nwithout internet access, assuming you have downloaded the libcint, "
      }
    ],
    "parent_section": "install",
    "description": "In typical installations, all external libraries (libcint, Libxc, XCFun) are\ndownloaded and installed when the C extensions are compiled, thus requiring\ninternet access. In this section, we show how to install the external libraries\nwithout internet access, assuming you have downloaded the libcint, Libxc, and\nXCFun libraries, git clone https://github.com/sunqm/libcint.git\ntar czf libcint.tar.gz libcint\nwget https://gitlab.com/libxc/libxc/-/archive/6.0.0/libxc-6.0.0.tar.gz\nwget -O xcfun.tar.gz https://github.com/fishjojo/xcfun/archive/refs/tags/cmake-3.5.tar.gz Assuming /opt is the place where these libraries will be installed, they\ncan be compiled, tar xvzf libcint.tar.gz cd libcint\nmkdir build && cd build\ncmake -DWITH_F12 = 1 -DWITH_RANGE_COULOMB = 1 -DWITH_COULOMB_ERF = 1 \\ -DCMAKE_INSTA"
  },
  {
    "name": "Using_optimized_BLAS",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_optimized_BLAS {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The default installation tries to find the BLAS libraries\nautomatically. This automated setup script may end up linking the code\nto slow versions of BLAS libraries, like the reference NETLIB\nimplementation. Using an optimized linear algebra library like ATLAS,\nBLIS, or OpenBLAS may speed up certain "
      }
    ],
    "parent_section": "install",
    "description": "The default installation tries to find the BLAS libraries\nautomatically. This automated setup script may end up linking the code\nto slow versions of BLAS libraries, like the reference NETLIB\nimplementation. Using an optimized linear algebra library like ATLAS,\nBLIS, or OpenBLAS may speed up certain parts of PySCF by factors of 10 to 1000. You can compile PySCF against BLAS libraries from other vendors to\nimprove performance. For example, the Intel Math Kernel Library (MKL)\ncan provide a 10x speedup in many modules, cd pyscf/lib/build\ncmake -DBLA_VENDOR = Intel10_64lp_seq ..\nmake When linking the program to MKL, CMake may have problems finding the\ncorrect MKL libraries for some versions of MKL.  Setting LD_LIBRARY_PATH to include the MKL dynamic libraries can sometimes\nhelp, for example, ex"
  },
  {
    "name": "Using_the_Qcint_optimized_integral_library",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_the_Qcint_optimized_integral_library {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The default integral library used by PySCF is libcint , which is implemented within a\nmodel that maximizes its compatibility with various high-performance\ncomputing systems. However, on x86-64 platforms, libcint has a more\nefficient counterpart, Qcint , which is\nheavily optimized with x86 SIMD instr"
      }
    ],
    "parent_section": "install",
    "description": "The default integral library used by PySCF is libcint , which is implemented within a\nmodel that maximizes its compatibility with various high-performance\ncomputing systems. However, on x86-64 platforms, libcint has a more\nefficient counterpart, Qcint , which is\nheavily optimized with x86 SIMD instructions (AVX-512/AVX2/AVX/SSE3).\nTo replace the default libcint library with the qcint library, edit the\nURL of the integral library in lib/CMakeLists.txt file, lib/CMakeLists.txt # ExternalProject_Add ( libcint GIT_REPOSITORY https://github.com/sunqm/qcint.git ..."
  },
  {
    "name": "Install_an_optimized_einsum_backend",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Install_an_optimized_einsum_backend {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Many modules in PySCF rely on numpy.einsum to perform tensor contractions.\nHowever, numpy.einsum is not efficient due to the lack of parallel execution. TBLIS provides an optimized\nimplementation for tensor contractions. It can deliver performance improvements\nof 10x to 100x than numpy.einsum . TBLI"
      }
    ],
    "parent_section": "install",
    "description": "Many modules in PySCF rely on numpy.einsum to perform tensor contractions.\nHowever, numpy.einsum is not efficient due to the lack of parallel execution. TBLIS provides an optimized\nimplementation for tensor contractions. It can deliver performance improvements\nof 10x to 100x than numpy.einsum . TBLIS can be used as a drop-in backend for einsum operations. The backend can be\ninstalled via the pytblis package: pip install pytblis Once pytblis is installed, PySCF will automatically detect and use it as the\nbackend for einsum operations."
  },
  {
    "name": "Troubleshooting",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Troubleshooting {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "error: command 'cmake' failed In some cases, installing PySCF with pip install pyscf may raise an error like the following: Building wheels for collected packages: pyscf Building wheel for pyscf ( setup.py ) ... error error: subprocess-exited-with-error × python setup.py bdist_wheel did not run succ"
      }
    ],
    "parent_section": "install",
    "description": "error: command 'cmake' failed In some cases, installing PySCF with pip install pyscf may raise an error like the following: Building wheels for collected packages: pyscf Building wheel for pyscf ( setup.py ) ... error error: subprocess-exited-with-error × python setup.py bdist_wheel did not run successfully. │ exit code: 1 ╰─> [ 7 lines of output ] scipy>1.1.0 may crash when calling scipy.linalg.eigh. ( Issues https://github.com/scipy/scipy/issues/15362 https://github.com/scipy/scipy/issues/16151 ) running bdist_wheel running build running build_ext Configuring extensions cmake -S/Users/<user>/personal/codes/chemistry/pyscf/pyscf/lib -Bbuild/temp.macosx-12-x86_64-cpython-310 error: command 'cmake' failed: No such file or directory [ end of output ] Here, pip chose not to install a binary w"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "install",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A molecular orbital is usually delocalized, i.e. it has non-negligible amplitude over the whole system rather than only around some atom(s) or bond(s).\nHowever, one can choose a unitary rotation \\(U\\) \\[\\phi = \\psi U\\] such that the resulting\norbitals \\(\\phi\\) are as spatially localized as possible."
      }
    ],
    "parent_section": "lo",
    "description": "A molecular orbital is usually delocalized, i.e. it has non-negligible amplitude over the whole system rather than only around some atom(s) or bond(s).\nHowever, one can choose a unitary rotation \\(U\\) \\[\\phi = \\psi U\\] such that the resulting\norbitals \\(\\phi\\) are as spatially localized as possible. This is typically achieved by one of two classes of\nmethods.\nThe first is to project the orbitals onto a predefined local set of orbitals, which can be e.g. atomic orbitals or pseudo-atomic orbitals.\nThe second is to optimize a cost function \\(f\\) , which measures the locality of the molecular orbitals.\nBecause there is no unambiguous choice for the localization criterion, several criteria have been suggested.\nBoys localization minimizes the spread of the orbital \\[f(U) = \\sum_{i} \\langle\\psi_i"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "lo",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Multiconfiguration pair-density functional theory (MC-PDFT) refers to methods in which the total electronic energy is obtained or derived from a functional of the on-top pair density as well as the total electron density, and these densities are in turn obtained from a multiconfigurational self-cons"
      }
    ],
    "parent_section": "mcpdft",
    "description": "Multiconfiguration pair-density functional theory (MC-PDFT) refers to methods in which the total electronic energy is obtained or derived from a functional of the on-top pair density as well as the total electron density, and these densities are in turn obtained from a multiconfigurational self-consistent field (MCSCF) wave function or wave functions of some sort.\nThe on-top pair density is the probability of two electrons existing simultaneously at one point in space.\nThe non-classical part of the MC-PDFT energy is called the “on-top energy” and is directly analogous to the exchange-correlation energy in standard density functional theory.\nIn practice, the on-top energy functional is always a generalization or a “translation” of an exchange-correlation functional from Kohn-Sham DFT.\nMC-PD"
  },
  {
    "name": "CASCI_PDFT",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "CASCI_PDFT {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "from pyscf import gto , mp , mcpdft mol = gto . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () # Use MP2 natural orbitals to define the active space for the single-point CAS-CI calculation mymp = mp . UMP2 ( myhf ) . run () noons , natorbs = mcscf . addo"
      }
    ],
    "parent_section": "mcpdft",
    "description": "from pyscf import gto , mp , mcpdft mol = gto . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () # Use MP2 natural orbitals to define the active space for the single-point CAS-CI calculation mymp = mp . UMP2 ( myhf ) . run () noons , natorbs = mcscf . addons . make_natural_orbitals ( mymp ) ncas , nelecas = ( 6 , 8 ) otfnal = 'tPBE' mycas = mcpdft . CASCI ( myhf , otfnal , ncas , nelecas ) mycas . kernel ( natorbs )"
  },
  {
    "name": "CASSCF_PDFT",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "CASSCF_PDFT {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "import pyscf from pyscf import mcpdft mol = pyscf . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () ncas , nelecas = ( 6 ,( 5 , 3 )) otfnal = 'tPBE' # For convenience, mycas.grids.level can be set at construction using an optional kwarg mycas = mcpdft . C"
      }
    ],
    "parent_section": "mcpdft",
    "description": "import pyscf from pyscf import mcpdft mol = pyscf . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () ncas , nelecas = ( 6 ,( 5 , 3 )) otfnal = 'tPBE' # For convenience, mycas.grids.level can be set at construction using an optional kwarg mycas = mcpdft . CASSCF ( myhf , otfnal , ncas , nelecas , grids_level = 6 ) . run () When state-averaged CASSCF wave functions are used, the MC-PDFT energy is computed separately for each state.\nWhen either state-averaged CASSCF or multiple roots with CASCI are calculated, the ordinal label of each state is as assigned by the underlying MCSCF calculation, regardless of the relative MC-PDFT energies.\nIn other words, state 2 may sometimes have a lower MC-PDFT energy than state 1."
  },
  {
    "name": "Available_on_top_functionals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Available_on_top_functionals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "“Translated” on-top functionals corresponding to any pure LDA or GGA exchange-correlation functional [ 47 ] , as well as meta-GGA functionals [ 48 ] which depend on the kinetic energy, are available.\nThese are specified by prepending the letter t to the name of the base DFT functional, as in tPBE or"
      }
    ],
    "parent_section": "mcpdft",
    "description": "“Translated” on-top functionals corresponding to any pure LDA or GGA exchange-correlation functional [ 47 ] , as well as meta-GGA functionals [ 48 ] which depend on the kinetic energy, are available.\nThese are specified by prepending the letter t to the name of the base DFT functional, as in tPBE or tBLYP .\n“Fully-translated” on-top functionals [ 49 ] corresponding to pure LDA or GGA functionals are also available and are specified by prepending the letters ft to the name of the base functional. With the exception of PBE0, for which the translated and fully-translated generalizations are implemented precisely as stipulated in Reference [ 50 ] , prepending t or ft to the names of hybrid DFT functionals in this way will not work, because there are multiple forms of hybrid on-top functional i"
  },
  {
    "name": "Multi_state_extension_methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Multi_state_extension_methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "MC-PDFT evaluates the total energy of a single electronic state through a nonlinear functional expression involving density variables.\nFor approximate functionals evaluated at approximate densities, it cannot be guaranteed that potential energy surfaces computed in this way for states of the same sy"
      }
    ],
    "parent_section": "mcpdft",
    "description": "MC-PDFT evaluates the total energy of a single electronic state through a nonlinear functional expression involving density variables.\nFor approximate functionals evaluated at approximate densities, it cannot be guaranteed that potential energy surfaces computed in this way for states of the same symmetry only cross along 3N-8 -dimensional conical intersection seams, which is a requirement for qualitatively accurate non-adiabatic molecular dynamics simulations.\nMulti-state methods are extensions of MC-PDFT which address this difficulty by defining the electronic energies of a set of states as eigenvalues of a small Hamiltonian matrix, of which the elements are related in one way or another to the MC-PDFT energy functional expression.\nIn PySCF, multi-state MC-PDFT methods are implemented as"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "mcpdft",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Multiconfigurational self-consistent field (MCSCF) methods go beyond the single-determinant Hartree-Fock (HF) method by allowing the wave function to become a linear combination of multiple determinants.\nWhile the configurations i.e. determinants can in principle be chosen in an arbitrary number of "
      }
    ],
    "parent_section": "mcscf",
    "description": "Multiconfigurational self-consistent field (MCSCF) methods go beyond the single-determinant Hartree-Fock (HF) method by allowing the wave function to become a linear combination of multiple determinants.\nWhile the configurations i.e. determinants can in principle be chosen in an arbitrary number of ways, PySCF focuses on the complete active space (CAS) family of methods, where the set of electron configurations is defined in terms of a given set of active orbitals, also known as the “active space”.\nThe CAS method generates all possible electron configurations that can be formed from the set of the active orbitals, and is therefore equivalent to an FCI procedure on a subset of the molecular orbitals; please see Configuration interaction (CISD and FCI) for a discussion on the FCI method.\nThe"
  },
  {
    "name": "CASCI",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "CASCI {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "from pyscf import gto , mp , mcscf mol = gto . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () # Use MP2 natural orbitals to define the active space for the single-point CAS-CI calculation mymp = mp . UMP2 ( myhf ) . run () noons , natorbs = mcscf . addon"
      }
    ],
    "parent_section": "mcscf",
    "description": "from pyscf import gto , mp , mcscf mol = gto . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () # Use MP2 natural orbitals to define the active space for the single-point CAS-CI calculation mymp = mp . UMP2 ( myhf ) . run () noons , natorbs = mcscf . addons . make_natural_orbitals ( mymp ) ncas , nelecas = ( 6 , 8 ) mycas = mcscf . CASCI ( myhf , ncas , nelecas ) mycas . kernel ( natorbs )"
  },
  {
    "name": "CASSCF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "CASSCF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "import pyscf mol = pyscf . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () ncas , nelecas = ( 6 ,( 5 , 3 )) # We can also run CAS calculations starting from the Hartree-Fock orbitals. mycas = myhf . CASSCF ( ncas , nelecas ) . run () Like many other modul"
      }
    ],
    "parent_section": "mcscf",
    "description": "import pyscf mol = pyscf . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () ncas , nelecas = ( 6 ,( 5 , 3 )) # We can also run CAS calculations starting from the Hartree-Fock orbitals. mycas = myhf . CASSCF ( ncas , nelecas ) . run () Like many other modules in PySCF, mcscf works with density-fitting ( Density fitting (DF) ) and x2c ( Scalar relativistic correction ).\nIt can also be used in its unrestricted formulation, please see examples/mcscf/60-uhf_based_ucasscf.py for an example.\nAn important feature of mcscf is that it can interface with external CI solver such as DMRG, FCIQMC, or selected CI methods, see the external projects for more details.\nYou can even use MP2 or CC methods as solvers!\nCheck out /examples/cc/42-as_casci_fcisolver.py fo"
  },
  {
    "name": "Picking_an_Active_Space",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Picking_an_Active_Space {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In general, selecting an active space can be cumbersome and PySCF offers severals ways to facilitate this process.\nThere are several strategies and they all contain two main components: Specify the number of electrons and orbitals in the active space. (Optional) Specify the which orbitals are “activ"
      }
    ],
    "parent_section": "mcscf",
    "description": "In general, selecting an active space can be cumbersome and PySCF offers severals ways to facilitate this process.\nThere are several strategies and they all contain two main components: Specify the number of electrons and orbitals in the active space. (Optional) Specify the which orbitals are “active” Note We always advise users to visualize their chosen active orbitals before starting large/expensive calculations.\nThis involves dumping the MO coefficients to a molden file (see example examples/tools/02-molden.py ) and visualizing with your chosen program.\nWhile there are many great softwares available to visualize orbitals, JMol is one of the easiest to use and is recommended for less experienced users. Below is a list of several general strategies one could employ to pick active space or"
  },
  {
    "name": "Frozen_orbital_MCSCF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Frozen_orbital_MCSCF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Orbitals can be frozen in the orbital optimization to e.g. reduce the computational effort of CASSCF calculations.\nThe orbitals will remain fixed throughout the optimization. Users can specify the number of lowest orbitals to freeze: mycas = mcscf . CASSCF ( myhf , 6 , 8 ) mycas . frozen = 2 mycas ."
      }
    ],
    "parent_section": "mcscf",
    "description": "Orbitals can be frozen in the orbital optimization to e.g. reduce the computational effort of CASSCF calculations.\nThe orbitals will remain fixed throughout the optimization. Users can specify the number of lowest orbitals to freeze: mycas = mcscf . CASSCF ( myhf , 6 , 8 ) mycas . frozen = 2 mycas . kernel () Users can also specify a list of orbital indices (0-based).\nThese may be occupied, virtual, or active orbitals. mycas = mcscf . CASSCF ( myhf , 6 , 8 ) mycas . frozen = [ 0 , 1 , 26 , 27 ] mycas . kernel () See examples/mcscf/19-frozen_orbital.py for a complete example. Note The frozen keyword of the CASSCF optimizer should not be confused with the frozen keyword of the FCI solver, which controls the number of orbitals that are constrained to be doubly occupied."
  },
  {
    "name": "Spin_state_of_CAS_wavefunction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_state_of_CAS_wavefunction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Multiconfigurational wavefunction provided by the\nthe pyscf.fci solver is typically spin-adapted, but there is no direct\ncontrol of the spin multiplicity (i.e. S^2 value). It is, nevertheless, possible\nto define the spin projection Sz of the obtained WF, which helps to fix the spin\nmultiplicity in m"
      }
    ],
    "parent_section": "mcscf",
    "description": "Multiconfigurational wavefunction provided by the\nthe pyscf.fci solver is typically spin-adapted, but there is no direct\ncontrol of the spin multiplicity (i.e. S^2 value). It is, nevertheless, possible\nto define the spin projection Sz of the obtained WF, which helps to fix the spin\nmultiplicity in most of the cases. By default, the MCSCF uses the setting in mol.spin for the value of 2*Sz. You can change the number of alpha and beta electrons in the active space.\nThe Sz value of the MCSCF wavefunction can differ from mol.spin . For example, you can start from Sz=0 RHF calculations, and then change the\nnumber of alpha and beta electrons in the active space to solve higher\nspin states, such as the triplet state.``` mol . spin = 0 myhf = mol . RHF () . run () # 5 alpha electrons, 3 beta electr"
  },
  {
    "name": "State_Averaged_Calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "State_Averaged_Calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "When your system has states that are close-by in energy, their ordering may change during the orbital optimization and result in non-convergence of the CASSCF optimization.\nIn such cases it is often helpful to optimize the orbitals for a state average.\nThe state_average_ function (note the hanging u"
      }
    ],
    "parent_section": "mcscf",
    "description": "When your system has states that are close-by in energy, their ordering may change during the orbital optimization and result in non-convergence of the CASSCF optimization.\nIn such cases it is often helpful to optimize the orbitals for a state average.\nThe state_average_ function (note the hanging underscore) is a member function of CASCI / CASSCF objects and takes the weights of the states as input.\nThe weights can be any normalized and non-negative array of values, but equal weights are typically used.\nSee Section 12.7.2 in Ref. [ 44 ] for more details. n_states = 5 weights = np . ones ( n_states ) / n_states mycas = mcscf . CASSCF ( mf , 4 , 4 ) . state_average_ ( weights ) See examples/mcscf/15-state_average.py for a complete example. By default, only a single spin and/or point group s"
  },
  {
    "name": "Job_Control",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Job_Control {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Optimization Settings # For CASSCF calculations, users may want to modify several of the convergence thresholds such as the energy ( conv_tol ), the orbital gradient ( conv_tol_grad ), and the maximum number of MCSCF iterations ( max_cycle_macro ). mycas = mcscf . CASSCF ( mf , 6 , 6 ) mycas . conv_"
      }
    ],
    "parent_section": "mcscf",
    "description": "Optimization Settings # For CASSCF calculations, users may want to modify several of the convergence thresholds such as the energy ( conv_tol ), the orbital gradient ( conv_tol_grad ), and the maximum number of MCSCF iterations ( max_cycle_macro ). mycas = mcscf . CASSCF ( mf , 6 , 6 ) mycas . conv_tol = 1e-12 mycas . conv_tol_grad = 1e-6 mycas . max_cycle_macro = 25 mycas . kernel () Initial Guess # Initial guess orbitals for the CASSCF calculation (starting orbitals) may be passed to the kernel member function of an MCSCF object. mycas = mcscf . CASSCF ( myhf , 8 , 8 ) mycas . kernel ( my_custom_mos ) CI coefficients from a previous calculation can also be passed as an initial guess to expedite the calculation: Examples: examples/mcscf/14-project_init_guess.py examples/mcscf/31-cr2_scan/"
  },
  {
    "name": "Optimization_Settings",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Optimization_Settings {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For CASSCF calculations, users may want to modify several of the convergence thresholds such as the energy ( conv_tol ), the orbital gradient ( conv_tol_grad ), and the maximum number of MCSCF iterations ( max_cycle_macro ). mycas = mcscf . CASSCF ( mf , 6 , 6 ) mycas . conv_tol = 1e-12 mycas . conv"
      }
    ],
    "parent_section": "mcscf",
    "description": "For CASSCF calculations, users may want to modify several of the convergence thresholds such as the energy ( conv_tol ), the orbital gradient ( conv_tol_grad ), and the maximum number of MCSCF iterations ( max_cycle_macro ). mycas = mcscf . CASSCF ( mf , 6 , 6 ) mycas . conv_tol = 1e-12 mycas . conv_tol_grad = 1e-6 mycas . max_cycle_macro = 25 mycas . kernel ()"
  },
  {
    "name": "Initial_Guess",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initial_Guess {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Initial guess orbitals for the CASSCF calculation (starting orbitals) may be passed to the kernel member function of an MCSCF object. mycas = mcscf . CASSCF ( myhf , 8 , 8 ) mycas . kernel ( my_custom_mos ) CI coefficients from a previous calculation can also be passed as an initial guess to expedit"
      }
    ],
    "parent_section": "mcscf",
    "description": "Initial guess orbitals for the CASSCF calculation (starting orbitals) may be passed to the kernel member function of an MCSCF object. mycas = mcscf . CASSCF ( myhf , 8 , 8 ) mycas . kernel ( my_custom_mos ) CI coefficients from a previous calculation can also be passed as an initial guess to expedite the calculation: Examples: examples/mcscf/14-project_init_guess.py examples/mcscf/31-cr2_scan/cr2-scan.py examples/mcscf/34-init_guess_localization.py examples/mcscf/43-avas.py examples/mcscf/43-dmet_cas.py"
  },
  {
    "name": "Restarting",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Restarting {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Warning When running large calculations, it’s always recommended that you specify a checkpoint file for your calculation. mycas . chkfile = \"casscf.chk\" Much like scf , if a job is interrupted, users can restart the MCSCF calculations using checkpoint files from a crashed calculation. from pyscf.lib"
      }
    ],
    "parent_section": "mcscf",
    "description": "Warning When running large calculations, it’s always recommended that you specify a checkpoint file for your calculation. mycas . chkfile = \"casscf.chk\" Much like scf , if a job is interrupted, users can restart the MCSCF calculations using checkpoint files from a crashed calculation. from pyscf.lib import chkfile old_chk_file = \"old_casscf.chk\" mycas = mcscf . CASSCF ( scf . RHF ( mol ), 6 , 6 ) mycas . chkfile = \"restarted_casscf.chk\" mo = chkfile . load ( old_chk_file , 'mcscf/mo_coeff' ) mycas . kernel ( mo ) See examples/mcscf/13-restart.py for a complete example. Restarting calculations can be also be useful when using results from a smaller active space to speed up calculations on a larger one."
  },
  {
    "name": "Observables_and_Properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Observables_and_Properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Wave Function Analysis # The analyze member functions of MCSCF objects prints many useful properties to stdout when the verbosity is >=4. Natural orbital occupancies Natural orbital AO expansions Overlap between canonical MCSCF orbitals and the initial guess orbitals. Analysis of the CI coefficients"
      }
    ],
    "parent_section": "mcscf",
    "description": "Wave Function Analysis # The analyze member functions of MCSCF objects prints many useful properties to stdout when the verbosity is >=4. Natural orbital occupancies Natural orbital AO expansions Overlap between canonical MCSCF orbitals and the initial guess orbitals. Analysis of the CI coefficients, i.e. the leading configurations and their weights AO populations Atomic populations AO spin densities (if applicable) Atomic spin densities (if applicable) mycas = myhf . CASCI ( 6 , 8 ) . run () mycas . verbose = 4 mycas . analyze () Natural Orbitals # The CAS wave function is invariant under orbital rotation within the inactive core, active, and inactive virtual spaces.\nThe inactive core and virtual orbitals are by default canonicalized, i.e., they are transformed by block-diagonalizing the "
  },
  {
    "name": "Wave_Function_Analysis",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Wave_Function_Analysis {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The analyze member functions of MCSCF objects prints many useful properties to stdout when the verbosity is >=4. Natural orbital occupancies Natural orbital AO expansions Overlap between canonical MCSCF orbitals and the initial guess orbitals. Analysis of the CI coefficients, i.e. the leading config"
      }
    ],
    "parent_section": "mcscf",
    "description": "The analyze member functions of MCSCF objects prints many useful properties to stdout when the verbosity is >=4. Natural orbital occupancies Natural orbital AO expansions Overlap between canonical MCSCF orbitals and the initial guess orbitals. Analysis of the CI coefficients, i.e. the leading configurations and their weights AO populations Atomic populations AO spin densities (if applicable) Atomic spin densities (if applicable) mycas = myhf . CASCI ( 6 , 8 ) . run () mycas . verbose = 4 mycas . analyze ()"
  },
  {
    "name": "Natural_Orbitals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Natural_Orbitals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The CAS wave function is invariant under orbital rotation within the inactive core, active, and inactive virtual spaces.\nThe inactive core and virtual orbitals are by default canonicalized, i.e., they are transformed by block-diagonalizing the generalized Fock matrix within the inactive core and vir"
      }
    ],
    "parent_section": "mcscf",
    "description": "The CAS wave function is invariant under orbital rotation within the inactive core, active, and inactive virtual spaces.\nThe inactive core and virtual orbitals are by default canonicalized, i.e., they are transformed by block-diagonalizing the generalized Fock matrix within the inactive core and virtual subblocks.\nThis also yields energy eigenvalues for the inactive core and virtual orbitals.\nIn contrast, no energy or electron occupation can be assigned to the active orbitals, strictly speaking.\nThe user may request the active orbitals to be transformed to the so-called natural representation, in which the reduced one-body density matrix is diagonal, and the formal natural orbital occupation numbers can be found on its diagonal. Warning When mycas.natorb is set, the natural orbitals may NO"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "mcscf",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Using any available method for computing gradients, molecular dynamics can be run to evolve the nuclei along their potential energy surfaces.\nThe MD module in PySCF supports both NVE and NVT ensemble integrations. A simple example of an NVE Born-Oppenheimer MD simulation with CASSCF is given in exam"
      }
    ],
    "parent_section": "md",
    "description": "Using any available method for computing gradients, molecular dynamics can be run to evolve the nuclei along their potential energy surfaces.\nThe MD module in PySCF supports both NVE and NVT ensemble integrations. A simple example of an NVE Born-Oppenheimer MD simulation with CASSCF is given in examples/md/00-simple_nve.py #!/usr/bin/env python ''' A simple example to run an NVE BOMD simulation. ''' import pyscf import pyscf.md mol = pyscf . M ( atom = 'O 0 0 0; O 0 0 1.2' , basis = 'ccpvdz' , spin = 2 ) myhf = mol . RHF () . run () # 6 orbitals, 8 electrons mycas = myhf . CASSCF ( 6 , 8 ) myscanner = mycas . nuc_grad_method () . as_scanner () # Generate the integrator # sets the time step to 5 a.u. and will run for 100 steps # or for 50 a.u. myintegrator = pyscf . md . NVE ( myscanner , d"
  },
  {
    "name": "Integrators",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Integrators {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The NVE ensemble uses the Velocity-Verlet integration scheme. The positions are evolved according to: \\[\\mathbf{r}(t_{i+1}) = \\mathbf{r}(t_i) + (\\delta t) \\mathbf{v}(t_i) + \\frac{1}{2}(\\delta t)^2 \\mathbf{a}(t_i)\\] and the velocities are evolved as \\[\\mathbf{v}(t_{i+1}) = \\mathbf{v}(t_i) + (\\delta t"
      }
    ],
    "parent_section": "md",
    "description": "The NVE ensemble uses the Velocity-Verlet integration scheme. The positions are evolved according to: \\[\\mathbf{r}(t_{i+1}) = \\mathbf{r}(t_i) + (\\delta t) \\mathbf{v}(t_i) + \\frac{1}{2}(\\delta t)^2 \\mathbf{a}(t_i)\\] and the velocities are evolved as \\[\\mathbf{v}(t_{i+1}) = \\mathbf{v}(t_i) + (\\delta t) \\frac{\\mathbf{a}(t_{i+1}) + \\mathbf{a}(t_i)}{2}\\] Note that to compute the acceleration, the most common isotope masses are used (rather than the average isotope mass). The NVT ensemble only has the Berendsen thermostat implemented. The Berendsen thermostat updates the velocities by weakly coupling the system to a heat bath at some temperature ( \\(T_0\\) ). The temperature is therefore corrected such that the deviation exponentially decays with some time constant \\(\\tau\\) . \\(\\tau\\) can also be"
  },
  {
    "name": "Initial_Velocity",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initial_Velocity {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The initial velocity for the system can be set through the veloc kwarg in the construction of the integrator such as integrator = pyscf . md . NVE ( hf , dt = 5 , steps = 10 , veloc = init_veloc ) This can be useful for restarting a dynamics simulation with a prior velocity, or starting a simulation"
      }
    ],
    "parent_section": "md",
    "description": "The initial velocity for the system can be set through the veloc kwarg in the construction of the integrator such as integrator = pyscf . md . NVE ( hf , dt = 5 , steps = 10 , veloc = init_veloc ) This can be useful for restarting a dynamics simulation with a prior velocity, or starting a simulation with a specific temperature. Additionally, the MD module also contains a function to sample the velocities from a Maxwell-Boltzmann distribution at a given temperature (in Kelvin). init_veloc = md . distributions . MaxwellBotlzmannVelocity ( mol , T = 300 ) The Maxwell-Botlzmann distribution at a specific temperature \\(T\\) for a particle of mass \\(m\\) is given as \\[f(v)dv = \\sqrt{\\frac{m}{2\\pi k T}}\\exp\\left(-\\frac{mv^2}{2kT}\\right)\\] Since all of the distributions use the same pseudo-random nu"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "md",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Second-order Møller–Plesset perturbation theory (MP2) [ 26 ] is a\npost-Hartree–Fock method. MP2 calculations can be performed in PySCF with or without\ndensity fitting, depending on the initial SCF calculation. Note also the existence of a native DF-MP2 implementation , which does\nnot depend on the i"
      }
    ],
    "parent_section": "mp",
    "description": "Second-order Møller–Plesset perturbation theory (MP2) [ 26 ] is a\npost-Hartree–Fock method. MP2 calculations can be performed in PySCF with or without\ndensity fitting, depending on the initial SCF calculation. Note also the existence of a native DF-MP2 implementation , which does\nnot depend on the integral approximation in SCF, and which is significantly faster than the\ndefault implementation of MP2 with density fitting. A simple example (see examples/mp/00-simple_mp2.py ) of running\nan MP2 calculation is #!/usr/bin/env python # # Author: Qiming Sun <osirpt.sun@gmail.com> # ''' A simple example to run MP2 calculation. ''' import pyscf mol = pyscf . M ( atom = 'H 0 0 0; F 0 0 1.1' , basis = 'ccpvdz' ) mf = mol . RHF () . run () mf . MP2 () . run () which outputs converged SCF energy = - 99."
  },
  {
    "name": "Spin_symmetry",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The MP2 module in PySCF supports a number of reference wavefunctions with\nbroken spin symmetry.  In particular, MP2 can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RMP2, UMP2, and GMP2 methods. The module-level mp.MP2(mf) con"
      }
    ],
    "parent_section": "mp",
    "description": "The MP2 module in PySCF supports a number of reference wavefunctions with\nbroken spin symmetry.  In particular, MP2 can be performed with a\nspin-restricted, spin-unrestricted, and general (spin-mixed) Hartree-Fock\nsolution, leading to the RMP2, UMP2, and GMP2 methods. The module-level mp.MP2(mf) constructor can infer the correct method based\non the level of symmetry-breaking in the mean-field argument.  For more explicit\ncontrol or inspection, the respective classes and functions can be found in mp2.py (restricted), ump2.py (unrestricted), and gmp2.py (general). For example, a spin-unrestricted calculation on triplet oxygen can be performed\nas follows: from pyscf import gto , scf , mp mol = gto . M ( atom = 'O 0 0 0; O 0 0 1.2' , # in Angstrom basis = 'ccpvdz' , spin = 2 ) mf = scf . HF ( "
  },
  {
    "name": "Properties",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Properties {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A number of properties are available at the MP2 level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = mymp . make_rdm1 () dm2 = mymp . make_rdm2 () Analytical nuclear gradients can be calculated [ 27 , 28 , 29 ] mygrad = mymp . nuc_gr"
      }
    ],
    "parent_section": "mp",
    "description": "A number of properties are available at the MP2 level. Unrelaxed 1- and 2-electron reduced density matrices can be calculated.\nThey are returned in the MO basis: dm1 = mymp . make_rdm1 () dm2 = mymp . make_rdm2 () Analytical nuclear gradients can be calculated [ 27 , 28 , 29 ] mygrad = mymp . nuc_grad_method () . run ()"
  },
  {
    "name": "Frozen_orbitals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Frozen_orbitals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "By default, MP2 calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals, use\nthe frozen keyword argument: mymp = mp . MP2 ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a\nlist of 0-based orbita"
      }
    ],
    "parent_section": "mp",
    "description": "By default, MP2 calculations in PySCF correlate all electrons in all available\norbitals. To freeze the lowest-energy core orbitals, use\nthe frozen keyword argument: mymp = mp . MP2 ( mf , frozen = 2 ) . run () To freeze occupied and/or unoccupied orbitals with finer control, a\nlist of 0-based orbital indices can be provided as the frozen keyword argument: # freeze 2 core orbitals mymp = mp . MP2 ( mf , frozen = [ 0 , 1 ]) . run () # freeze 2 core orbitals and 3 unoccupied orbitals mymp = mp . MP2 ( mf , frozen = [ 0 , 1 , 16 , 17 , 18 ]) . run () The number of core orbitals to be frozen can be generated automatically: mymp = mp . MP2 ( mf ) . set_frozen () . run () set_frozen() will freeze the core orbitals determined by sum of the core electrons of atoms, which are shown as follows.\nThe c"
  },
  {
    "name": "Job_control",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Job_control {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Avoid t2 storage # If the t2 amplitudes are not required after the MP2 calculation, they\ndon’t need to be saved in memory: mymp = mp . MP2 ( mf ) # by default, with_t2=True mymp . kernel ( with_t2 = False )"
      }
    ],
    "parent_section": "mp",
    "description": "Avoid t2 storage # If the t2 amplitudes are not required after the MP2 calculation, they\ndon’t need to be saved in memory: mymp = mp . MP2 ( mf ) # by default, with_t2=True mymp . kernel ( with_t2 = False )"
  },
  {
    "name": "Avoid_t2_storage",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Avoid_t2_storage {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If the t2 amplitudes are not required after the MP2 calculation, they\ndon’t need to be saved in memory: mymp = mp . MP2 ( mf ) # by default, with_t2=True mymp . kernel ( with_t2 = False )"
      }
    ],
    "parent_section": "mp",
    "description": "If the t2 amplitudes are not required after the MP2 calculation, they\ndon’t need to be saved in memory: mymp = mp . MP2 ( mf ) # by default, with_t2=True mymp . kernel ( with_t2 = False )"
  },
  {
    "name": "Density_fitted_MP2_DF_MP2",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Density_fitted_MP2_DF_MP2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Background # MP2 can be combined to great benefit with density fitting (DF), also known as the resolution of the identity\n(RI) approximation. While the formal scaling remains \\(O(N^5)\\) , the prefactor and the overall\ncomputational cost are reduced strongly, so that calculations can be performed on "
      }
    ],
    "parent_section": "mp",
    "description": "Background # MP2 can be combined to great benefit with density fitting (DF), also known as the resolution of the identity\n(RI) approximation. While the formal scaling remains \\(O(N^5)\\) , the prefactor and the overall\ncomputational cost are reduced strongly, so that calculations can be performed on much larger\nmolecules than with conventional MP2. Provided that a suitable auxiliary basis set is used,\nthe resulting DF/RI errors in reaction energies, geometries, properties etc. are negligible\ncompared to the intrinsic errors of MP2. This implementation can calculate energies, as well as unrelaxed and relaxed one-particle\ndensity matrices. Analytical gradients are not available yet. RHF and UHF references are supported\nthroughout. Please note that this part of the documentation does not descr"
  },
  {
    "name": "Background",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Background {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "MP2 can be combined to great benefit with density fitting (DF), also known as the resolution of the identity\n(RI) approximation. While the formal scaling remains \\(O(N^5)\\) , the prefactor and the overall\ncomputational cost are reduced strongly, so that calculations can be performed on much larger\nm"
      }
    ],
    "parent_section": "mp",
    "description": "MP2 can be combined to great benefit with density fitting (DF), also known as the resolution of the identity\n(RI) approximation. While the formal scaling remains \\(O(N^5)\\) , the prefactor and the overall\ncomputational cost are reduced strongly, so that calculations can be performed on much larger\nmolecules than with conventional MP2. Provided that a suitable auxiliary basis set is used,\nthe resulting DF/RI errors in reaction energies, geometries, properties etc. are negligible\ncompared to the intrinsic errors of MP2. This implementation can calculate energies, as well as unrelaxed and relaxed one-particle\ndensity matrices. Analytical gradients are not available yet. RHF and UHF references are supported\nthroughout. Please note that this part of the documentation does not describe the older"
  },
  {
    "name": "Using_the_DF_MP2_implementation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_the_DF_MP2_implementation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For technical reasons (incompatible algorithms), the “native” DF-MP2 implementation is not\nimplemented as a subclass of mp.mp2.MP2 , but it is written as an independent class instead.\nCurrently, the classes DFRMP2 (for RHF references) and DFUMP2 (for UHF references) need to\nbe imported from the resp"
      }
    ],
    "parent_section": "mp",
    "description": "For technical reasons (incompatible algorithms), the “native” DF-MP2 implementation is not\nimplemented as a subclass of mp.mp2.MP2 , but it is written as an independent class instead.\nCurrently, the classes DFRMP2 (for RHF references) and DFUMP2 (for UHF references) need to\nbe imported from the respective modules mp.dfmp2_native and mp.dfump2_native : from pyscf.mp.dfmp2_native import DFRMP2 from pyscf.mp.dfump2_native import DFUMP2 Both modules also make the respective classes available under the alias DFMP2 . The file examples/mp/10-dfmp2.py contains a simple example for a DF-MP2 energy calculation. There is also an older variant of DF-MP2 implemented in mp.dfmp2 , which does not exploit the\nadvantages of density fitting fully, and may therefore have much higher memory demands for larger"
  },
  {
    "name": "DF_MP2_densities",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "DF_MP2_densities {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Relaxed and unrelaxed 1-RDMs can be calculated for the RHF and UHF variants of the “native” DF-MP2\nimplementation. The points below provide some advice on choosing the correct type of MP2 density. The relaxed density should be used to calculate properties if the MP2 method is well-behaved for\nthe sy"
      }
    ],
    "parent_section": "mp",
    "description": "Relaxed and unrelaxed 1-RDMs can be calculated for the RHF and UHF variants of the “native” DF-MP2\nimplementation. The points below provide some advice on choosing the correct type of MP2 density. The relaxed density should be used to calculate properties if the MP2 method is well-behaved for\nthe system in question. Properties calculated thereby correspond to the correct derivative of the\nMP2 energy with respect to an appropriate external perturbation. This is illustrated in examples/mp/11-dfmp2-density.py , where the dipole moment of chloromethane is calculated\nmuch more accurately with the relaxed density than with the unrelaxed one. To calculate the\nrelaxed density, a set of CP-SCF type equations needs to be solved in one of the steps. In\nill-behaved systems, for example if there is mul"
  },
  {
    "name": "Spin_component_scaling",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_component_scaling {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Spin-component scaled (SCS-)MP2 calculations can be performed analogously to DF-MP2 calculations\nusing the classes SCSDFRMP2 and SCSDFUMP2 , which also have got aliases such as SCSMP2 inside the respective modules. The default scaling factors can be changed to arbitrary values: from pyscf.mp.dfmp2_n"
      }
    ],
    "parent_section": "mp",
    "description": "Spin-component scaled (SCS-)MP2 calculations can be performed analogously to DF-MP2 calculations\nusing the classes SCSDFRMP2 and SCSDFUMP2 , which also have got aliases such as SCSMP2 inside the respective modules. The default scaling factors can be changed to arbitrary values: from pyscf.mp.dfmp2_native import SCSMP2 pt = SCSMP2 ( mf , ps = 6 / 5 , pt = 1 / 3 ) pt . kernel ()"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "mp",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A second-order perturbative energy correction can be added on top of a multireference wave function.\nThe MRPT module in PySCF supports the second-order N-electron valence state perturbation theory (NEVPT2) [ 55 ] using the strongly contracted (SC) internal contraction scheme, [ 56 , 57 ] which is an"
      }
    ],
    "parent_section": "mrpt",
    "description": "A second-order perturbative energy correction can be added on top of a multireference wave function.\nThe MRPT module in PySCF supports the second-order N-electron valence state perturbation theory (NEVPT2) [ 55 ] using the strongly contracted (SC) internal contraction scheme, [ 56 , 57 ] which is an intruder-state-free MRPT.\nSC-NEVPT2 can be applied to CASCI/CASSCF wave functions produced by the FCI or DMRG solvers. [ 58 ] The number of the CI root needs to be specified for state-specific NEVPT2 calculations with mrpt.NEVPT(mc,root=Root_ID) .\nBy default, the NEVPT2 calculation is performed for the lowest root, Root_ID=0 . A simple example of SC-NEVPT2 calculations with the FCI and DMRG solvers is given in examples/mrpt/03-dmrg_nevpt2.py #!/usr/bin/env python # # Author: Sheng Guo <shengg@p"
  },
  {
    "name": "Compressed_Perturber_Functions",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Compressed_Perturber_Functions {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The bottleneck in SC-NEVPT2 is the evaluation of the energies of the perturber functions,\nwhere up to the 4-particle reduced density matrix (4-RDM) appears.\nIn DMRG-SC-NEVPT2, this evaluation is done with the compressed bond dimension (M’) which is smaller than\nthe bond dimension in the DMRG energy "
      }
    ],
    "parent_section": "mrpt",
    "description": "The bottleneck in SC-NEVPT2 is the evaluation of the energies of the perturber functions,\nwhere up to the 4-particle reduced density matrix (4-RDM) appears.\nIn DMRG-SC-NEVPT2, this evaluation is done with the compressed bond dimension (M’) which is smaller than\nthe bond dimension in the DMRG energy optimization to avoid the bottleneck.\nIt can be specified by mrpt.NEVPT(mc,root=Root_ID).compress_approx(maxM=M') . More information can be found in Reference [ 58 ]"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "mrpt",
    "description": "Show Source"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "pbc",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In addition to molecular calculations, density fitting (DF) is also useful in periodic calculations, as it reduces the computational cost of manipulating the electron repulsion integrals (ERIs). Currently, PySCF provides three periodic DF methods that differ in their employed auxiliary basis functio"
      }
    ],
    "parent_section": "df",
    "description": "In addition to molecular calculations, density fitting (DF) is also useful in periodic calculations, as it reduces the computational cost of manipulating the electron repulsion integrals (ERIs). Currently, PySCF provides three periodic DF methods that differ in their employed auxiliary basis functions. Gaussian density fitting ( GDF ) uses Gaussian-type orbitals (GTOs) as the auxiliary basis functions. [ 72 ] This parallels the molecular DF class. Fast Fourier transform density fitting ( FFTDF ) uses plane waves (PWs) as the auxiliary basis functions. FFTDF is also known as the Gaussian and plane wave (GPW) approach in the literature and other software packages. [ 73 , 74 ] Mixed density fitting ( MDF ) uses both PWs and GTOs as the auxiliary basis functions. [ 72 ] This section of the use"
  },
  {
    "name": "Using_DF_in_periodic_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Using_DF_in_periodic_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Unlike for molecular calculations, DF is used by default in periodic SCF calculations. For example, initializing a KRHF (i.e., RHF with \\(k\\) -point sampling) object uses FFTDF by default: import numpy as np from pyscf.pbc import gto , scf cell = gto . M ( atom = \"He 0 0 0\" , a = np . eye ( 3 ) * 2 "
      }
    ],
    "parent_section": "df",
    "description": "Unlike for molecular calculations, DF is used by default in periodic SCF calculations. For example, initializing a KRHF (i.e., RHF with \\(k\\) -point sampling) object uses FFTDF by default: import numpy as np from pyscf.pbc import gto , scf cell = gto . M ( atom = \"He 0 0 0\" , a = np . eye ( 3 ) * 2 , basis = \"6-31g\" ) kpts = cell . make_kpts ([ 2 , 2 , 2 ]) mf = scf . KRHF ( cell , kpts ) print ( mf . with_df ) # <pyscf.pbc.df.fft.FFTDF at 0x7feb78373c88> The periodic SCF classes also provide methods for using GDF : mf = scf . KRHF ( cell , kpts ) . density_fit () and MDF : mf = scf . KRHF ( cell , kpts ) . mix_density_fit () In addition to using the APIs above, the user can also initialize a DF object first and overwrite the with_df attribute of the SCF object. For example: from pyscf.pbc"
  },
  {
    "name": "Controlling_DF_error",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Controlling_DF_error {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The DF error is introduced by the incompleteness of the finite auxiliary basis used to expand the atomic orbital pair densities. The DF error can often be reduced by increasing the number of auxiliary basis functions being used. FFTDF # FFTDF uses plane waves (PWs) as the auxiliary basis, whose size"
      }
    ],
    "parent_section": "df",
    "description": "The DF error is introduced by the incompleteness of the finite auxiliary basis used to expand the atomic orbital pair densities. The DF error can often be reduced by increasing the number of auxiliary basis functions being used. FFTDF # FFTDF uses plane waves (PWs) as the auxiliary basis, whose size is determined by FFTDF.mesh , which is set to Cell.mesh upon initialization. Cell.mesh is a 1d array-like object of three integer numbers, [nx, ny, nz] , that defines the number of PWs (or the real-space grid points in the unit cell) in the \\(x\\) , \\(y\\) and \\(z\\) directions, respectively. The total number of PWs being used for FFTDF is therefore nx * ny * nz . PySCF determines Cell.mesh from Cell.ke_cutoff - the kinetic energy cutoff. By default, Cell.ke_cutoff is determined by Cell.precision "
  },
  {
    "name": "FFTDF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "FFTDF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "FFTDF uses plane waves (PWs) as the auxiliary basis, whose size is determined by FFTDF.mesh , which is set to Cell.mesh upon initialization. Cell.mesh is a 1d array-like object of three integer numbers, [nx, ny, nz] , that defines the number of PWs (or the real-space grid points in the unit cell) in"
      }
    ],
    "parent_section": "df",
    "description": "FFTDF uses plane waves (PWs) as the auxiliary basis, whose size is determined by FFTDF.mesh , which is set to Cell.mesh upon initialization. Cell.mesh is a 1d array-like object of three integer numbers, [nx, ny, nz] , that defines the number of PWs (or the real-space grid points in the unit cell) in the \\(x\\) , \\(y\\) and \\(z\\) directions, respectively. The total number of PWs being used for FFTDF is therefore nx * ny * nz . PySCF determines Cell.mesh from Cell.ke_cutoff - the kinetic energy cutoff. By default, Cell.ke_cutoff is determined by Cell.precision and the most compact atomic orbital in the basis set. To use a PW basis of a different size, the user can either overwrite FFTDF.mesh directly or change it by specifying Cell.ke_cutoff . An example is provided as follows: import numpy as"
  },
  {
    "name": "GDF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "GDF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "GDF uses Gaussian-type orbitals (GTOs) as the auxiliary basis and parallels the df module for molecular calculations. We guide the readers to Choice of auxiliary basis for more details on how to specify the auxiliary basis sets for GDF. A PBC example can be found in examples/pbc/35-gaussian_density_"
      }
    ],
    "parent_section": "df",
    "description": "GDF uses Gaussian-type orbitals (GTOs) as the auxiliary basis and parallels the df module for molecular calculations. We guide the readers to Choice of auxiliary basis for more details on how to specify the auxiliary basis sets for GDF. A PBC example can be found in examples/pbc/35-gaussian_density_fit.py ."
  },
  {
    "name": "MDF",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "MDF {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "MDF uses mixed GTOs and PWs as the fitting basis. The GTO part of the auxiliary basis can be set in the same way as for GDF (again, see Choice of auxiliary basis ), while the PW part is similar to FFTDF, i.e., setting either MDF.mesh or Cell.ke_cutoff . The default size of the PW basis is again rela"
      }
    ],
    "parent_section": "df",
    "description": "MDF uses mixed GTOs and PWs as the fitting basis. The GTO part of the auxiliary basis can be set in the same way as for GDF (again, see Choice of auxiliary basis ), while the PW part is similar to FFTDF, i.e., setting either MDF.mesh or Cell.ke_cutoff . The default size of the PW basis is again relatively conservative and the user is recommended to test convergence, as mentioned in FFTDF ."
  },
  {
    "name": "Saving_and_reusing_DF_tensors",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Saving_and_reusing_DF_tensors {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "While FFTDF is implemented in the so-called integral-direct manner and needs no “initialization”, both GDF and MDF pre-compute the Cholesky decomposed electron repulsion integrals (CDERIs) and save the 3-index tensor to disk for later use. The APIs for saving and reusing the CDERIs in GDF and MDF ar"
      }
    ],
    "parent_section": "df",
    "description": "While FFTDF is implemented in the so-called integral-direct manner and needs no “initialization”, both GDF and MDF pre-compute the Cholesky decomposed electron repulsion integrals (CDERIs) and save the 3-index tensor to disk for later use. The APIs for saving and reusing the CDERIs in GDF and MDF are the same as in the molecular df module; we guide the user to Saving and reusing DF tensors for a detailed description. A PBC example is provided in examples/pbc/35-gaussian_density_fit.py ."
  },
  {
    "name": "Choice_of_DF_method",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Choice_of_DF_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The choice of DF method depends on the type of calculation, the required accuracy, and the available computational resources. Type of calculation # All-electron versus pseudopotential : For all-electron calculations, only GDF and MDF can be used because FFTDF would require an impractically large PW "
      }
    ],
    "parent_section": "df",
    "description": "The choice of DF method depends on the type of calculation, the required accuracy, and the available computational resources. Type of calculation # All-electron versus pseudopotential : For all-electron calculations, only GDF and MDF can be used because FFTDF would require an impractically large PW basis to describe the core orbitals accurately (hydrogen and helium are two exceptions since they don’t have core orbitals). For pseudopotential -based calculations, all three DF methods can be used. Dimensionality : For calculations on low-dimensional systems (0D, 1D, and 2D), only GDF and MDF can be used. The user needs to specify the dimension by setting Cell.dimension . Treatment of exact exchange : For HF or DFT calculations using a hybrid functional, the exact exchange integral has a diver"
  },
  {
    "name": "Type_of_calculation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Type_of_calculation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "All-electron versus pseudopotential : For all-electron calculations, only GDF and MDF can be used because FFTDF would require an impractically large PW basis to describe the core orbitals accurately (hydrogen and helium are two exceptions since they don’t have core orbitals). For pseudopotential -ba"
      }
    ],
    "parent_section": "df",
    "description": "All-electron versus pseudopotential : For all-electron calculations, only GDF and MDF can be used because FFTDF would require an impractically large PW basis to describe the core orbitals accurately (hydrogen and helium are two exceptions since they don’t have core orbitals). For pseudopotential -based calculations, all three DF methods can be used. Dimensionality : For calculations on low-dimensional systems (0D, 1D, and 2D), only GDF and MDF can be used. The user needs to specify the dimension by setting Cell.dimension . Treatment of exact exchange : For HF or DFT calculations using a hybrid functional, the exact exchange integral has a divergence in reciprocal space that needs special treatment. [ 75 ] Different treatments can be used by setting the exxdiv attribute upon initializing a "
  },
  {
    "name": "Required_accuracy",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Required_accuracy {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "FFTDF can be considered “exact” for pseudopotential-based calculations within the given AO basis if a sufficiently large PW basis is used. GDF has a typical error of \\(10^{-5} \\sim 10^{-4} E_h\\) per atom in the converged SCF energy when tested on simple 3D solids of first- and second-row elements an"
      }
    ],
    "parent_section": "df",
    "description": "FFTDF can be considered “exact” for pseudopotential-based calculations within the given AO basis if a sufficiently large PW basis is used. GDF has a typical error of \\(10^{-5} \\sim 10^{-4} E_h\\) per atom in the converged SCF energy when tested on simple 3D solids of first- and second-row elements and using default auxiliary basis sets. [ 72 , 76 ] This error can be reduced by using a larger auxiliary basis set. [ 76 ] MDF is in general more accurate than GDF and comparable to FFTDF if a sufficiently large PW basis is used. The typical error of MDF is \\(10^{-6} E_h\\) per atom or lower in the SCF energy with the default parameters. [ 72 ]"
  },
  {
    "name": "Computational_resources",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Computational_resources {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "FFTDF uses very little disk space but requires \\(O(N_k n_{\\mathrm{AO}}^2 N_{\\mathrm{PW}})\\) memory , where \\(N_{\\mathrm{PW}}\\) is the size of the PW basis. Despite the modest, linear dependence on \\(N_k\\) , the memory requirement could be high for systems that require a relatively large PW basis. GD"
      }
    ],
    "parent_section": "df",
    "description": "FFTDF uses very little disk space but requires \\(O(N_k n_{\\mathrm{AO}}^2 N_{\\mathrm{PW}})\\) memory , where \\(N_{\\mathrm{PW}}\\) is the size of the PW basis. Despite the modest, linear dependence on \\(N_k\\) , the memory requirement could be high for systems that require a relatively large PW basis. GDF requires enough disk space to hold the pre-computed CDERIs. The size of these integrals grows quickly with the system size and scales as \\(O(N_k^2 n_{\\mathrm{AO}}^2 n_{\\mathrm{aux}})\\) , where \\(N_k\\) is the number of k-points, \\(n_{\\mathrm{AO}}\\) is the number of AOs per unit cell, and \\(n_{\\mathrm{aux}}\\) is the number of auxiliary basis functions per unit cell. Note that for DFT calculations using pure exchange-correlation functionals (LDA and GGA), the storage requirement is reduced to \\(O"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "df",
    "description": "Show Source"
  },
  {
    "name": "Overview_of_the_Available_Integral_Schemes",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Overview_of_the_Available_Integral_Schemes {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Coulomb Integral Schemes # FFTDF (aka the GPW algorithm): from pyscf.pbc.df import FFTDF kpts = cell . make_kpts ( kmesh ) mf = cell . KRKS ( xc = 'pbe0' , kpts = kpts ) mf . with_df = FFTDF ( cell , kpts = kpts ) # Unecessary, this is the default mf . run () This algorithm employs plane-wave (PW) f"
      }
    ],
    "parent_section": "dft-settings",
    "description": "Coulomb Integral Schemes # FFTDF (aka the GPW algorithm): from pyscf.pbc.df import FFTDF kpts = cell . make_kpts ( kmesh ) mf = cell . KRKS ( xc = 'pbe0' , kpts = kpts ) mf . with_df = FFTDF ( cell , kpts = kpts ) # Unecessary, this is the default mf . run () This algorithm employs plane-wave (PW) functions as auxiliary functions in the\ndensity fitting method. Coulomb integrals are computed using real-space\ndensity evaluation with fast-Fourier transform. In this approach, electron\ndensity is evaluated on real space grids and the Poisson equation is solved in\nreciprocal space to evaluate Coulomb integrals. The fast Fourier transforms\n(FFTs) are used to transform quantities between real space and reciprocal\nspace. With a sufficiently high energy cutoff in reciprocal space (approaching the\nco"
  },
  {
    "name": "Coulomb_Integral_Schemes",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Coulomb_Integral_Schemes {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "FFTDF (aka the GPW algorithm): from pyscf.pbc.df import FFTDF kpts = cell . make_kpts ( kmesh ) mf = cell . KRKS ( xc = 'pbe0' , kpts = kpts ) mf . with_df = FFTDF ( cell , kpts = kpts ) # Unecessary, this is the default mf . run () This algorithm employs plane-wave (PW) functions as auxiliary funct"
      }
    ],
    "parent_section": "dft-settings",
    "description": "FFTDF (aka the GPW algorithm): from pyscf.pbc.df import FFTDF kpts = cell . make_kpts ( kmesh ) mf = cell . KRKS ( xc = 'pbe0' , kpts = kpts ) mf . with_df = FFTDF ( cell , kpts = kpts ) # Unecessary, this is the default mf . run () This algorithm employs plane-wave (PW) functions as auxiliary functions in the\ndensity fitting method. Coulomb integrals are computed using real-space\ndensity evaluation with fast-Fourier transform. In this approach, electron\ndensity is evaluated on real space grids and the Poisson equation is solved in\nreciprocal space to evaluate Coulomb integrals. The fast Fourier transforms\n(FFTs) are used to transform quantities between real space and reciprocal\nspace. With a sufficiently high energy cutoff in reciprocal space (approaching the\ncomplete basis limit for plan"
  },
  {
    "name": "Numerical_Integration_Grids",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Numerical_Integration_Grids {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In periodic DFT calculations, XC integrals are evaluated numerically on a set of\nreal-space mesh grids. Two primary types of grids are commonly used: uniform\ngrids and atomic-centered grids. UniformGrids : from pyscf.pbc.dft import UniformGrids mf = cell . KRKS ( xc = 'pbe' , kpts = cell . make_kpts"
      }
    ],
    "parent_section": "dft-settings",
    "description": "In periodic DFT calculations, XC integrals are evaluated numerically on a set of\nreal-space mesh grids. Two primary types of grids are commonly used: uniform\ngrids and atomic-centered grids. UniformGrids : from pyscf.pbc.dft import UniformGrids mf = cell . KRKS ( xc = 'pbe' , kpts = cell . make_kpts ( kmesh )) mf . grids = UniformGrids ( cell ) mf . run () Uniform grids consist of an evenly spaced mesh that spans the unit cell. These\nmesh grids can be shared with the mesh used in the FFTDF-based Coulomb integral\ncomputation code. The XC and Coulomb computations can be combined to reduce the\noverall computational cost. Although a sufficient dense uniform mesh can accurately describe the core electron\ndensity, it require significantly more grids than atomic-centered grids. As a\nresult, unifo"
  },
  {
    "name": "Numerical_Integration_Schemes",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Numerical_Integration_Schemes {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Each type of DFT integration grid is associated with a corresponding\nXC integration algorithm. Two algorithms are implemented in PySCF: NumInt : from pyscf.pbc.dft import NumInt , KNumInt mf = cell . KRKS ( xc = 'pbe' , kpts = cell . make_kpts ( kmesh )) # mf.grids = KNumInt() # Unecessary, this is "
      }
    ],
    "parent_section": "dft-settings",
    "description": "Each type of DFT integration grid is associated with a corresponding\nXC integration algorithm. Two algorithms are implemented in PySCF: NumInt : from pyscf.pbc.dft import NumInt , KNumInt mf = cell . KRKS ( xc = 'pbe' , kpts = cell . make_kpts ( kmesh )) # mf.grids = KNumInt() # Unecessary, this is the default mf . run () The NumInt module follows the implementation used in molecular DFT. It\nsupports both UniformGrids and BeckeGrids. The computational cost of NumInt is\nroughly proportional to the number of grid points. The locality of orbitals\nand the sparsity of the XC matrix are not explored in the NumInt code. As a\nresult, the cost scales roughly cubicly with system size. Despite this, NumInt\nremains the default XC integration scheme as it supports most functionalities\n(such as the fxc "
  },
  {
    "name": "Scenarios_and_Suggested_Configurations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Scenarios_and_Suggested_Configurations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Summary of Scenarios and Integration Options # The following table summarizes common PBC DFT scenarios and the available\nintegral or XC integration algorithms for each case: Scenario Available Algorithms All-electron calculations GDF, RSDF, RSJK, NumInt-BeckeGrids Pseudopotentials FFTDF, MultiGrid, "
      }
    ],
    "parent_section": "dft-settings",
    "description": "Summary of Scenarios and Integration Options # The following table summarizes common PBC DFT scenarios and the available\nintegral or XC integration algorithms for each case: Scenario Available Algorithms All-electron calculations GDF, RSDF, RSJK, NumInt-BeckeGrids Pseudopotentials FFTDF, MultiGrid, NumInt Semi-local functionals (w/o HFX) FFTDF, GDF, RSDF, MultiGrid, NumInt-BeckeGrids Hybrid DFT GDF, RSDF, RSJK 2D systems with truncated Coulomb FFTDF, GDF, RSJK, MultiGrid, NumInt-BeckeGrids 1D systems with infinite vacuum AFTDF, GDF, RSJK, NumInt-BeckeGrids Typical Scenarios # Several key dimensions influence the choice of integral algorithms and numerical\nconfigurations in the PBC DFT calculations: Functional type: Semi-local (without HFX) vs. hybrid (with HFX) Core treatment: All-electron"
  },
  {
    "name": "Summary_of_Scenarios_and_Integration_Options",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Summary_of_Scenarios_and_Integration_Options {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The following table summarizes common PBC DFT scenarios and the available\nintegral or XC integration algorithms for each case: Scenario Available Algorithms All-electron calculations GDF, RSDF, RSJK, NumInt-BeckeGrids Pseudopotentials FFTDF, MultiGrid, NumInt Semi-local functionals (w/o HFX) FFTDF, "
      }
    ],
    "parent_section": "dft-settings",
    "description": "The following table summarizes common PBC DFT scenarios and the available\nintegral or XC integration algorithms for each case: Scenario Available Algorithms All-electron calculations GDF, RSDF, RSJK, NumInt-BeckeGrids Pseudopotentials FFTDF, MultiGrid, NumInt Semi-local functionals (w/o HFX) FFTDF, GDF, RSDF, MultiGrid, NumInt-BeckeGrids Hybrid DFT GDF, RSDF, RSJK 2D systems with truncated Coulomb FFTDF, GDF, RSJK, MultiGrid, NumInt-BeckeGrids 1D systems with infinite vacuum AFTDF, GDF, RSJK, NumInt-BeckeGrids"
  },
  {
    "name": "Typical_Scenarios",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Typical_Scenarios {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Several key dimensions influence the choice of integral algorithms and numerical\nconfigurations in the PBC DFT calculations: Functional type: Semi-local (without HFX) vs. hybrid (with HFX) Core treatment: All-electron vs. pseudopotential Periodicity: Fully 3D periodic vs. low-dimensional systems (1D"
      }
    ],
    "parent_section": "dft-settings",
    "description": "Several key dimensions influence the choice of integral algorithms and numerical\nconfigurations in the PBC DFT calculations: Functional type: Semi-local (without HFX) vs. hybrid (with HFX) Core treatment: All-electron vs. pseudopotential Periodicity: Fully 3D periodic vs. low-dimensional systems (1D/2D slab models) In the following, we analyze each combination of these dimensions, and provide\npractical guidance for setting up efficient integral schemes and configurations. Pseudopotential + Semi-local XC + 3D Periodicity # This is one of the most common scenarios in PBC DFT calculations. The\ndefault settings of the KRKS and KUKS classes can directly handle this type of\nsystem. However, the default NumInt calculator is not computationally\nefficient for large systems. For better performance, "
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "dft-settings",
    "description": "Show Source"
  },
  {
    "name": "Examples",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Examples {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "#!/usr/bin/env python ''' Gamma point post-HF calculation needs only real integrals. Methods implemented in finite-size system can be directly used here without any modification. ''' import numpy from pyscf.pbc import gto , scf cell = gto . M ( a = numpy . eye ( 3 ) * 3.5668 , atom = '''C     0.    "
      }
    ],
    "parent_section": "mix_mol",
    "description": "#!/usr/bin/env python ''' Gamma point post-HF calculation needs only real integrals. Methods implemented in finite-size system can be directly used here without any modification. ''' import numpy from pyscf.pbc import gto , scf cell = gto . M ( a = numpy . eye ( 3 ) * 3.5668 , atom = '''C     0.      0.      0. C     0.8917  0.8917  0.8917 C     1.7834  1.7834  0. C     2.6751  2.6751  0.8917 C     1.7834  0.      1.7834 C     2.6751  0.8917  2.6751 C     0.      1.7834  1.7834 C     0.8917  2.6751  2.6751''' , basis = '6-31g' , verbose = 4 , ) mf = scf . RHF ( cell ) . density_fit () mf . with_df . mesh = [ 10 ] * 3 mf . kernel () # # Import CC, TDDFT module from the molecular implementations # from pyscf import cc , tddft mycc = cc . CCSD ( mf ) mycc . kernel () mytd = tddft . TDHF ( mf "
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "mix_mol",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF supports periodic Hartree-Fock and density functional theory calculations\nwith Brillouin zone sampling.  The results of these calculations serve\nas input to a variety of periodic post-HF and post-DFT calculations.\nA minimal example of a periodic HF calculation on diamond with\na 2x2x2 sampling "
      }
    ],
    "parent_section": "scf",
    "description": "PySCF supports periodic Hartree-Fock and density functional theory calculations\nwith Brillouin zone sampling.  The results of these calculations serve\nas input to a variety of periodic post-HF and post-DFT calculations.\nA minimal example of a periodic HF calculation on diamond with\na 2x2x2 sampling of the Brillouin zone is shown below.  Note that the kpts keyword argument must be in physical units (inverse bohr),\nwhich can be easily achieved using the Cell.make_kpts() method: from pyscf.pbc import gto , scf cell = gto . M ( atom = '''C 0.0000 0.0000 0.0000 C 0.8917 0.8917 0.8917''' , a = '''0.0000 1.7834 1.7834 1.7834 0.0000 1.7834 1.7834 1.7834 0.0000''' , pseudo = 'gth-pade' , basis = 'gth-szv' ) kmf = scf . KRHF ( cell , kpts = cell . make_kpts ([ 2 , 2 , 2 ])) . run () # converged SCF "
  },
  {
    "name": "Density_fitting",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Density_fitting {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The default behavior is to use plane-wave density fitting (FFTDF).\nThe number of plane-waves used as an auxiliary basis is controlled by kinetic\nenergy cutoff, which is specified by the Cell.ke_cutoff parameter.  The\ndefault value of this parameter is chosen to provide many digits of precision in\nth"
      }
    ],
    "parent_section": "scf",
    "description": "The default behavior is to use plane-wave density fitting (FFTDF).\nThe number of plane-waves used as an auxiliary basis is controlled by kinetic\nenergy cutoff, which is specified by the Cell.ke_cutoff parameter.  The\ndefault value of this parameter is chosen to provide many digits of precision in\nthe ERIs and the subsequent energies.  If reduced precision is tolerable, this\nparameter can be set manually, resulting in significant speedups and memory\nsavings.  For the diamond example above, lowering the kinetic energy cutoff to 100\nhartree changes the SCF energy by about 5 microhartree: cell . ke_cutoff = 100.0 # in Hartree cell . build () kmf = scf . KRHF ( ... ) . run () # converged SCF energy = -10.9308602914696 For many systems, Gaussian density fitting (GDF) is more economical, although"
  },
  {
    "name": "Finite_size_effects",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Finite_size_effects {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The long-ranged nature of the Coulomb interaction is responsible for a number of\ndivergent contributions to the energy.  For charge-neutral unit cells, the\ndivergence of the nuclear repulsion energy, the electron-nuclear attraction\nenergy, and the electronic Hartree energy cancel one another. The no"
      }
    ],
    "parent_section": "scf",
    "description": "The long-ranged nature of the Coulomb interaction is responsible for a number of\ndivergent contributions to the energy.  For charge-neutral unit cells, the\ndivergence of the nuclear repulsion energy, the electron-nuclear attraction\nenergy, and the electronic Hartree energy cancel one another. The nonlocal exact exchange energy exhibits an integrable divergence at \\(G=0\\) that is responsible for the leading-order finite-size error of HF\nand hybrid DFT calculations [ 68 , 69 , 70 ] .  In\nPySCF, this exchange divergence can be addressed in a number of ways using the exxdiv keyword argument to the mean-field class, with the following\npossible values. 'ewald' (default) The \\(G=0\\) value of the Coulomb potential is the supercell Madelung\nconstant [ 68 , 69 , 70 ] , which is evaluated by\nEwald su"
  },
  {
    "name": "Band_structure_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Band_structure_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "After an SCF calculation has been performed, the band structure can be\ncalculated non-self-consistently along a k-point path using the SCF.get_bands(kpts) function, where kpts is a list of k-points along\nwhich the band structure is desired. Warning For Hartree-Fock or hybrid DFT, the discontinuity o"
      }
    ],
    "parent_section": "scf",
    "description": "After an SCF calculation has been performed, the band structure can be\ncalculated non-self-consistently along a k-point path using the SCF.get_bands(kpts) function, where kpts is a list of k-points along\nwhich the band structure is desired. Warning For Hartree-Fock or hybrid DFT, the discontinuity of the exchange potential\nat \\(G=0\\) is problematic for band structure calculations.  Using exxdiv='vcut_sph' with FFTDF is recommended instead.  Alternatively,\nthe SCF procedure can be repeated at each k-point, which is much more\nexpensive but allows the use of any exxdiv or density fitting. See examples/pbc/09-band_ase.py for an example DFT band structure\ncalculation."
  },
  {
    "name": "Add_ons",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Add_ons {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "All molecular SCF add-ons are also available for periodic SCF but\nmust be accessed through the molecular pyscf.scf.addons module.\nHere we highlight a few of the most useful add-ons. Linear dependencies # The dense packing of atoms in solids combined with the use of diffuse\natom-centered basis functi"
      }
    ],
    "parent_section": "scf",
    "description": "All molecular SCF add-ons are also available for periodic SCF but\nmust be accessed through the molecular pyscf.scf.addons module.\nHere we highlight a few of the most useful add-ons. Linear dependencies # The dense packing of atoms in solids combined with the use of diffuse\natom-centered basis functions is responsible for frequent linear dependencies.\nThe linear dependency can be eliminated by Cholesky orthogonalization: from pyscf import scf as mol_scf kmf = scf . KRHF ( cell , kpts = kpts ) kmf = mol_scf . addons . remove_linear_dep_ ( kmf ) . run () Smearing # For metals or small band gap semiconductors, it can be useful to smear the\norbital occupation numbers away from integer values.  This can improve SCF\nconvergence and can expedite convergence to the thermodynamic limit with k-point\n"
  },
  {
    "name": "Linear_dependencies",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Linear_dependencies {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The dense packing of atoms in solids combined with the use of diffuse\natom-centered basis functions is responsible for frequent linear dependencies.\nThe linear dependency can be eliminated by Cholesky orthogonalization: from pyscf import scf as mol_scf kmf = scf . KRHF ( cell , kpts = kpts ) kmf = m"
      }
    ],
    "parent_section": "scf",
    "description": "The dense packing of atoms in solids combined with the use of diffuse\natom-centered basis functions is responsible for frequent linear dependencies.\nThe linear dependency can be eliminated by Cholesky orthogonalization: from pyscf import scf as mol_scf kmf = scf . KRHF ( cell , kpts = kpts ) kmf = mol_scf . addons . remove_linear_dep_ ( kmf ) . run ()"
  },
  {
    "name": "Smearing",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Smearing {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For metals or small band gap semiconductors, it can be useful to smear the\norbital occupation numbers away from integer values.  This can improve SCF\nconvergence and can expedite convergence to the thermodynamic limit with k-point\nsampling.  Because this approach assumes a finite electronic temperat"
      }
    ],
    "parent_section": "scf",
    "description": "For metals or small band gap semiconductors, it can be useful to smear the\norbital occupation numbers away from integer values.  This can improve SCF\nconvergence and can expedite convergence to the thermodynamic limit with k-point\nsampling.  Because this approach assumes a finite electronic temperature, it\nyields an entropy and free energy: kmf = scf . KRHF ( cell , kpts = kpts ) kmf = scf . addons . smearing_ ( kmf , sigma = 0.01 , method = 'fermi' ) . run () print ( 'Entropy = %s ' % kmf . entropy ) print ( 'Free energy = %s ' % kmf . e_free ) print ( 'Zero temperature energy = %s ' % (( kmf . e_tot + kmf . e_free ) / 2 )) Fermi-Dirac smearing ( method='fermi' ) and Gaussian smearing\n( method='gauss' ) are supported. Warning Because most functions in PySCF assume integer occupations, the"
  },
  {
    "name": "Stability",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Stability {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Periodic SCF solutions can be checked with stability analysis: kmf = scf . KRHF ( cell ) . run () kmf . stability ()"
      }
    ],
    "parent_section": "scf",
    "description": "Periodic SCF solutions can be checked with stability analysis: kmf = scf . KRHF ( cell ) . run () kmf . stability ()"
  },
  {
    "name": "Multigrid",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Multigrid {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For pure DFT calculations, multi-grid algorithm becomes efficient if the size of\nunit cell is relatively large (e.g. more than 10 atoms) or the kinetic energy\ncutoff is relatively high (e.g. more than 100k plane waves). This algorithm is\nimplemented in the pyscf.pbc.dft.multigrid module: from pyscf."
      }
    ],
    "parent_section": "scf",
    "description": "For pure DFT calculations, multi-grid algorithm becomes efficient if the size of\nunit cell is relatively large (e.g. more than 10 atoms) or the kinetic energy\ncutoff is relatively high (e.g. more than 100k plane waves). This algorithm is\nimplemented in the pyscf.pbc.dft.multigrid module: from pyscf.pbc.dft import multigrid mf = multigrid . multigrid ( dft . KRKS ( cell )) mf . run () More examples can be found #!/usr/bin/env python ''' Use multi-grid to accelerate DFT numerical integration. ''' import numpy from pyscf.pbc import gto , dft from pyscf.pbc.dft import multigrid cell = gto . M ( verbose = 4 , a = numpy . eye ( 3 ) * 3.5668 , atom = '''C     0.      0.      0. C     0.8917  0.8917  0.8917 C     1.7834  1.7834  0. C     2.6751  2.6751  0.8917 C     1.7834  0.      1.7834 C     2."
  },
  {
    "name": "Range_separation_integration",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Range_separation_integration {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "This algorithm computes most of the four-center integrals in real space. For small\nsystems, it is less efficient than most density fitting algorithms. When you\nneed to handle a huge unit cell, or to compute exact exchange for many k points,\nor to use all-electron basis sets, you can consider to invo"
      }
    ],
    "parent_section": "scf",
    "description": "This algorithm computes most of the four-center integrals in real space. For small\nsystems, it is less efficient than most density fitting algorithms. When you\nneed to handle a huge unit cell, or to compute exact exchange for many k points,\nor to use all-electron basis sets, you can consider to invoke this algorithm.\nFor periodic SCF models, you can call the method jk_method : kmf = scf . KRHF ( cell , kpts ) . jk_method ( 'RS' ) kmf . kernel () This algorithm has much smaller memory footprint than density fitting algorithm.\nIt is also a good choice if your computer does not have enough memory to call\ndensity fitting methods. Note The implementation in current release does not support band structure calculations"
  },
  {
    "name": "How_to_choose_integral_scheme",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "How_to_choose_integral_scheme {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In the tables below, we provide a very rough estimation of the capability and\ncharacters for each integral algorithm in typical periodic mean-field\ncalculations. Number of basis functions for Gamma point calculations Scheme Pure DFT hybrid DFT FFTDF < 5000 < 300 GDF < 5000 < 5000 MDF < 5000 < 2000 M"
      }
    ],
    "parent_section": "scf",
    "description": "In the tables below, we provide a very rough estimation of the capability and\ncharacters for each integral algorithm in typical periodic mean-field\ncalculations. Number of basis functions for Gamma point calculations Scheme Pure DFT hybrid DFT FFTDF < 5000 < 300 GDF < 5000 < 5000 MDF < 5000 < 2000 Multi-grid 100 - 100000 N/A RS 100 - 10000 100 - 10000 Assuming 100 AOs per unit cell, the number of k-points Scheme Pure DFT hybrid DFT FFTDF < 2000 < 10 GDF < 2000 < 100 MDF < 2000 < 50 Multi-grid 5000 N/A RS 1000 1000 Relative performance for systems of 100 AOs per unit cell, 10 k-points Scheme Pure DFT hybrid DFT FFTDF 1x 1000x GDF 10x 100x MDF 30x 300x Multi-grid 1x N/A RS 100x 100x Other metrics Scheme All-electron Warm-up cost Accuracy Memory cost IO cost FFTDF Extremely slow Low High Extr"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "scf",
    "description": "Show Source"
  },
  {
    "name": "Building_a_crystal",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Building_a_crystal {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Periodic crystals are built using the pbc.gto.Cell class,\nwhich is very similar to the gto.Mole class, from pyscf.pbc import gto cell = gto . Cell () cell . atom = '''H 0 0 0; H 1 1 1''' cell . basis = 'gth-dzvp' cell . pseudo = 'gth-lda' cell . a = numpy . eye ( 3 ) * 2 cell . build () The other eq"
      }
    ],
    "parent_section": "pbcgto",
    "description": "Periodic crystals are built using the pbc.gto.Cell class,\nwhich is very similar to the gto.Mole class, from pyscf.pbc import gto cell = gto . Cell () cell . atom = '''H 0 0 0; H 1 1 1''' cell . basis = 'gth-dzvp' cell . pseudo = 'gth-lda' cell . a = numpy . eye ( 3 ) * 2 cell . build () The other equivalent ways to build a molecule introduced in Molecular\nstructure , including the shortcut functions pbc.gto.M() or pyscf.M() ,\nalso apply here, from pyscf.pbc import gto cell = gto . Cell () cell . build ( atom = '''H 0 0 0; H 1 1 1''' , basis = 'gth-dzvp' , pseudo = 'gth-lda' , a = numpy . eye ( 3 ) * 2 ) from pyscf.pbc import gto cell = gto . M ( atom = '''H 0 0 0; H 1 1 1''' , basis = 'gth-dzvp' , pseudo = 'gth-lda' , a = numpy . eye ( 3 ) * 2 ) import pyscf cell = pyscf . M ( atom = '''H "
  },
  {
    "name": "Geometry_and_lattice_vectors",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Geometry_and_lattice_vectors {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The Cell.atom attribute defines the positions of the atoms inside the unit cell, and\nthe additional parameter Cell.a defines the lattice vectors.\nThe format of Cell.a is array-like, cell . a = numpy . eye ( 3 ) * 2 cell . a = [[ 2 , 0 , 0 ],[ 0 , 2 , 0 ],[ 0 , 0 , 2 ]] Each row of the 3-by-3 matrix "
      }
    ],
    "parent_section": "pbcgto",
    "description": "The Cell.atom attribute defines the positions of the atoms inside the unit cell, and\nthe additional parameter Cell.a defines the lattice vectors.\nThe format of Cell.a is array-like, cell . a = numpy . eye ( 3 ) * 2 cell . a = [[ 2 , 0 , 0 ],[ 0 , 2 , 0 ],[ 0 , 0 , 2 ]] Each row of the 3-by-3 matrix of Cell.a represents a lattice vector\nin Cartesian coordinates, with the same unit as the input atom parameter\n(and controllable by the unit attribute). Warning The input lattice vectors should form a right-handed coordinate system, as\notherwise some integrals may be computed incorrectly in PySCF.\nPySCF will print a warning if the lattice vectors do not form a right-handed\ncoordinate system."
  },
  {
    "name": "Basis_set_and_pseudopotentials",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Basis_set_and_pseudopotentials {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF uses crystalline Gaussian-type orbitals as basis functions for periodic\ncalculations.  The predefined basis sets and ECPs for molecular calculations\ncan be used in periodic calculations as well. As described more in Density fitting for crystalline\ncalculations , many PBC calculations require t"
      }
    ],
    "parent_section": "pbcgto",
    "description": "PySCF uses crystalline Gaussian-type orbitals as basis functions for periodic\ncalculations.  The predefined basis sets and ECPs for molecular calculations\ncan be used in periodic calculations as well. As described more in Density fitting for crystalline\ncalculations , many PBC calculations require the use of ECPs (or\npseudopotentials, as they are more commonly called in periodic codes).  In\naddition to molecular ECPs, PySCF includes GTH pseudopotentials, which have\nbeen parameterized for use with HF or different DFT functionals, cell . pseudo = 'gth-hf' cell . pseudo = 'gth-lda' # an alias for 'gth-pade' cell . pseudo = 'gth-pbe' The GTH pseudopotentials should always be used with corresponding valence basis sets, cell . basis = 'gth-szv' # or gth-dzv, gth-dzvp, gth-tzvp Lists of all avail"
  },
  {
    "name": "K_points",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "K_points {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The k-points to be used in solid calculations can be obtained through the Cell.make_kpts method, by specifying the number of k-points\nin each lattice vector direction, kpts = cell . make_kpts ([ 1 , 2 , 2 ]) print ( kpts . shape ) # (4,3) By default, this will return the shifted Monkhorst-Pack mesh "
      }
    ],
    "parent_section": "pbcgto",
    "description": "The k-points to be used in solid calculations can be obtained through the Cell.make_kpts method, by specifying the number of k-points\nin each lattice vector direction, kpts = cell . make_kpts ([ 1 , 2 , 2 ]) print ( kpts . shape ) # (4,3) By default, this will return the shifted Monkhorst-Pack mesh that includes\nthe Gamma point. To get the non-shifted Monkhorst-Pack mesh, kpts = cell . make_kpts ([ 1 , 2 , 2 ], with_gamma_point = False ) To get a shifted Monkhorst-pack mesh centered at a specific point, kpts = cell . make_kpts ([ 1 , 2 , 2 ], scaled_center = [ 0. , 0.25 , 0.25 ]) where scaled_center is defined in the units of reciprocal lattice vectors. The obtained k-points are used as input for crystalline electronic structure calculations, from pyscf.pbc import scf kpts = cell . make_kp"
  },
  {
    "name": "Spin",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Because k-point sampling formally represents a calculation on a supercell,\nthe attribute Cell.spin indicates the number of unpaired electrons in the\nsupercell ( not in the unit cell). For example, in a calculation with\na 2x2x2 k-point mesh, cell.spin = 1 leads to one unpaired electron in the\nsuperce"
      }
    ],
    "parent_section": "pbcgto",
    "description": "Because k-point sampling formally represents a calculation on a supercell,\nthe attribute Cell.spin indicates the number of unpaired electrons in the\nsupercell ( not in the unit cell). For example, in a calculation with\na 2x2x2 k-point mesh, cell.spin = 1 leads to one unpaired electron in the\nsupercell (not eight)."
  },
  {
    "name": "Low_dimensional_systems",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Low_dimensional_systems {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The PySCF pbc module also supports low-dimensional periodic systems. You can initialize\nthe attribute Cell.dimension to specify the dimension of the system, cell . dimension = 2 cell . a = numpy . eye ( 3 ) * 2 cell . build () When Cell.dimension is smaller than 3, a vacuum of infinite size will be\n"
      }
    ],
    "parent_section": "pbcgto",
    "description": "The PySCF pbc module also supports low-dimensional periodic systems. You can initialize\nthe attribute Cell.dimension to specify the dimension of the system, cell . dimension = 2 cell . a = numpy . eye ( 3 ) * 2 cell . build () When Cell.dimension is smaller than 3, a vacuum of infinite size will be\napplied in certain direction(s).  For example, when Cell.dimension = 2 ,\nthe z-direction will be treated as infinitely large and the xy-plane\nconstitutes the periodic surface. When Cell.dimension = 1 , the y and z axes\nare treated as vacuum and thus the system is a wire in the x direction.\nWhen Cell.dimension = 0 , all three directions are treated as vacuum, and this is\nequivalent to a molecular system."
  },
  {
    "name": "Other_parameters",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Other_parameters {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The Cell.precision attribute determines the integral accuracy, and its\ndefault value is 1e-8 hartree. When calling the cell.build() method,\nsome parameters are set automatically based on the value of precision , including mesh - length-3 list or 1x3 array of int The numbers of grid points in the FFT"
      }
    ],
    "parent_section": "pbcgto",
    "description": "The Cell.precision attribute determines the integral accuracy, and its\ndefault value is 1e-8 hartree. When calling the cell.build() method,\nsome parameters are set automatically based on the value of precision , including mesh - length-3 list or 1x3 array of int The numbers of grid points in the FFT-mesh in each direction. ke_cutoff - float Kinetic energy cutoff of the plane waves in FFTDF rcut - float Cutoff radius (in Bohr) of the lattice summation in the integral evaluation Other attributes of the Mole class such as verbose , max_memory , etc., have the same meanings in the Cell class. Note Currently, point group symmetries for crystals are not supported."
  },
  {
    "name": "Accessing_AO_integrals",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Accessing_AO_integrals {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Periodic AO integrals can be evaluated using the Cell.pbc_intor function, overlap = cell . pbc_intor ( 'int1e_ovlp' ) kin = cell . pbc_intor ( 'int1e_kin' ) By default, the Cell.pbc_intor function only returns integrals at the\nGamma point.  If k-points are specified, it will return the integrals at "
      }
    ],
    "parent_section": "pbcgto",
    "description": "Periodic AO integrals can be evaluated using the Cell.pbc_intor function, overlap = cell . pbc_intor ( 'int1e_ovlp' ) kin = cell . pbc_intor ( 'int1e_kin' ) By default, the Cell.pbc_intor function only returns integrals at the\nGamma point.  If k-points are specified, it will return the integrals at each\nk-point, kpts = cell . make_kpts ([ 2 , 2 , 2 ]) overlap = cell . pbc_intor ( 'int1e_ovlp' , kpts = kpts ) Note The Cell.pbc_intor function can only be used to evaluate periodic short-range\nintegrals. PBC density fitting methods have to be used to compute the integrals for\nlong-range operators such as the electron-nuclear attraction and the electron-electron\nrepulsion integrals. The electron repulsion integrals can be evaluated with the periodic density fitting\nmethods, from pyscf.pbc impor"
  },
  {
    "name": "Initializing_Mean_Field_and_Post_SCF_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initializing_Mean_Field_and_Post_SCF_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Mean-field and post-SCF methods can be initialized directly from the Cell instance. Instantiating Mean-Field Methods # For single k-point mean-field methods, you can pass the k-point to the cell.HF or cell.KS methods. kpt = np . array ([ 0. , 0. , 0. ]) mf = cell . HF ( kpt = kpt ) mf = cell . KS ( "
      }
    ],
    "parent_section": "pbcgto",
    "description": "Mean-field and post-SCF methods can be initialized directly from the Cell instance. Instantiating Mean-Field Methods # For single k-point mean-field methods, you can pass the k-point to the cell.HF or cell.KS methods. kpt = np . array ([ 0. , 0. , 0. ]) mf = cell . HF ( kpt = kpt ) mf = cell . KS ( kpt = kpt ) To create mean-field methods with a k-point mesh, the HF and KS methods are\nprefixed with “K”. The k-points should be created and passed to these K-prefixed\nmean-field methods. kpts = cell . make_kpts ([ 3 , 3 , 3 ]) mf = cell . KHF ( kpts = kpts ) mf = cell . KKS ( kpts = kpts ) Based on the cell.spin setting, different mean-field instances are created. By default: Restricted closed-shell methods are used for molecules without unpaired electrons ( cell.spin=0 ). Unrestricted methods"
  },
  {
    "name": "Instantiating_Mean_Field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Instantiating_Mean_Field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For single k-point mean-field methods, you can pass the k-point to the cell.HF or cell.KS methods. kpt = np . array ([ 0. , 0. , 0. ]) mf = cell . HF ( kpt = kpt ) mf = cell . KS ( kpt = kpt ) To create mean-field methods with a k-point mesh, the HF and KS methods are\nprefixed with “K”. The k-points"
      }
    ],
    "parent_section": "pbcgto",
    "description": "For single k-point mean-field methods, you can pass the k-point to the cell.HF or cell.KS methods. kpt = np . array ([ 0. , 0. , 0. ]) mf = cell . HF ( kpt = kpt ) mf = cell . KS ( kpt = kpt ) To create mean-field methods with a k-point mesh, the HF and KS methods are\nprefixed with “K”. The k-points should be created and passed to these K-prefixed\nmean-field methods. kpts = cell . make_kpts ([ 3 , 3 , 3 ]) mf = cell . KHF ( kpts = kpts ) mf = cell . KKS ( kpts = kpts ) Based on the cell.spin setting, different mean-field instances are created. By default: Restricted closed-shell methods are used for molecules without unpaired electrons ( cell.spin=0 ). Unrestricted methods (UHF, UKS) are used for molecules with unpaired electrons ( cell.spin > 0 ). The use of k-point symmetry in KHF  and K"
  },
  {
    "name": "Explicit_Mean_field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Explicit_Mean_field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To create specific mean-field instances, such as unrestricted or generalized HF\nor KS methods, they can be explicitly called from the Cell instance. The\nfollowing rules apply: cell.RHF() and cell.RKS() create single k-point restricted Hartree-Fock or\nKohn-Sham methods. When cell.spin != 0 , ROHF and"
      }
    ],
    "parent_section": "pbcgto",
    "description": "To create specific mean-field instances, such as unrestricted or generalized HF\nor KS methods, they can be explicitly called from the Cell instance. The\nfollowing rules apply: cell.RHF() and cell.RKS() create single k-point restricted Hartree-Fock or\nKohn-Sham methods. When cell.spin != 0 , ROHF and ROKS methods are\ninstantiated. However, for k-point mean-field methods, cell.KRHF() and cell.KRKS() always create restricted closed-shell models, regardless of the cell.spin setting. This is different from the treatment in single k-point methods. cell.ROHF() , cell.ROKS() , cell.KROHF() , and cell.KROKS() create\nrestricted open-shell HF or KS methods. cell.UHF() , cell.UKS() , cell.KUHF() , and cell.KUKS() create\nunrestricted Hartree-Fock or Kohn-Sham methods, regardless of the cell.spin settin"
  },
  {
    "name": "Keyword_Parameters_for_Mean_field_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Keyword_Parameters_for_Mean_field_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Configuration parameters for mean-field methods can be specified through keyword\narguments of the instantiation methods. For example, mf = cell . RKS ( xc = 'b3lyp' , max_cycle = 20 ) mf = cell . KGKS ( xc = 'pbe' , kpts = cell . make_kpts ([ 2 , 2 , 2 ]))"
      }
    ],
    "parent_section": "pbcgto",
    "description": "Configuration parameters for mean-field methods can be specified through keyword\narguments of the instantiation methods. For example, mf = cell . RKS ( xc = 'b3lyp' , max_cycle = 20 ) mf = cell . KGKS ( xc = 'pbe' , kpts = cell . make_kpts ([ 2 , 2 , 2 ]))"
  },
  {
    "name": "Instantiating_Post_SCF_Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Instantiating_Post_SCF_Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Post-SCF methods at the gamma point can be specified for the Cell instance.\nKeyword arguments can be supplied, and they will be passed to the post-SCF\nmethods. mycc = cell . CCSD ( frozen = 1 ) mytd = cell . TDA () For post-SCF methods with k-point sampling, the method should be prefixed with “K”.\nA"
      }
    ],
    "parent_section": "pbcgto",
    "description": "Post-SCF methods at the gamma point can be specified for the Cell instance.\nKeyword arguments can be supplied, and they will be passed to the post-SCF\nmethods. mycc = cell . CCSD ( frozen = 1 ) mytd = cell . TDA () For post-SCF methods with k-point sampling, the method should be prefixed with “K”.\nAdditionally, k-points can be supplied as keyword arguments, and they will be\nautomatically applied when creating the underlying mean-field object. mycc = cell . KCCSD ( kpts = cell . make_kpts ([ 2 , 2 , 2 ]), frozen = 1 )"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "pbcgto",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "particle-particle Random Phase Approximation (ppRPA):cite: vanaggelenExchangecorrelationEnergyPairing2013 ,\nwhich was originally used to describe the nuclear many-body correlation,\nhas been developed to predict ground-state and excited-state properties of molecular and bulk systems.\nThe ppRPA correl"
      }
    ],
    "parent_section": "pprpa",
    "description": "particle-particle Random Phase Approximation (ppRPA):cite: vanaggelenExchangecorrelationEnergyPairing2013 ,\nwhich was originally used to describe the nuclear many-body correlation,\nhas been developed to predict ground-state and excited-state properties of molecular and bulk systems.\nThe ppRPA correlation energy is exact up to the second order electron-electron interaction and is equivalent to ladder coupled cluster doubles.\nFor calculations of excitation energies in ppRPA,\nthe excitation energies of the N-electron system can be calculated as the differences between the two-electron addition\nenergies of the (N-2)-electron system from the particle-particle channel.\nSimilarly,\nthe excitation energies can also be obtained from the differences between the two-electron removal energies of the (N"
  },
  {
    "name": "Correlation_Energy",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Correlation_Energy {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The evaluation of the ppRPA requires the full diagonalization of the ppRPA matrix,\nwhich scales as \\(N^6\\) ."
      }
    ],
    "parent_section": "pprpa",
    "description": "The evaluation of the ppRPA requires the full diagonalization of the ppRPA matrix,\nwhich scales as \\(N^6\\) ."
  },
  {
    "name": "Excitation_Energy",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Excitation_Energy {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The formal scaling of ppRPA for computing excitation energies is \\(N^4\\) with the Davidson algorithm:cite: yangExcitationEnergiesParticleparticle2014 .\nThe computational cost can be further significantly reduced by using active-space approach:cite: liLinearScalingCalculations2023 ,\nwhich directly tr"
      }
    ],
    "parent_section": "pprpa",
    "description": "The formal scaling of ppRPA for computing excitation energies is \\(N^4\\) with the Davidson algorithm:cite: yangExcitationEnergiesParticleparticle2014 .\nThe computational cost can be further significantly reduced by using active-space approach:cite: liLinearScalingCalculations2023 ,\nwhich directly truncates ppRPA matrix in the molecular orbital space without loss of accuracy. In the current implementation,\nthe active-space approach can be used in both restricted and unrestricted calculation,\nthe Davidson algorithm is only support in the restricted calculation. particle-particle channel # To get two-electron addition energies in the particle-particle channel,\nset charge=2 in the mol or cell object to create an (N-2)-electron system. hole-hole channel # To get two-electron removal energies in"
  },
  {
    "name": "particle_particle_channel",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "particle_particle_channel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To get two-electron addition energies in the particle-particle channel,\nset charge=2 in the mol or cell object to create an (N-2)-electron system."
      }
    ],
    "parent_section": "pprpa",
    "description": "To get two-electron addition energies in the particle-particle channel,\nset charge=2 in the mol or cell object to create an (N-2)-electron system."
  },
  {
    "name": "hole_hole_channel",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "hole_hole_channel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To get two-electron removal energies in the particle-particle channel,\nset charge=-2 in the mol or cell object to create an (N+2)-electron system."
      }
    ],
    "parent_section": "pprpa",
    "description": "To get two-electron removal energies in the particle-particle channel,\nset charge=-2 in the mol or cell object to create an (N+2)-electron system."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "pprpa",
    "description": "Show Source"
  },
  {
    "name": "How_to_install_PySCF_forge",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "How_to_install_PySCF_forge {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF-forge is distributed as a separate GitHub repository .\nLike PySCF, it can be installed via pip, pip install pyscf - forge # or pip install git + https : // github . com / pyscf / pyscf - forge or cloned and built from source.  As long as PySCF-forge can be found in your PYTHONPATH , its module"
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "PySCF-forge is distributed as a separate GitHub repository .\nLike PySCF, it can be installed via pip, pip install pyscf - forge # or pip install git + https : // github . com / pyscf / pyscf - forge or cloned and built from source.  As long as PySCF-forge can be found in your PYTHONPATH , its modules can be imported as if they were native to PySCF.\nAlternatively, you can define the PYSCF_EXT_PATH environment variable to\npoint to your local pyscf-forge directory, export PYSCF_EXT_PATH =/ path / to / pyscf - forge PySCF will read the PYSCF_EXT_PATH environment variable and load modules from\nthis path at runtime. For more details of the PYSCF_EXT_PATH environment\nvariable, see the Extensions section.  For\nexample, from pyscf import gto , mcpdft # mcpdft is in pyscf-forge mol = gto . M ( atom "
  },
  {
    "name": "How_to_develop_in_PySCF_forge",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "How_to_develop_in_PySCF_forge {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If you are developing new features or modifying the code in PySCF-forge, an\neditable installation is recommended.  By configuring the package in editable\nmode, you can modify existing modules and add new features to PySCF-forge.\nAfter cloning the library to your local repository, there are two ways "
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "If you are developing new features or modifying the code in PySCF-forge, an\neditable installation is recommended.  By configuring the package in editable\nmode, you can modify existing modules and add new features to PySCF-forge.\nAfter cloning the library to your local repository, there are two ways to\nenable the editable installation. Method 1. Using pip for editable installation # Install the package with the following pip command, pip install -- no - deps - e / path / to / pyscf - forge This command creates a .pth file in ~/.local/lib/python3.*/site-packages/ or other Python runtime paths. It is recommended to use this method with Python\nvirtual environments. Method 2. Setting an environment variable # As described above, you can also define the PYSCF_EXT_PATH environment\nvariable to poi"
  },
  {
    "name": "Method_1_Using_pip_for_editable_installation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Method_1_Using_pip_for_editable_installation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Install the package with the following pip command, pip install -- no - deps - e / path / to / pyscf - forge This command creates a .pth file in ~/.local/lib/python3.*/site-packages/ or other Python runtime paths. It is recommended to use this method with Python\nvirtual environments."
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "Install the package with the following pip command, pip install -- no - deps - e / path / to / pyscf - forge This command creates a .pth file in ~/.local/lib/python3.*/site-packages/ or other Python runtime paths. It is recommended to use this method with Python\nvirtual environments."
  },
  {
    "name": "Method_2_Setting_an_environment_variable",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Method_2_Setting_an_environment_variable {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "As described above, you can also define the PYSCF_EXT_PATH environment\nvariable to point to your local PySCF-forge directory, export PYSCF_EXT_PATH =/ path / to / pyscf - forge"
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "As described above, you can also define the PYSCF_EXT_PATH environment\nvariable to point to your local PySCF-forge directory, export PYSCF_EXT_PATH =/ path / to / pyscf - forge"
  },
  {
    "name": "Adding_new_features_An_example",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Adding_new_features_An_example {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Suppose you want to create a new module in PySCF-forge that provides a new\nfeature called abc .  You can follow these steps to add the module, Install PySCF-forge in editable installation mode. Create a folder named pyscf-forge/pyscf/abc .  Due to the editable\ninstallation mode, this folder can be r"
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "Suppose you want to create a new module in PySCF-forge that provides a new\nfeature called abc .  You can follow these steps to add the module, Install PySCF-forge in editable installation mode. Create a folder named pyscf-forge/pyscf/abc .  Due to the editable\ninstallation mode, this folder can be readily imported as a regular pyscf module. >>> from pyscf import abc >>> print ( abc ) <module 'pyscf.abc' (namespace)> >>> print ( abc . __path__ ) _NamespacePath(['path/to/pyscf-forge/pyscf/abc']) Add Python code files to the pyscf-forge/pyscf/abc directory.  This\nprocess is similar to developing new methods for PySCF.  For example, you\ncan add the following Python files into the pyscf-forge/pyscf/abc folder, pyscf-forge\n├── ...\n└── pyscf\n    ├── ...\n    └── abc\n        ├── __init__.py\n       "
  },
  {
    "name": "Path_Conflicts",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Path_Conflicts {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "What if you want to add a feature to a module that already exists in PySCF?\nFor example, if you want to add a new method, like pp_rpa.py , to the pyscf/tdscf folder, this could conflict with the existing pyscf.tdscf module in the PySCF core repository.  Adding features to existing modules\nrequires m"
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "What if you want to add a feature to a module that already exists in PySCF?\nFor example, if you want to add a new method, like pp_rpa.py , to the pyscf/tdscf folder, this could conflict with the existing pyscf.tdscf module in the PySCF core repository.  Adding features to existing modules\nrequires more a slightly more complex configuration. To import the pp_rpa module from the PySCF-forge repository, you will need to\nmodify the __init__.py file of the PySCF core module.  Add the following line\nof code to modify the __path__ attribute of the pyscf.tdscf module, __path__ = __import__ ( 'pkgutil' ) . extend_path ( __path__ , __name__ ) This command extends the search path of the tdscf module, resulting in the __path__ attribute being set to [ '/path/to/pyscf/pyscf/tdscf' , '/path/to/pyscf-for"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "pyscf-forge",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "In the Quantum Mechanics - Molecular Mechanics (QM/MM) method,\nthe system is divided into a QM region and an MM region.\nQM/MM models mainly differ in the treatment of the interaction\nbetween QM and MM regions. The qmmm module implements the electronic embedding model,\nwhere classical point charges i"
      }
    ],
    "parent_section": "qmmm",
    "description": "In the Quantum Mechanics - Molecular Mechanics (QM/MM) method,\nthe system is divided into a QM region and an MM region.\nQM/MM models mainly differ in the treatment of the interaction\nbetween QM and MM regions. The qmmm module implements the electronic embedding model,\nwhere classical point charges in the MM region are\nadded into the QM Hamiltonian analogously to the nuclear charges: \\[\\begin{split}\\mathbf{H}_{\\mathrm{QMMM}} =&\\ \\mathbf{H}_{\\mathrm{QM}}\n    + \\mathbf{V}_{\\mathrm{nuc}-\\mathrm{MM}} + \\mathbf{V}_{\\mathrm{elec}-\\mathrm{MM}} \\\\\n    =&\\ \\mathbf{H}_{\\mathrm{QM}} + \\sum_{A}^{N_{\\mathrm{MM}}} \\sum_{B}^{N_{\\mathrm{QM}}}\n        \\frac{Q_{A}Q_{B}}{|\\mathbf{R}_A - \\mathbf{R}_B|}\n    - \\sum_{A}^{N_{\\mathrm{MM}}} \\sum_i^{N_{\\mathrm{elec}}}\n        \\frac{Q_{A}}{|\\mathbf{R}_A - \\mathbf{r}_i"
  },
  {
    "name": "SCF_methods_with_MM_charges",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "SCF_methods_with_MM_charges {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "MM background charges support SCF methods scf.RHF() , scf.UHF() , scf.ROHF() , scf.RKS() , scf.UKS() and scf.ROKS() ,\nby decorating the underlying SCF objects with qmmm.mm_charge() .\nA minimal example of using the qmmm module is as follows. >>> from pyscf import gto , scf , qmmm >>> mol = gto . M ( "
      }
    ],
    "parent_section": "qmmm",
    "description": "MM background charges support SCF methods scf.RHF() , scf.UHF() , scf.ROHF() , scf.RKS() , scf.UKS() and scf.ROKS() ,\nby decorating the underlying SCF objects with qmmm.mm_charge() .\nA minimal example of using the qmmm module is as follows. >>> from pyscf import gto , scf , qmmm >>> mol = gto . M ( atom = 'H 0 0 0; F 0 0 1' , basis = 'ccpvdz' ) >>> coords = [( 0.5 , 0.6 , 0.8 )] >>> charges = [ - 0.3 ] >>> mf = qmmm . mm_charge ( scf . RHF ( mol ), coords , charges ) >>> mf . kernel () converged SCF energy = -100.045455504517 In the above example, the coordinates (in the same unit as mol.unit ) and\ncharges of the point charges in the MM region are given by coords and charges ,\nrespectively. Note Currently, MM charges do not support scf.GHF() and scf.GKS() . Analytical nuclear gradients are"
  },
  {
    "name": "Post_SCF_methods_with_MM_charges",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Post_SCF_methods_with_MM_charges {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Once function qmmm.mm_charge() is\napplied on the SCF object, it affects all the\npost-HF calculations, eg. MP2, CCSD, MCSCF, etc. >>> from pyscf import mcscf >>> mf = qmmm . mm_charge ( scf . RHF ( mol ), coords , charges ) . run () >>> mc = mcscf . CASSCF ( mf , 4 , 4 ) >>> mc . run ( conv_tol = 1E-"
      }
    ],
    "parent_section": "qmmm",
    "description": "Once function qmmm.mm_charge() is\napplied on the SCF object, it affects all the\npost-HF calculations, eg. MP2, CCSD, MCSCF, etc. >>> from pyscf import mcscf >>> mf = qmmm . mm_charge ( scf . RHF ( mol ), coords , charges ) . run () >>> mc = mcscf . CASSCF ( mf , 4 , 4 ) >>> mc . run ( conv_tol = 1E-10 ) CASSCF energy = -100.101848457578 CASCI E = -100.101848457578  E(CI) = -6.74400107375546  S^2 = 0.0000000"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "qmmm",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Self-consistent field (SCF) methods include both Hartree-Fock (HF) theory\nand Kohn-Sham (KS) density functional theory (DFT). Self-consistent\nfield theories only depend on the electronic density matrices, and are\nthe simplest level of quantum chemical models. Details that are\nspecific to DFT can be "
      }
    ],
    "parent_section": "scf",
    "description": "Self-consistent field (SCF) methods include both Hartree-Fock (HF) theory\nand Kohn-Sham (KS) density functional theory (DFT). Self-consistent\nfield theories only depend on the electronic density matrices, and are\nthe simplest level of quantum chemical models. Details that are\nspecific to DFT can be found in Density functional theory (DFT) . In both HF and KS-DFT, the ground-state wavefunction is expressed as a\nsingle Slater determinant \\(\\Phi_0\\) of molecular orbitals (MOs) \\(\\psi\\) , \\(\\Phi_0 = \\mathcal{A}|\\psi_1(1)\\psi_2(2) \\ldots\n\\psi_N(N)|\\) . The total electronic energy \\(E=\\langle\\Psi_0|\\hat{H}|\\Psi_0\\rangle\\) is then minimized,\nsubject to orbital orthogonality; this is equivalent to the\ndescription of the electrons as independent particles that only\ninteract via each others’ mean fi"
  },
  {
    "name": "Initial_guess",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Initial_guess {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The Coulomb and exchange matrices depend on the occupied orbitals,\nmeaning that the SCF equation \\(\\mathbf{F C}=\\mathbf{S C E}\\) needs to be solved self-consistently by some sort of iterative\nprocedure, which begins from some initial guess. The accuracy of\nseveral initial guesses for SCF calculation"
      }
    ],
    "parent_section": "scf",
    "description": "The Coulomb and exchange matrices depend on the occupied orbitals,\nmeaning that the SCF equation \\(\\mathbf{F C}=\\mathbf{S C E}\\) needs to be solved self-consistently by some sort of iterative\nprocedure, which begins from some initial guess. The accuracy of\nseveral initial guesses for SCF calculations has recently been\nassessed in [ 3 ] , to which we refer for\ndetailed discussion on initial guesses. Several of initial guess have been implemented in PySCF; the used\nvariant is controlled by the init_guess attribute of the SCF\nsolver. The following values are possible 'minao' (default) A superposition of atomic densities [ 4 , 5 ] technique, in\nwhich the guess is obtained by projecting the minimal basis of the\nfirst contracted functions in the cc-pVTZ or cc-pVTZ-PP basis set\nonto the orbital b"
  },
  {
    "name": "Restart_from_an_old_calculation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Restart_from_an_old_calculation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Although alike many other quantum chemistry codes, there is no restart mechanism available in PySCF package, calculations can still\nbe “restarted” by reading in an earlier wave function as the initial\nguess for the wave function.  The initial guess can be prepared in\nmany ways.  One is to read the c"
      }
    ],
    "parent_section": "scf",
    "description": "Although alike many other quantum chemistry codes, there is no restart mechanism available in PySCF package, calculations can still\nbe “restarted” by reading in an earlier wave function as the initial\nguess for the wave function.  The initial guess can be prepared in\nmany ways.  One is to read the chkpoint file which is generated in\nthe previous or other calculations: >>> from pyscf import scf >>> mf = scf . RHF ( mol ) >>> mf . chkfile = '/path/to/chkfile' >>> mf . init_guess = 'chkfile' >>> mf . kernel () /path/to/chkfile can be found in the output in the calculation (if mol.verbose >= 4 , the filename of the chkfile will be dumped in\nthe output).  If the results of the calculation are needed at a later\nstage (e.g. for an eventual restart or use as an initial guess for a\nlarger calculati"
  },
  {
    "name": "Converging_SCF_iterations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Converging_SCF_iterations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Even with a very good initial guess, making the SCF procedure converge\nis sometimes challenging. PySCF implements two kinds of approaches for\nSCF, namely, direct inversion in the iterative subspace (DIIS) and\nsecond-order SCF (SOSCF). DIIS (default) With DIIS, the Fock matrix at each iteration is ex"
      }
    ],
    "parent_section": "scf",
    "description": "Even with a very good initial guess, making the SCF procedure converge\nis sometimes challenging. PySCF implements two kinds of approaches for\nSCF, namely, direct inversion in the iterative subspace (DIIS) and\nsecond-order SCF (SOSCF). DIIS (default) With DIIS, the Fock matrix at each iteration is extrapolated using\nFock matrices from the previous iterations, by minimizing the norm\nof the commutator \\([\\mathbf{F},\\mathbf{PS}]\\) where \\(\\mathbf{P}\\) is the density matrix [ 7 , 8 ] .  Two variants of DIIS\nare implemented in PySCF, namely, EDIIS [ 9 ] and ADIIS [ 10 ] .  Examples of selecting\ndifferent DIIS schemes can be found in examples/scf/24-tune_diis.py . SOSCF To achieve quadratic convergence in the orbital optimization,\nPySCF implements a general second-order solver called the\nco-itera"
  },
  {
    "name": "Stability_analysis",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Stability_analysis {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Even when the SCF converges, the wave function that is found may not\ncorrespond to a local minimum; calculations can sometimes also\nconverge onto saddle points. Since saddle points are also extrema of\nthe energy functional, the orbital gradient vanishes and the SCF\nequation \\(\\mathbf{F C}=\\mathbf{S "
      }
    ],
    "parent_section": "scf",
    "description": "Even when the SCF converges, the wave function that is found may not\ncorrespond to a local minimum; calculations can sometimes also\nconverge onto saddle points. Since saddle points are also extrema of\nthe energy functional, the orbital gradient vanishes and the SCF\nequation \\(\\mathbf{F C}=\\mathbf{S C E}\\) is satisfied [ 1 ] . However, in such cases the energy can be\ndecreased by perturbing the orbitals away from the saddle point, which\nmeans that the wave function is unstable. Instabilities in the wave function are conventionally classified as\neither internal or external [ 13 ] . External\ninstabilities mean that the energy can be decreased by loosening some\nconstraints on the wave function, such as allowing restricted\nHartree-Fock orbitals to transform into unrestricted Hartree-Fock,\nwhere"
  },
  {
    "name": "Property_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Property_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Various properties can be computed by calling the corresponding\nfunctions, for example, dipole moment: mf . dip_moment () Mulliken population: mf . mulliken_pop () nuclear gradients: g = mf . Gradients () g . kernel () Also several response properties are available in PySCF\nwith the properties exten"
      }
    ],
    "parent_section": "scf",
    "description": "Various properties can be computed by calling the corresponding\nfunctions, for example, dipole moment: mf . dip_moment () Mulliken population: mf . mulliken_pop () nuclear gradients: g = mf . Gradients () g . kernel () Also several response properties are available in PySCF\nwith the properties extension, see the\nexamples there ."
  },
  {
    "name": "Spin_restricted_spin_unrestricted_restricted_open_shell_and_generalized_calculations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Spin_restricted_spin_unrestricted_restricted_open_shell_and_generalized_calculations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The general spin-orbital used in the HF or KS-DFT wave function can be\nwritten as \\[\\psi_i(1) = \\phi_{i\\alpha}(r)\\alpha + \\phi_{i\\beta}(r)\\beta \\;,\\] Four variants of the ansatz \\(\\psi(1)\\) are commonly used in\nquantum chemistry; they are also all available in PySCF. Restricted (RHF/RKS) The spin-or"
      }
    ],
    "parent_section": "scf",
    "description": "The general spin-orbital used in the HF or KS-DFT wave function can be\nwritten as \\[\\psi_i(1) = \\phi_{i\\alpha}(r)\\alpha + \\phi_{i\\beta}(r)\\beta \\;,\\] Four variants of the ansatz \\(\\psi(1)\\) are commonly used in\nquantum chemistry; they are also all available in PySCF. Restricted (RHF/RKS) The spin-orbitals are either alpha (spin-up) or beta (spin-down), \\(\\psi_i =\\phi_i(r)\\alpha\\) or \\(\\psi_i = \\phi_i(r)\\beta\\) ,\nand the alpha and beta orbitals share the same spatial orbital \\(\\phi_i(r)\\) . The closed-shell determinant is thus \\(\\Phi=\\mathcal{A}|\\phi_1(r_1)\\alpha \\phi_1(r_2)\\beta \\ldots\n\\phi_{N/2}(r_{N-1})\\alpha \\phi_{N/2}(r_N)\\beta|\\) and \\(S=0\\) . Unrestricted (UHF/UKS) The orbitals can have either alpha or beta spin, but the alpha and\nbeta orbitals may have different spatial components. "
  },
  {
    "name": "Linear_dependencies",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Linear_dependencies {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Most quantum chemistry programs solve the self-consistent field\nequations \\[\\mathbf{F} \\mathbf{C} = \\mathbf{S} \\mathbf{C} \\mathbf{E}\\] in an orthonormal basis, which is formally obtained as \\[\\mathbf{C} = \\mathbf{X} \\tilde{\\mathbf{C}}\\] where the orthogonalizing matrix \\(\\mathbf{X}\\) is typically\nch"
      }
    ],
    "parent_section": "scf",
    "description": "Most quantum chemistry programs solve the self-consistent field\nequations \\[\\mathbf{F} \\mathbf{C} = \\mathbf{S} \\mathbf{C} \\mathbf{E}\\] in an orthonormal basis, which is formally obtained as \\[\\mathbf{C} = \\mathbf{X} \\tilde{\\mathbf{C}}\\] where the orthogonalizing matrix \\(\\mathbf{X}\\) is typically\nchosen as \\(\\mathbf{X}=\\mathbf{S}^{-1/2}\\) . By expressing the\norbitals in terms of the half-inverse overlap matrix, the generalized\neigenproblem \\(\\mathbf{F} \\mathbf{C} = \\mathbf{S} \\mathbf{C}\n\\mathbf{E}\\) can be rewritten as a regular eigenproblem \\(\\tilde{\\mathbf{F}} \\tilde{\\mathbf{C}} = \\tilde{\\mathbf{C}}\n\\mathbf{E}\\) [ 1 ] . Moreover, as the half-inverse overlap matrix \\(\\mathbf{S}^{-1/2}\\) is typically formed by the canonical orthonormalization procedure [ 14 ] in which eigenvectors of the o"
  },
  {
    "name": "Scalar_relativistic_correction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Scalar_relativistic_correction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Scalar relativistic effects can be applied on the one-body operators\nthrough spin-free eXact-2-component (SFX2C) Hamiltonian [ 17 ] .  The SFX2C Hamiltonian can be invoked by\ndecorating the SCF objects with the x2c() method, three other\nequivalent function names are also listed below: mf = scf . RHF"
      }
    ],
    "parent_section": "scf",
    "description": "Scalar relativistic effects can be applied on the one-body operators\nthrough spin-free eXact-2-component (SFX2C) Hamiltonian [ 17 ] .  The SFX2C Hamiltonian can be invoked by\ndecorating the SCF objects with the x2c() method, three other\nequivalent function names are also listed below: mf = scf . RHF ( mol ) . x2c () mf = scf . RHF ( mol ) . x2c1e () mf = scf . RHF ( mol ) . sfx2c () mf = scf . RHF ( mol ) . sfx2c1e () Note that the SFX2C Hamiltonian only changes the one-body operators,\nand it only accounts for the mass-velocity effect, while picture\nchange effect and spin-orbit coupling are not included.  Once the SCF\nobject is decorated by x2c() method, the corresponding post-SCF\nobjects will also automatically have the SFX2C Hamiltonian applied.\nTo turn it off explicitly, one can do: mf "
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "scf",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Direct computation of the Hartree-Fock exchange matrix in the atomic orbital basis scales poorly with system size.\nTo achieve better scaling, one three-dimensional integral in the 6-dimensional two-electron integrals can be computed analytically, while the other can be evaluated on a real-space grid"
      }
    ],
    "parent_section": "sgx",
    "description": "Direct computation of the Hartree-Fock exchange matrix in the atomic orbital basis scales poorly with system size.\nTo achieve better scaling, one three-dimensional integral in the 6-dimensional two-electron integrals can be computed analytically, while the other can be evaluated on a real-space grid, as proposed by Friesner [ 88 ] .\nThe PySCF implementation resembles the chain-of-spheres (COSX) algorithm of Neese et al. [ 89 ] , but uses more conservative grids and a slightly different P-junction screening function.\nOverlap fitting is used to reduce aliasing errors [ 90 ] .\nSGX scales as \\(O(N^2)\\) with system size, as opposed to the \\(O(N^4)\\) scaling of analytical exchange [ 89 ] ."
  },
  {
    "name": "Usage_and_Example",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Usage_and_Example {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Any scf.hf.SCF object mf can be converted to an equivalent object that computes the Coulomb and exchange matrices with SGX instead of analytical integration by calling sgx.sgx_fit(mf) . examples/sgx/00-simple_sgx.py #!/usr/bin/env python ''' This example shows how to use pseudo spectral integrals in"
      }
    ],
    "parent_section": "sgx",
    "description": "Any scf.hf.SCF object mf can be converted to an equivalent object that computes the Coulomb and exchange matrices with SGX instead of analytical integration by calling sgx.sgx_fit(mf) . examples/sgx/00-simple_sgx.py #!/usr/bin/env python ''' This example shows how to use pseudo spectral integrals in SCF calculation. ''' from pyscf import gto from pyscf import scf from pyscf import sgx mol = gto . M ( atom = '''O    0.   0.       0. H    0.   -0.757   0.587 H    0.   0.757    0.587 ''' , basis = 'ccpvdz' , ) # Direct K matrix for comparison mf = scf . RHF ( mol ) mf . kernel () # Using SGX for J-matrix and K-matrix, without using P-junction screening mf = sgx . sgx_fit ( scf . RHF ( mol ), pjs = False ) mf . kernel () # Using RI for Coulomb matrix while K-matrix is constructed with SGX meth"
  },
  {
    "name": "Adjustable_Parameters",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Adjustable_Parameters {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Calling the sgx_fit function on an scf.hf.SCF object returns an equivalent SGXHF object with a with_df attribute that handles SGX integration. To use a non-default auxiliary basis (for dfj=True ), auxbasis can be specified in the call to sgx_fit . In addition, there are various adjustable parameters"
      }
    ],
    "parent_section": "sgx",
    "description": "Calling the sgx_fit function on an scf.hf.SCF object returns an equivalent SGXHF object with a with_df attribute that handles SGX integration. To use a non-default auxiliary basis (for dfj=True ), auxbasis can be specified in the call to sgx_fit . In addition, there are various adjustable parameters for SGX: with_df attributes: grids_level_i : The grid level to use for initial SCF iterations. grids_level_f : The grid level to use for final SCF iterations. grids_thrd : The grid points where no atomic orbital is significant (has a value greater than this threshold) are removed from consideration. grids_switch_thrd : The threshold for the magnitude of the change in the density matrix that triggers the switch from the initial grid specified by grids_level_i to the final grid specified by grids"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "sgx",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Solvation model allows the quantum chemistry calculations to include the\ninteractions between solvents and the quantum solute. Solvents can be treated\nimplicitly, known as continuum solvents, and explicitly. For continuum solvents,\nwe implemented the PCM (polarizable continuum model), ddCOSMO (domai"
      }
    ],
    "parent_section": "solvent",
    "description": "Solvation model allows the quantum chemistry calculations to include the\ninteractions between solvents and the quantum solute. Solvents can be treated\nimplicitly, known as continuum solvents, and explicitly. For continuum solvents,\nwe implemented the PCM (polarizable continuum model), ddCOSMO (domain-decomposition COSMO solvation model),\nddPCM (domain-decomposition polarizable continuum model),\nand SMD (Solvation Model Density). For the explicit solvent environment,\nwe provided the interface to call the polarizable embedding library CPPE."
  },
  {
    "name": "PCM_model",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "PCM_model {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF support four types of PCM solvent models, i.e. C-PCM, IEF-PCM, SS(V)PE, and COSMO\n(See https://manual.q-chem.com/5.2/Ch12.S2.SS2.html for more detailed descriptions of these methods).\nThe analytical gradient and semi-analytical Hessian are also supported. PCM solvent models can be applied on t"
      }
    ],
    "parent_section": "solvent",
    "description": "PySCF support four types of PCM solvent models, i.e. C-PCM, IEF-PCM, SS(V)PE, and COSMO\n(See https://manual.q-chem.com/5.2/Ch12.S2.SS2.html for more detailed descriptions of these methods).\nThe analytical gradient and semi-analytical Hessian are also supported. PCM solvent models can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' ) . PCM () mf . with_solvent . method = 'IEF-PCM' # C-PCM, SS(V)PE, COSMO mf . with_solvent . eps = 78.3553 # for water mf . run () In regular MCSCF (CASCI or CASSCF), and post-SCF calculations, the setup for\nself-consistent solvent is similar: import pyscf mol = pyscf . M ( a"
  },
  {
    "name": "Solvent_for_excited_states",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Solvent_for_excited_states {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "When combining to TDDFT or other methods of excited states, solvent can be\nmodelled in the manner of self-consistency (fast solvent) or single shot (slow\nsolvent). Below we use TDDFT to demonstrate the treatments of fast solvent\nand slow solvent. In vertical excitations, the solvent almost does not "
      }
    ],
    "parent_section": "solvent",
    "description": "When combining to TDDFT or other methods of excited states, solvent can be\nmodelled in the manner of self-consistency (fast solvent) or single shot (slow\nsolvent). Below we use TDDFT to demonstrate the treatments of fast solvent\nand slow solvent. In vertical excitations, the solvent almost does not respond to the change of\nelectronic structure. It should be viewed as slow solvent. The calculation\ncan be started with an SCF with fully relaxed solvent and followed by a regular\nTDDFT method: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RHF () . PCM () . run () td = mf . TDA () . run () In the diabatic excitations, we would like to let the solvent rapidl"
  },
  {
    "name": "Solvent_parameters",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Solvent_parameters {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The default solvent in the PCM module is water. When studying other types of\nsolvents, you can consider to modify the dielectric parameter eps using the\nconstants listed below: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -"
      }
    ],
    "parent_section": "solvent",
    "description": "The default solvent in the PCM module is water. When studying other types of\nsolvents, you can consider to modify the dielectric parameter eps using the\nconstants listed below: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RHF () . PCM () mf . with_solvent . eps = 32.613 # methanol mf . run () These dielectric constants are obtained from https://gaussian.com/scrf/ .\nMore dataset can be found in Minnesota Solvent Descriptor Database\n( https://comp.chem.umn.edu/solvation )"
  },
  {
    "name": "ddCOSMO",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ddCOSMO {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Self-consistent solvents for ground state # Solvent model can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' "
      }
    ],
    "parent_section": "solvent",
    "description": "Self-consistent solvents for ground state # Solvent model can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' ) . DDCOSMO () . run ()"
  },
  {
    "name": "Self_consistent_solvents_for_ground_state",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Self_consistent_solvents_for_ground_state {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Solvent model can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' ) . DDCOSMO () . run ()"
      }
    ],
    "parent_section": "solvent",
    "description": "Solvent model can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' ) . DDCOSMO () . run ()"
  },
  {
    "name": "SMD_model",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "SMD_model {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "SMD model is recommended for computing solvation free energy. The implementation of SMD model\nin PySCF is based on IEF-PCM. Other SMx models are not supported yet\n(See https://manual.q-chem.com/5.2/Ch12.S2.SS8.html ). The source code for CDS contribution\nis taken from NWChem ( nwchemgit/nwchem )\nSMD"
      }
    ],
    "parent_section": "solvent",
    "description": "SMD model is recommended for computing solvation free energy. The implementation of SMD model\nin PySCF is based on IEF-PCM. Other SMx models are not supported yet\n(See https://manual.q-chem.com/5.2/Ch12.S2.SS8.html ). The source code for CDS contribution\nis taken from NWChem ( nwchemgit/nwchem )\nSMD solvent solvent models can be applied on to an SCF object: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935   -1.082 H  0.   -0.935   -1.082''' , basis = '6-31g*' , verbose = 4 ) mf = mol . RKS ( xc = 'b3lyp' ) . SMD () mf . with_solvent . solvent = 'water' mf . run () The solvent descriptor can be assigned to the with_solvent directly: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.      -0.542 O  0.    0.       0.677 H  0.    0.935"
  },
  {
    "name": "Polarizable_embedding",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Polarizable_embedding {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To use polarizable embedding model for mean-field calculations, one would need\nto first generate potential data for the input of CPPE library. The best way to\ngenerate potential files is with PyFraME .\nYou can directly throw in a pdb file, select the QM region and how to parametrize\ndifferent parts "
      }
    ],
    "parent_section": "solvent",
    "description": "To use polarizable embedding model for mean-field calculations, one would need\nto first generate potential data for the input of CPPE library. The best way to\ngenerate potential files is with PyFraME .\nYou can directly throw in a pdb file, select the QM region and how to parametrize\ndifferent parts of the environment (with either pre-defined potentials, or with LoProp).\nSome guidance is also provided in the Tutorial Review paper about PE, section 4: https://onlinelibrary.wiley.com/doi/full/10.1002/qua.25717 Therein, the format of the potential file is also explained (it’s the same\nformat as used in the original Dalton pelib implementation). With the generated potential file, one can carry out the polarizable embedding\ncalculations: import pyscf mol = pyscf . M ( atom = ''' C  0.    0.     "
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "solvent",
    "description": "Show Source"
  },
  {
    "name": "Introduction",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Introduction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF implements the time-dependent Hartree-Fock (TDHF) and\ntime-dependent density functional theory (TDDFT) (frequency domain)\nlinear response theories to compute excited-state energies\nand transition properties in the tdscf module.\nA minimal example that runs a TDDFT calculation is as follows from"
      }
    ],
    "parent_section": "tddft",
    "description": "PySCF implements the time-dependent Hartree-Fock (TDHF) and\ntime-dependent density functional theory (TDDFT) (frequency domain)\nlinear response theories to compute excited-state energies\nand transition properties in the tdscf module.\nA minimal example that runs a TDDFT calculation is as follows from pyscf import gto , scf , dft , tddft mol = gto . Mole () mol . build ( atom = 'H 0 0 0; F 0 0 1.1' , # in Angstrom basis = '631g' , symmetry = True , verbose = 4 , ) mf = dft . RKS ( mol ) mf . xc = 'b3lyp' mf . kernel () mytd = tddft . TDDFT ( mf ) mytd . nstates = 10 mytd . kernel () mytd . analyze () The example above computes the excitation energies, oscillator strengths\nand transition dipole moments of the ten lowest singlet exicted states."
  },
  {
    "name": "Theory",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Theory {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Using first-order time-dependent perturbation theory within HF or KS theory,\none obtains the non-Hermitian TDHF or TDDFT equations for the excitation energies [ 59 ] : \\[\\begin{split}\\left(\\!\\!\\begin{array}{ll}\n    \\mathbf{A} & \\mathbf{B} \\\\\n    \\mathbf{B}^\\ast & \\mathbf{A}^\\ast\n\\end{array}\\!\\!\\righ"
      }
    ],
    "parent_section": "tddft",
    "description": "Using first-order time-dependent perturbation theory within HF or KS theory,\none obtains the non-Hermitian TDHF or TDDFT equations for the excitation energies [ 59 ] : \\[\\begin{split}\\left(\\!\\!\\begin{array}{ll}\n    \\mathbf{A} & \\mathbf{B} \\\\\n    \\mathbf{B}^\\ast & \\mathbf{A}^\\ast\n\\end{array}\\!\\!\\right)\n\\left(\\!\\!\\begin{array}{c}\n    \\mathbf{X} \\\\ \\mathbf{Y}\n\\end{array}\\!\\!\\right) = \\omega\n\\left(\\!\\!\\begin{array}{lr}\n    \\mathbf{1} & \\mathbf{0} \\\\\n    \\mathbf{0} & -\\mathbf{1}\n\\end{array}\\!\\!\\right)\n\\left(\\!\\!\\begin{array}{c}\n    \\mathbf{X} \\\\ \\mathbf{Y}\n\\end{array}\\!\\!\\right) \\;,\\end{split}\\] where \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\) are the orbital\nhessians which also appear in the stability analysis for reference states (see Stability analysis ), \\(\\omega\\) is the excitation energy, and \\(\\m"
  },
  {
    "name": "Methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "For TDHF or TDDFT calculations,\nthe reference state can be either restricted or unrestricted: mytd = mol . RKS () . run () . TDDFT () . run () mytd = mol . UKS () . run () . TDDFT () . run () By default, only singlet excited states are computed.\nIn order to compute triplet excited states, one needs "
      }
    ],
    "parent_section": "tddft",
    "description": "For TDHF or TDDFT calculations,\nthe reference state can be either restricted or unrestricted: mytd = mol . RKS () . run () . TDDFT () . run () mytd = mol . UKS () . run () . TDDFT () . run () By default, only singlet excited states are computed.\nIn order to compute triplet excited states, one needs to set the\nattribute singlet to False : mytd . singlet = False mytd . kernel () One can also perform symmetry analysis by calling the analyze() method,\nwhich also computes the oscillator strengths and dipole moments: mytd . analyze ( verbose = 4 )"
  },
  {
    "name": "Property_calculation",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Property_calculation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Oscillator strengths # Oscillator strengths for each excited state can be computed in\nboth length and velocity gauges: mytd . oscillator_strength ( gauge = 'length' ) mytd . oscillator_strength ( gauge = 'velocity' ) Higher order corrections [ 61 ] to the oscillator strength can also be included: #i"
      }
    ],
    "parent_section": "tddft",
    "description": "Oscillator strengths # Oscillator strengths for each excited state can be computed in\nboth length and velocity gauges: mytd . oscillator_strength ( gauge = 'length' ) mytd . oscillator_strength ( gauge = 'velocity' ) Higher order corrections [ 61 ] to the oscillator strength can also be included: #include corrections due to magnetic dipole and electric quadruple mytd . oscillator_strength ( gauge = 'velocity' , order = 1 ) #also include corrections due to magnetic quadruple and electric octupole mytd . oscillator_strength ( gauge = 'velocity' , order = 2 ) Transition moments # PySCF implements various types of transition moments between the reference SCF state and\nthe TDHF or TDDFT excited states. These include: electric dipole, quadrupole and octupole transition moments in both length and"
  },
  {
    "name": "Oscillator_strengths",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Oscillator_strengths {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Oscillator strengths for each excited state can be computed in\nboth length and velocity gauges: mytd . oscillator_strength ( gauge = 'length' ) mytd . oscillator_strength ( gauge = 'velocity' ) Higher order corrections [ 61 ] to the oscillator strength can also be included: #include corrections due "
      }
    ],
    "parent_section": "tddft",
    "description": "Oscillator strengths for each excited state can be computed in\nboth length and velocity gauges: mytd . oscillator_strength ( gauge = 'length' ) mytd . oscillator_strength ( gauge = 'velocity' ) Higher order corrections [ 61 ] to the oscillator strength can also be included: #include corrections due to magnetic dipole and electric quadruple mytd . oscillator_strength ( gauge = 'velocity' , order = 1 ) #also include corrections due to magnetic quadruple and electric octupole mytd . oscillator_strength ( gauge = 'velocity' , order = 2 )"
  },
  {
    "name": "Transition_moments",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Transition_moments {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "PySCF implements various types of transition moments between the reference SCF state and\nthe TDHF or TDDFT excited states. These include: electric dipole, quadrupole and octupole transition moments in both length and velocity gauges: mytd . transition_dipole () mytd . transition_velocity_dipole () m"
      }
    ],
    "parent_section": "tddft",
    "description": "PySCF implements various types of transition moments between the reference SCF state and\nthe TDHF or TDDFT excited states. These include: electric dipole, quadrupole and octupole transition moments in both length and velocity gauges: mytd . transition_dipole () mytd . transition_velocity_dipole () mytd . transition_quadrupole () mytd . transition_velocity_quadrupole () mytd . transition_octupole () mytd . transition_velocity_octupole () magnetic dipole and quadrupole transition moments: mytd . transition_magnetic_dipole () mytd . transition_magnetic_quadrupole ()"
  },
  {
    "name": "Nuclear_gradients",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Nuclear_gradients {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Analytic nuclear gradients are available for TDHF and TDDFT,\nand they can be computed as follows: tdg = mytd . Gradients () g1 = tdg . kernel () #default will compute the gradients of first excited state g1 = tdg . kernel ( state = 1 ) #first excited state g2 = tdg . kernel ( state = 2 ) #second exc"
      }
    ],
    "parent_section": "tddft",
    "description": "Analytic nuclear gradients are available for TDHF and TDDFT,\nand they can be computed as follows: tdg = mytd . Gradients () g1 = tdg . kernel () #default will compute the gradients of first excited state g1 = tdg . kernel ( state = 1 ) #first excited state g2 = tdg . kernel ( state = 2 ) #second excited state"
  },
  {
    "name": "Natural_transition_orbital_analysis",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Natural_transition_orbital_analysis {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Natural transition orbitals (NTOs) can be computed by\nsingular value decomposition of the transition density matrix.\nIn PySCF, these orbitals can be obtained as follows: weights , nto_coeff = mytd . get_nto ( state = 1 ) where nto_coeff are the coefficients for NTOs represented in AO basis,\nand they"
      }
    ],
    "parent_section": "tddft",
    "description": "Natural transition orbitals (NTOs) can be computed by\nsingular value decomposition of the transition density matrix.\nIn PySCF, these orbitals can be obtained as follows: weights , nto_coeff = mytd . get_nto ( state = 1 ) where nto_coeff are the coefficients for NTOs represented in AO basis,\nand they are ordered as occupied orbitals followed by virtual orbitals."
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "tddft",
    "description": "Show Source"
  },
  {
    "name": "Modules_classes_and_the_kernel_method",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Modules_classes_and_the_kernel_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Similar to NumPy or SciPy , PySCF is\na collection of modules, such as gto (for defining molecules with Gaussian type orbitals), scf (for self-consistent field calculations), or cc (for coupled-cluster calculations).\nModules must be imported to be used, from pyscf import gto , scf , cc Modules provid"
      }
    ],
    "parent_section": "using",
    "description": "Similar to NumPy or SciPy , PySCF is\na collection of modules, such as gto (for defining molecules with Gaussian type orbitals), scf (for self-consistent field calculations), or cc (for coupled-cluster calculations).\nModules must be imported to be used, from pyscf import gto , scf , cc Modules provide access to both functions and classes, where the latter is more commonly\nused to define a calculation. For example, the gto module provides the gto.Mole class,\nthe scf module provides the scf.RHF class (and others, such as scf.UHF , etc.), and\nthe cc module provides the cc.CCSD class. Performing a calculation in PySCF typically involves\nimporting a module, instantiating a class provided by that module with some arguments,\nand executing the functions of that class. For example, from pyscf import"
  },
  {
    "name": "Stream_methods",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Stream_methods {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "To unify the return value of different methods and thus allow chaining calculations together,\nPySCF includes three “stream methods”. A stream method of an object only returns the object\nitself. The three stream methods are described below. The set method updates object attributes. For example, mf = "
      }
    ],
    "parent_section": "using",
    "description": "To unify the return value of different methods and thus allow chaining calculations together,\nPySCF includes three “stream methods”. A stream method of an object only returns the object\nitself. The three stream methods are described below. The set method updates object attributes. For example, mf = scf . RHF ( mol ) . set ( conv_tol = 1e-5 ) is identical to two lines of statements, mf = scf . RHF ( mol ) mf . conv_tol = 1e-5 The run method calls the kernel method.  Arguments passed to the run method will be passed to the kernel method.  If keyword arguments are\ngiven, run will first call the set method to update the attributes and\nthen execute the kernel method.  For example, mf = scf . RHF ( mol ) . run ( dm_init , conv_tol = 1e-5 ) is identical to three lines of statements, mf = scf . RH"
  },
  {
    "name": "Scanners",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Scanners {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "A scanner is a function that takes a Mole (or Cell ) object as input and\nreturns the energy or nuclear gradients at a chosen level of theory. A scanner\ncan be considered as a shortcut function for a sequence of statements, which\nincludes the initialization of a required calculation model with possib"
      }
    ],
    "parent_section": "using",
    "description": "A scanner is a function that takes a Mole (or Cell ) object as input and\nreturns the energy or nuclear gradients at a chosen level of theory. A scanner\ncan be considered as a shortcut function for a sequence of statements, which\nincludes the initialization of a required calculation model with possible\nprecomputing, updating the attributes based on the settings of the referred\nobject, calling the kernel function, and finally returning results. For example, consider the following conventional script to perform a potential\nenergy surface scan of the dissociation of the hydrogen molecule using CCSD, for r in ( 1.0 , 1.1 , 1.2 ): mol = gto . M ( atom = f \"H 0 0 0; H 0 0 { r } \" ) mf = scf . RHF ( mol ) . run () mycc = cc . CCSD ( mf ) . run () print ( mycc . e_tot ) This can be simplified using"
  },
  {
    "name": "Class_and_function_behaviors",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Class_and_function_behaviors {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Classes are designed to hold only the final results (such as energies and wavefunction parameters)\nand the control parameters (such as the convergence threshold and the maximum number of iterations).\nIntermediate quantities are not saved in the class. After calling the kernel() or run() method, resu"
      }
    ],
    "parent_section": "using",
    "description": "Classes are designed to hold only the final results (such as energies and wavefunction parameters)\nand the control parameters (such as the convergence threshold and the maximum number of iterations).\nIntermediate quantities are not saved in the class. After calling the kernel() or run() method, results will be generated and\nsaved as attributes of the object.  For example, from pyscf import gto , scf , cc mol = gto . M ( atom = 'H 0 0 0; H 0 0 1.1' , basis = 'ccpvtz' ) mf = scf . RHF ( mol ) . run () mycc = cc . CCSD ( mf ) . run () print ( mycc . e_tot ) print ( mycc . e_corr ) print ( mycc . t1 . shape ) print ( mycc . t2 . shape ) Many useful functions are defined at both the class level (as methods) and\nthe module level. For example, myhf = scf . RHF ( mol ) vj , vk = myhf . get_jk ( mo"
  },
  {
    "name": "Global_configurations",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "Global_configurations {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Default behaviors in PySCF can be controlled by using global configurations.\nA global configuration file is a Python script that contains PySCF configurations.\nWhen PySCF is imported in a Python program (or Python interpreter), the\npackage will preload the global configuration file to set default va"
      }
    ],
    "parent_section": "using",
    "description": "Default behaviors in PySCF can be controlled by using global configurations.\nA global configuration file is a Python script that contains PySCF configurations.\nWhen PySCF is imported in a Python program (or Python interpreter), the\npackage will preload the global configuration file to set default values.\nFor example, the configuration file below detects the available memory in the\noperating system at runtime and sets the maximum memory for PySCF, ~/.pyscf_conf.py # import psutil MAX_MEMORY = int ( psutil . virtual_memory () . available / 1e6 ) By setting MAX_MEMORY in the global configuration file, you don’t need to set\nthe max_memory attribute in every script. The dynamically determined MAX_MEMORY will be loaded during the program initialization automatically. There are two ways to identi"
  },
  {
    "name": "This_Page",
    "software": "PySCF",
    "paradigm": "KEY_VALUE",
    "syntax_template": "This_Page {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Show Source"
      }
    ],
    "parent_section": "using",
    "description": "Show Source"
  }
]