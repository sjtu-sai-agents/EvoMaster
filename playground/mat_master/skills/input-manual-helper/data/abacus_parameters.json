[
  {
    "name": "suffix",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "suffix {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "ABACUS",
        "unit": null,
        "description": "In each run, ABACUS will generate a subdirectory in the working directory. This subdirectory contains all the information of the run. The subdirectory name has the format: OUT.suffix, where the suffix is the name you can pick up for your convenience."
      }
    ],
    "parent_section": null,
    "description": "In each run, ABACUS will generate a subdirectory in the working directory. This subdirectory contains all the information of the run. The subdirectory name has the format: OUT.suffix, where the suffix is the name you can pick up for your convenience."
  },
  {
    "name": "calculation",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "calculation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "scf",
        "unit": null,
        "description": "Specify the type of calculation. scf: perform self-consistent electronic structure calculations nscf: perform non-self-consistent electronic structure calculations. A charge density file is required relax: perform structure relaxation calculations, the relax_nmax parameter depicts the maximal number of ionic iterations cell-relax: perform cell relaxation calculations md: perform molecular dynamics simulations get_pchg: obtain partial (band-decomposed) charge densities (for LCAO basis only). See "
      }
    ],
    "parent_section": null,
    "description": "Specify the type of calculation. scf: perform self-consistent electronic structure calculations nscf: perform non-self-consistent electronic structure calculations. A charge density file is required relax: perform structure relaxation calculations, the relax_nmax parameter depicts the maximal number of ionic iterations cell-relax: perform cell relaxation calculations md: perform molecular dynamics simulations get_pchg: obtain partial (band-decomposed) charge densities (for LCAO basis only). See "
  },
  {
    "name": "esolver_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "esolver_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "ksdft",
        "unit": null,
        "description": "choose the energy solver. ksdft: Kohn-Sham density functional theory ofdft: orbital-free density functional theory tdofdft: time-dependent orbital-free density functional theory sdft: stochastic density functional theory tddft: real-time time-dependent density functional theory (RT-TDDFT) lj: Leonard Jones potential dp: DeeP potential, see details in md.md nep: Neuroevolution Potential, see details in md.md ks-lr: Kohn-Sham density functional theory + LR-TDDFT (Under Development Feature) lr: LR-"
      }
    ],
    "parent_section": null,
    "description": "choose the energy solver. ksdft: Kohn-Sham density functional theory ofdft: orbital-free density functional theory tdofdft: time-dependent orbital-free density functional theory sdft: stochastic density functional theory tddft: real-time time-dependent density functional theory (RT-TDDFT) lj: Leonard Jones potential dp: DeeP potential, see details in md.md nep: Neuroevolution Potential, see details in md.md ks-lr: Kohn-Sham density functional theory + LR-TDDFT (Under Development Feature) lr: LR-"
  },
  {
    "name": "symmetry",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "symmetry {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0: if calculation ==md/nscf/get_pchg/get_wf/get_s or gamma_only ==True; If ( dft_fuctional ==hse/hf/pbe0/scan0 or rpa ==True). If efield_flag ==1 1: else",
        "unit": null,
        "description": "takes value 1, 0 or -1. -1: No symmetry will be considered. It is recommended to set -1 for non-colinear + soc calculations, where time reversal symmetry is broken sometimes. 0: Only time reversal symmetry would be considered in symmetry operations, which implied k point and -k point would be treated as a single k point with twice the weight. 1: Symmetry analysis will be performed to determine the type of Bravais lattice and associated symmetry operations. (point groups, space groups, primitive "
      }
    ],
    "parent_section": null,
    "description": "takes value 1, 0 or -1. -1: No symmetry will be considered. It is recommended to set -1 for non-colinear + soc calculations, where time reversal symmetry is broken sometimes. 0: Only time reversal symmetry would be considered in symmetry operations, which implied k point and -k point would be treated as a single k point with twice the weight. 1: Symmetry analysis will be performed to determine the type of Bravais lattice and associated symmetry operations. (point groups, space groups, primitive "
  },
  {
    "name": "symmetry_prec",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "symmetry_prec {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0e-6",
        "unit": null,
        "description": "The accuracy for symmetry analysis. Typically, the default value is good enough, but if the lattice parameters or atom positions in STRU file are not accurate enough, this value should be enlarged. Note: if calculation ==cell_relax , this value can be dynamically changed corresponding to the variation of accuracy of the lattice parameters and atom positions during the relaxation. The new value will be printed in OUT.${suffix}/running_cell-relax.log in that case."
      }
    ],
    "parent_section": null,
    "description": "The accuracy for symmetry analysis. Typically, the default value is good enough, but if the lattice parameters or atom positions in STRU file are not accurate enough, this value should be enlarged. Note: if calculation ==cell_relax , this value can be dynamically changed corresponding to the variation of accuracy of the lattice parameters and atom positions during the relaxation. The new value will be printed in OUT.${suffix}/running_cell-relax.log in that case."
  },
  {
    "name": "symmetry_autoclose",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "symmetry_autoclose {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Control how to deal with error in symmetry analysis due to inaccurate lattice parameters or atom positions in STRU file, especially useful when calculation ==cell-relax False: quit with an error message True: automatically set symmetry to 0 and continue running without symmetry analysis"
      }
    ],
    "parent_section": null,
    "description": "Control how to deal with error in symmetry analysis due to inaccurate lattice parameters or atom positions in STRU file, especially useful when calculation ==cell-relax False: quit with an error message True: automatically set symmetry to 0 and continue running without symmetry analysis"
  },
  {
    "name": "cal_symm_repr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cal_symm_repr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1 3",
        "unit": null,
        "description": "Whether to print the matrix representation of symmetry operation to running log file. If the first value is given as 1, then all matrix representations will be printed. The second optional parameter controls the precision (number of digits) to print, default is 3, which is enough for a quick check."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the matrix representation of symmetry operation to running log file. If the first value is given as 1, then all matrix representations will be printed. The second optional parameter controls the precision (number of digits) to print, default is 3, which is enough for a quick check."
  },
  {
    "name": "kpar",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "kpar {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Divide all processors into kpar groups, and k points will be distributed among each group. The value taken should be less than or equal to the number of k points as well as the number of MPI processes."
      }
    ],
    "parent_section": null,
    "description": "Divide all processors into kpar groups, and k points will be distributed among each group. The value taken should be less than or equal to the number of k points as well as the number of MPI processes."
  },
  {
    "name": "bndpar",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bndpar {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Divide all processors into bndpar groups, and bands (only stochastic orbitals now) will be distributed among each group. It should be larger than 0."
      }
    ],
    "parent_section": null,
    "description": "Divide all processors into bndpar groups, and bands (only stochastic orbitals now) will be distributed among each group. It should be larger than 0."
  },
  {
    "name": "latname",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "latname {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Specifies the type of Bravias lattice. When set to none , the three lattice vectors are supplied explicitly in STRU file. When set to a certain Bravais lattice type, there is no need to provide lattice vector, but a few lattice parameters might be required. For more information regarding this parameter, consult the page on STRU file . Available options are: none: free structure sc: simple cubic fcc: face-centered cubic bcc: body-centered cubic hexagonal: hexagonal trigonal: trigonal st: simple t"
      }
    ],
    "parent_section": null,
    "description": "Specifies the type of Bravias lattice. When set to none , the three lattice vectors are supplied explicitly in STRU file. When set to a certain Bravais lattice type, there is no need to provide lattice vector, but a few lattice parameters might be required. For more information regarding this parameter, consult the page on STRU file . Available options are: none: free structure sc: simple cubic fcc: face-centered cubic bcc: body-centered cubic hexagonal: hexagonal trigonal: trigonal st: simple t"
  },
  {
    "name": "init_wfc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "init_wfc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "atomic",
        "unit": null,
        "description": "The type of the starting wave functions. Available options are: atomic: from atomic pseudo wave functions. If they are not enough, other wave functions are initialized with random numbers. atomic+random: add small random numbers on atomic pseudo-wavefunctions file: from binary files wf*.dat , which are output by setting out_wfc_pw to 2 . random: random numbers nao: from numerical atomic orbitals. If they are not enough, other wave functions are initialized with random numbers. nao+random: add sm"
      }
    ],
    "parent_section": null,
    "description": "The type of the starting wave functions. Available options are: atomic: from atomic pseudo wave functions. If they are not enough, other wave functions are initialized with random numbers. atomic+random: add small random numbers on atomic pseudo-wavefunctions file: from binary files wf*.dat , which are output by setting out_wfc_pw to 2 . random: random numbers nao: from numerical atomic orbitals. If they are not enough, other wave functions are initialized with random numbers. nao+random: add sm"
  },
  {
    "name": "init_chg",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "init_chg {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "atomic",
        "unit": null,
        "description": "This variable is used for both plane wave set and localized orbitals set. It indicates the type of starting density. atomic: the density is starting from the summation of the atomic density of single atoms. file: the density will be read in from a binary file charge-density.dat first. If it does not exist, the charge density will be read in from cube files. Besides, when you do nspin=1 calculation, you only need the density file chgs1.cube. However, if you do nspin=2 calculation, you also need t"
      }
    ],
    "parent_section": null,
    "description": "This variable is used for both plane wave set and localized orbitals set. It indicates the type of starting density. atomic: the density is starting from the summation of the atomic density of single atoms. file: the density will be read in from a binary file charge-density.dat first. If it does not exist, the charge density will be read in from cube files. Besides, when you do nspin=1 calculation, you only need the density file chgs1.cube. However, if you do nspin=2 calculation, you also need t"
  },
  {
    "name": "init_vel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "init_vel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: read the atom velocity (atomic unit : 1 a.u. = 21.877 Angstrom/fs) from the atom file ( STRU ) and determine the initial temperature md_tfirst . If md_tfirst is unset or less than zero, init_vel is autoset to be true . False: assign value to atom velocity using Gaussian distributed random numbers."
      }
    ],
    "parent_section": null,
    "description": "True: read the atom velocity (atomic unit : 1 a.u. = 21.877 Angstrom/fs) from the atom file ( STRU ) and determine the initial temperature md_tfirst . If md_tfirst is unset or less than zero, init_vel is autoset to be true . False: assign value to atom velocity using Gaussian distributed random numbers."
  },
  {
    "name": "mem_saver",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mem_saver {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "0",
        "unit": null,
        "description": "Save memory when performing nscf calculations. 0: no memory saving techniques are used. 1: a memory saving technique will be used for many k point calculations."
      }
    ],
    "parent_section": null,
    "description": "Save memory when performing nscf calculations. 0: no memory saving techniques are used. 1: a memory saving technique will be used for many k point calculations."
  },
  {
    "name": "diago_proc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "diago_proc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "0: it will be set to the number of MPI processes. Normally, it is fine just leave it to the default value. >0 : it specifies the number of processes used for carrying out diagonalization. Must be less than or equal to total number of MPI processes. Also, when cg diagonalization is used, diago_proc must be the same as the total number of MPI processes."
      }
    ],
    "parent_section": null,
    "description": "0: it will be set to the number of MPI processes. Normally, it is fine just leave it to the default value. >0 : it specifies the number of processes used for carrying out diagonalization. Must be less than or equal to total number of MPI processes. Also, when cg diagonalization is used, diago_proc must be the same as the total number of MPI processes."
  },
  {
    "name": "nbspline",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nbspline {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1",
        "unit": null,
        "description": "If set to a natural number, a Cardinal B-spline interpolation will be used to calculate Structure Factor. nbspline represents the order of B-spline basis and a larger one can get more accurate results but cost more. It is turned off by default."
      }
    ],
    "parent_section": null,
    "description": "If set to a natural number, a Cardinal B-spline interpolation will be used to calculate Structure Factor. nbspline represents the order of B-spline basis and a larger one can get more accurate results but cost more. It is turned off by default."
  },
  {
    "name": "kspacing",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "kspacing {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Set the smallest allowed spacing between k points, unit in 1/bohr. It should be larger than 0.0, and suggest smaller than 0.25. When you have set this value > 0.0, then the KPT file is unnecessary, and the number of K points nk_i = max(1, int(|b_i|/KSPACING_i)+1), where b_i is the reciprocal lattice vector. The default value 0.0 means that ABACUS will read the applied KPT file. If only one value is set (such as kspacing 0.5 ), then kspacing values of a/b/c direction are all set to it; and one ca"
      }
    ],
    "parent_section": null,
    "description": "Set the smallest allowed spacing between k points, unit in 1/bohr. It should be larger than 0.0, and suggest smaller than 0.25. When you have set this value > 0.0, then the KPT file is unnecessary, and the number of K points nk_i = max(1, int(|b_i|/KSPACING_i)+1), where b_i is the reciprocal lattice vector. The default value 0.0 means that ABACUS will read the applied KPT file. If only one value is set (such as kspacing 0.5 ), then kspacing values of a/b/c direction are all set to it; and one ca"
  },
  {
    "name": "min_dist_coef",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "min_dist_coef {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.2",
        "unit": null,
        "description": "A factor related to the allowed minimum distance between two atoms. At the beginning, ABACUS will check the structure, and if the distance of two atoms is shorter than min_dist_coef*(standard covalent bond length), we think this structure is unreasonable. If you want to calculate some structures in extreme conditions like high pressure, you should set this parameter as a smaller value or even 0."
      }
    ],
    "parent_section": null,
    "description": "A factor related to the allowed minimum distance between two atoms. At the beginning, ABACUS will check the structure, and if the distance of two atoms is shorter than min_dist_coef*(standard covalent bond length), we think this structure is unreasonable. If you want to calculate some structures in extreme conditions like high pressure, you should set this parameter as a smaller value or even 0."
  },
  {
    "name": "device",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "device {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "cpu",
        "unit": null,
        "description": "Specifies the computing device for ABACUS. Available options are: cpu: for CPUs via Intel, AMD, or Other supported CPU devices gpu: for GPUs via CUDA or ROCm. Known limitations: ks_solver must also be set to the algorithms supported. lcao_in_pw currently does not support gpu ."
      }
    ],
    "parent_section": null,
    "description": "Specifies the computing device for ABACUS. Available options are: cpu: for CPUs via Intel, AMD, or Other supported CPU devices gpu: for GPUs via CUDA or ROCm. Known limitations: ks_solver must also be set to the algorithms supported. lcao_in_pw currently does not support gpu ."
  },
  {
    "name": "precision",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "precision {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "double",
        "unit": null,
        "description": "Specifies the precision when performing scf calculation. single: single precision double: double precision"
      }
    ],
    "parent_section": null,
    "description": "Specifies the precision when performing scf calculation. single: single precision double: double precision"
  },
  {
    "name": "timer_enable_nvtx",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "timer_enable_nvtx {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Controls whether NVTX profiling labels are emitted by the timer. This feature is only effective on CUDA platforms. True: Enable NVTX profiling labels in the timer. False: Disable NVTX profiling labels in the timer."
      }
    ],
    "parent_section": null,
    "description": "Controls whether NVTX profiling labels are emitted by the timer. This feature is only effective on CUDA platforms. True: Enable NVTX profiling labels in the timer. False: Disable NVTX profiling labels in the timer."
  },
  {
    "name": "nb2d",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nb2d {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "When using elpa or scalapack to solver the eigenvalue problem, the data should be distributed by the two-dimensional block-cyclic distribution. This paramter specifies the size of the block. It is valid for: ks_solver is genelpa or scalapack_gvx. If nb2d is set to 0, then it will be automatically set in the program according to the size of atomic orbital basis: if size <= 500: nb2d = 1 if 500 < size <= 1000: nb2d = 32 if size > 1000: nb2d = 64; ks_solver is dav_subspace, and diag_subspace is 1 o"
      }
    ],
    "parent_section": null,
    "description": "When using elpa or scalapack to solver the eigenvalue problem, the data should be distributed by the two-dimensional block-cyclic distribution. This paramter specifies the size of the block. It is valid for: ks_solver is genelpa or scalapack_gvx. If nb2d is set to 0, then it will be automatically set in the program according to the size of atomic orbital basis: if size <= 500: nb2d = 1 if 500 < size <= 1000: nb2d = 32 if size > 1000: nb2d = 64; ks_solver is dav_subspace, and diag_subspace is 1 o"
  },
  {
    "name": "stru_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "stru_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "STRU",
        "unit": null,
        "description": "The name of the structure file. Containing various information about atom species, including pseudopotential files, local orbitals files, cell information, atom positions, and whether atoms should be allowed to move. When calculation is set to md and md_restart is set to true , this keyword will NOT work. Refer to Doc"
      }
    ],
    "parent_section": null,
    "description": "The name of the structure file. Containing various information about atom species, including pseudopotential files, local orbitals files, cell information, atom positions, and whether atoms should be allowed to move. When calculation is set to md and md_restart is set to true , this keyword will NOT work. Refer to Doc"
  },
  {
    "name": "kpoint_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "kpoint_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "KPT",
        "unit": null,
        "description": "The name of the k-point file that includes the k-point information of Brillouin zone. In atomic orbitals basis with gamma_only set to true, the KPT file is unnecessary, because a KPT file will be generated automatically. When more than one k-points are required, an explicit KPT file is mandatory. Refer to Doc"
      }
    ],
    "parent_section": null,
    "description": "The name of the k-point file that includes the k-point information of Brillouin zone. In atomic orbitals basis with gamma_only set to true, the KPT file is unnecessary, because a KPT file will be generated automatically. When more than one k-points are required, an explicit KPT file is mandatory. Refer to Doc"
  },
  {
    "name": "pseudo_dir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pseudo_dir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "“”",
        "unit": null,
        "description": "The direcotyr of pseudopotential files. This parameter is combined with the pseudopotential filenames in the STRU file to form the complete pseudopotential file paths. Example: set pseudo_dir to “…/” with “Si.upf” which specified under “ATOMIC_SPECIES” in STRU file, ABACUS will open the pseudopotential file in path “…/Si.upf”."
      }
    ],
    "parent_section": null,
    "description": "The direcotyr of pseudopotential files. This parameter is combined with the pseudopotential filenames in the STRU file to form the complete pseudopotential file paths. Example: set pseudo_dir to “…/” with “Si.upf” which specified under “ATOMIC_SPECIES” in STRU file, ABACUS will open the pseudopotential file in path “…/Si.upf”."
  },
  {
    "name": "orbital_dir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "orbital_dir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "“”",
        "unit": null,
        "description": "The directory to save numerical atomic orbitals. This parameter is combined with orbital filenames in the STRU file to form the complete orbital file paths. Example: set orbital_dir to “…/” with “Si.orb” which specified under “NUMERICAL_ORBITAL” in STRU file, ABACUS will open the orbital file in path “…/Si.orb”."
      }
    ],
    "parent_section": null,
    "description": "The directory to save numerical atomic orbitals. This parameter is combined with orbital filenames in the STRU file to form the complete orbital file paths. Example: set orbital_dir to “…/” with “Si.orb” which specified under “NUMERICAL_ORBITAL” in STRU file, ABACUS will open the orbital file in path “…/Si.orb”."
  },
  {
    "name": "read_file_dir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "read_file_dir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "OUT.$suffix",
        "unit": null,
        "description": "Location of files, such as the electron density ( chgs1.cube ), required as a starting point. Example: ‘./’ implies the files to be read are located in the working directory."
      }
    ],
    "parent_section": null,
    "description": "Location of files, such as the electron density ( chgs1.cube ), required as a starting point. Example: ‘./’ implies the files to be read are located in the working directory."
  },
  {
    "name": "restart_load",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "restart_load {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "If restart_save is set to true and an electronic iteration is finished, calculations can be restarted from the charge density file, which are saved in the former calculation. Please ensure read_file_dir is correct, and the charge density file exist. If EXX(exact exchange) is calculated (i.e. dft_fuctional ==hse/hf/pbe0/scan0 or rpa ==True ), the Hexx® files in the same folder for each processor will also be read."
      }
    ],
    "parent_section": null,
    "description": "If restart_save is set to true and an electronic iteration is finished, calculations can be restarted from the charge density file, which are saved in the former calculation. Please ensure read_file_dir is correct, and the charge density file exist. If EXX(exact exchange) is calculated (i.e. dft_fuctional ==hse/hf/pbe0/scan0 or rpa ==True ), the Hexx® files in the same folder for each processor will also be read."
  },
  {
    "name": "spillage_outdir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "spillage_outdir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "“./”",
        "unit": null,
        "description": "The directory to save the spillage files."
      }
    ],
    "parent_section": null,
    "description": "The directory to save the spillage files."
  },
  {
    "name": "ecutwfc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ecutwfc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "Energy cutoff for plane wave functions. Note that even for localized orbitals basis, you still need to setup an energy cutoff for this system. Because our local pseudopotential parts and the related force are calculated from plane wave basis set, etc. Also, because our orbitals are generated by matching localized orbitals to a chosen set of wave functions from a certain energy cutoff, this set of localize orbitals is most accurate under this same plane wave energy cutoff."
      }
    ],
    "parent_section": null,
    "description": "Energy cutoff for plane wave functions. Note that even for localized orbitals basis, you still need to setup an energy cutoff for this system. Because our local pseudopotential parts and the related force are calculated from plane wave basis set, etc. Also, because our orbitals are generated by matching localized orbitals to a chosen set of wave functions from a certain energy cutoff, this set of localize orbitals is most accurate under this same plane wave energy cutoff."
  },
  {
    "name": "ecutrho",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ecutrho {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "4*ecutwfc",
        "unit": null,
        "description": "Energy cutoff for charge density and potential. For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. For ultrasoft pseudopotential a larger value than the default is often desirable ( ecutrho = 8 to 12 times ecutwfc , typically). The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an hig"
      }
    ],
    "parent_section": null,
    "description": "Energy cutoff for charge density and potential. For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. For ultrasoft pseudopotential a larger value than the default is often desirable ( ecutrho = 8 to 12 times ecutwfc , typically). The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an hig"
  },
  {
    "name": "nx",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nx {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
  },
  {
    "name": "ny",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ny {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
  },
  {
    "name": "nz",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nz {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho."
  },
  {
    "name": "ndx",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ndx {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
  },
  {
    "name": "ndy",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ndy {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
  },
  {
    "name": "ndz",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ndz {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
      }
    ],
    "parent_section": null,
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc. Note: You must specify all three dimensions for this setting to be used. Note: These parameters must be used combined with nx,ny,nz . If nx,ny,nz are unset, ndx,ndy,ndz are used as nx,ny,nz ."
  },
  {
    "name": "pw_seed",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pw_seed {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Specify the random seed to initialize wave functions. Only positive integers are available."
      }
    ],
    "parent_section": null,
    "description": "Specify the random seed to initialize wave functions. Only positive integers are available."
  },
  {
    "name": "pw_diag_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pw_diag_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "Only used when you use ks_solver = cg/dav/dav_subspace/bpcg . It indicates the threshold for the first electronic iteration, from the second iteration the pw_diag_thr will be updated automatically. For nscf calculations with planewave basis set, pw_diag_thr should be <= 1e-3."
      }
    ],
    "parent_section": null,
    "description": "Only used when you use ks_solver = cg/dav/dav_subspace/bpcg . It indicates the threshold for the first electronic iteration, from the second iteration the pw_diag_thr will be updated automatically. For nscf calculations with planewave basis set, pw_diag_thr should be <= 1e-3."
  },
  {
    "name": "diago_smooth_ethr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "diago_smooth_ethr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "If TRUE , the smooth threshold strategy, which applies a larger threshold (10e-5) for the empty states, will be implemented in the diagonalization methods. (This strategy should not affect total energy, forces, and other ground-state properties, but computational efficiency will be improved.) If FALSE , the smooth threshold strategy will not be applied."
      }
    ],
    "parent_section": null,
    "description": "If TRUE , the smooth threshold strategy, which applies a larger threshold (10e-5) for the empty states, will be implemented in the diagonalization methods. (This strategy should not affect total energy, forces, and other ground-state properties, but computational efficiency will be improved.) If FALSE , the smooth threshold strategy will not be applied."
  },
  {
    "name": "use_k_continuity",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "use_k_continuity {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Whether to use k-point continuity for initializing wave functions. When enabled, this strategy exploits the similarity between wavefunctions at neighboring k-points by propagating the wavefunction from a previously initialized k-point to a new k-point, significantly reducing the computational cost of the initial guess. Important constraints: Must be used together with diago_smooth_ethr = 1 for optimal performance This feature is particularly useful for calculations with dense k-point sampling wh"
      }
    ],
    "parent_section": null,
    "description": "Whether to use k-point continuity for initializing wave functions. When enabled, this strategy exploits the similarity between wavefunctions at neighboring k-points by propagating the wavefunction from a previously initialized k-point to a new k-point, significantly reducing the computational cost of the initial guess. Important constraints: Must be used together with diago_smooth_ethr = 1 for optimal performance This feature is particularly useful for calculations with dense k-point sampling wh"
  },
  {
    "name": "pw_diag_nmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pw_diag_nmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "40",
        "unit": null,
        "description": "Only useful when you use ks_solver = cg/dav/dav_subspace/bpcg . It indicates the maximal iteration number for cg/david/dav_subspace/bpcg method."
      }
    ],
    "parent_section": null,
    "description": "Only useful when you use ks_solver = cg/dav/dav_subspace/bpcg . It indicates the maximal iteration number for cg/david/dav_subspace/bpcg method."
  },
  {
    "name": "pw_diag_ndim",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pw_diag_ndim {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "4",
        "unit": null,
        "description": "Only useful when you use ks_solver = dav or ks_solver = dav_subspace . It indicates dimension of workspace(number of wavefunction packets, at least 2 needed) for the Davidson method. A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization."
      }
    ],
    "parent_section": null,
    "description": "Only useful when you use ks_solver = dav or ks_solver = dav_subspace . It indicates dimension of workspace(number of wavefunction packets, at least 2 needed) for the Davidson method. A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization."
  },
  {
    "name": "diag_subspace",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "diag_subspace {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "The method to diagonalize subspace in dav_subspace method. The available options are: 0: by LAPACK 1: by GenELPA 2: by ScaLAPACK LAPACK only solve in one core, GenELPA and ScaLAPACK can solve in parallel. If the system is small (such as the band number is less than 100), LAPACK is recommended. If the system is large and MPI parallel is used, then GenELPA or ScaLAPACK is recommended, and GenELPA usually has better performance. For GenELPA and ScaLAPACK, the block size can be set by nb2d ."
      }
    ],
    "parent_section": null,
    "description": "The method to diagonalize subspace in dav_subspace method. The available options are: 0: by LAPACK 1: by GenELPA 2: by ScaLAPACK LAPACK only solve in one core, GenELPA and ScaLAPACK can solve in parallel. If the system is small (such as the band number is less than 100), LAPACK is recommended. If the system is large and MPI parallel is used, then GenELPA or ScaLAPACK is recommended, and GenELPA usually has better performance. For GenELPA and ScaLAPACK, the block size can be set by nb2d ."
  },
  {
    "name": "erf_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "erf_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Used in variable-cell molecular dynamics (or in stress calculation). See erf_sigma in detail."
      }
    ],
    "parent_section": null,
    "description": "Used in variable-cell molecular dynamics (or in stress calculation). See erf_sigma in detail."
  },
  {
    "name": "fft_mode",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "fft_mode {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Set the mode of FFTW. 0: FFTW_ESTIMATE 1: FFTW_MEASURE 2: FFTW_PATIENT 3: FFTW_EXHAUSTIVE"
      }
    ],
    "parent_section": null,
    "description": "Set the mode of FFTW. 0: FFTW_ESTIMATE 1: FFTW_MEASURE 2: FFTW_PATIENT 3: FFTW_EXHAUSTIVE"
  },
  {
    "name": "erf_height",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "erf_height {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Used in variable-cell molecular dynamics (or in stress calculation). See erf_sigma in detail."
      }
    ],
    "parent_section": null,
    "description": "Used in variable-cell molecular dynamics (or in stress calculation). See erf_sigma in detail."
  },
  {
    "name": "erf_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "erf_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "In order to recover the accuracy of a constant energy cutoff calculation, the kinetic functional is modified, which is used in variable-cell molecular dynamics (or in stress calculation). erf_ecut is the value of the constant energy cutoff; erf_height and erf_sigma are the height and the width of the energy step for reciprocal vectors whose square modulus is greater than erf_ecut . In the kinetic energy, G^2 is replaced by G^2 + erf_height * (1 + erf ( (G^2 - erf_ecut)/erf_sigma) ) See: M. Berna"
      }
    ],
    "parent_section": null,
    "description": "In order to recover the accuracy of a constant energy cutoff calculation, the kinetic functional is modified, which is used in variable-cell molecular dynamics (or in stress calculation). erf_ecut is the value of the constant energy cutoff; erf_height and erf_sigma are the height and the width of the energy step for reciprocal vectors whose square modulus is greater than erf_ecut . In the kinetic energy, G^2 is replaced by G^2 + erf_height * (1 + erf ( (G^2 - erf_ecut)/erf_sigma) ) See: M. Berna"
  },
  {
    "name": "lmaxmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lmaxmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2.",
        "unit": null,
        "description": "If not equals to 2, then the maximum l channels on LCAO is set to lmaxmax. If 2, then the number of l channels will be read from the LCAO data sets. Normally no input should be supplied for this variable so that it is kept as its default."
      }
    ],
    "parent_section": null,
    "description": "If not equals to 2, then the maximum l channels on LCAO is set to lmaxmax. If 2, then the number of l channels will be read from the LCAO data sets. Normally no input should be supplied for this variable so that it is kept as its default."
  },
  {
    "name": "lcao_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lcao_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "ecutwfc",
        "unit": null,
        "description": "Energy cutoff (in Ry) for two-center integrals in LCAO. The two-center integration table are obtained via a k space integral whose upper limit is about sqrt( lcao_ecut )."
      }
    ],
    "parent_section": null,
    "description": "Energy cutoff (in Ry) for two-center integrals in LCAO. The two-center integration table are obtained via a k space integral whose upper limit is about sqrt( lcao_ecut )."
  },
  {
    "name": "lcao_dk",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lcao_dk {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "the interval of k points for two-center integrals. The two-center integration table are obtained via a k space integral on a uniform grid with spacing lcao_dk ."
      }
    ],
    "parent_section": null,
    "description": "the interval of k points for two-center integrals. The two-center integration table are obtained via a k space integral on a uniform grid with spacing lcao_dk ."
  },
  {
    "name": "lcao_dr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lcao_dr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "r spacing of the integration table of two-center integrals."
      }
    ],
    "parent_section": null,
    "description": "r spacing of the integration table of two-center integrals."
  },
  {
    "name": "lcao_rmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lcao_rmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "30",
        "unit": null,
        "description": "Maximum distance for the two-center integration table."
      }
    ],
    "parent_section": null,
    "description": "Maximum distance for the two-center integration table."
  },
  {
    "name": "search_radius",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "search_radius {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1",
        "unit": null,
        "description": "Searching radius in finding the neighbouring atoms. By default the radius will be automatically determined by the cutoffs of orbitals and nonlocal beta projectors."
      }
    ],
    "parent_section": null,
    "description": "Searching radius in finding the neighbouring atoms. By default the radius will be automatically determined by the cutoffs of orbitals and nonlocal beta projectors."
  },
  {
    "name": "bx",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bx {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
      }
    ],
    "parent_section": null,
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
  },
  {
    "name": "by",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "by {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
      }
    ],
    "parent_section": null,
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
  },
  {
    "name": "bz",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bz {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
      }
    ],
    "parent_section": null,
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values."
  },
  {
    "name": "elpa_num_thread",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "elpa_num_thread {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1",
        "unit": null,
        "description": "Number of threads used in one elpa calculation. If the number is below 0 or 0 or beyond the max number of threads, all elpa calculation will be using all mpi threads"
      }
    ],
    "parent_section": null,
    "description": "Number of threads used in one elpa calculation. If the number is below 0 or 0 or beyond the max number of threads, all elpa calculation will be using all mpi threads"
  },
  {
    "name": "num_stream",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "num_stream {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "“4”",
        "unit": null,
        "description": "The number of streams used in GPU calculations (only for LCAO). For most devices, the performance is satisfactory when the number is larger than 2."
      }
    ],
    "parent_section": null,
    "description": "The number of streams used in GPU calculations (only for LCAO). For most devices, the performance is satisfactory when the number is larger than 2."
  },
  {
    "name": "basis_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "basis_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "pw",
        "unit": null,
        "description": "Choose the basis set. pw: Using plane-wave basis set only. lcao: Using localized atomic orbital sets. lcao_in_pw: Expand the localized atomic set in plane-wave basis, non-self-consistent field calculation not tested."
      }
    ],
    "parent_section": null,
    "description": "Choose the basis set. pw: Using plane-wave basis set only. lcao: Using localized atomic orbital sets. lcao_in_pw: Expand the localized atomic set in plane-wave basis, non-self-consistent field calculation not tested."
  },
  {
    "name": "ks_solver",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ks_solver {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "PW basis: cg. LCAO basis: genelpa (if compiling option USE_ELPA has been set) lapack (if compiling option ENABLE_MPI has not been set) scalapack_gvx (if compiling option USE_ELPA has not been set and compiling option ENABLE_MPI has been set) cusolver (if compiling option USE_CUDA has been set)",
        "unit": null,
        "description": "Choose the diagonalization methods for the Hamiltonian matrix expanded in a certain basis set. For plane-wave basis, cg: The conjugate-gradient (CG) method. bpcg: The BPCG method, which is a block-parallel Conjugate Gradient (CG) method, typically exhibits higher acceleration in a GPU environment. dav: The Davidson algorithm. dav_subspace: The Davidson algorithm without orthogonalization operation, this method is the most recommended for efficiency. pw_diag_ndim can be set to 2 for this method. "
      }
    ],
    "parent_section": null,
    "description": "Choose the diagonalization methods for the Hamiltonian matrix expanded in a certain basis set. For plane-wave basis, cg: The conjugate-gradient (CG) method. bpcg: The BPCG method, which is a block-parallel Conjugate Gradient (CG) method, typically exhibits higher acceleration in a GPU environment. dav: The Davidson algorithm. dav_subspace: The Davidson algorithm without orthogonalization operation, this method is the most recommended for efficiency. pw_diag_ndim can be set to 2 for this method. "
  },
  {
    "name": "nbands",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nbands {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "nspin=1: max(1.2*occupied_bands, occupied_bands + 10) nspin=2: max(1.2*nelec_spin, nelec_spin + 10), in which nelec_spin = max(nelec_spin_up, nelec_spin_down) nspin=4: max(1.2*nelec, nelec + 20)",
        "unit": null,
        "description": "The number of Kohn-Sham orbitals to calculate. It is recommended to setup this value, especially when smearing techniques are utilized, more bands should be included."
      }
    ],
    "parent_section": null,
    "description": "The number of Kohn-Sham orbitals to calculate. It is recommended to setup this value, especially when smearing techniques are utilized, more bands should be included."
  },
  {
    "name": "nelec",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nelec {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "0.0: The total number of electrons will be calculated by the sum of valence electrons (i.e. assuming neutral system). >0.0 : this denotes the total number of electrons in the system. Must be less than 2*nbands."
      }
    ],
    "parent_section": null,
    "description": "0.0: The total number of electrons will be calculated by the sum of valence electrons (i.e. assuming neutral system). >0.0 : this denotes the total number of electrons in the system. Must be less than 2*nbands."
  },
  {
    "name": "nelec_delta",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nelec_delta {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "The total number of electrons will be calculated by nelec + nelec_delta ."
      }
    ],
    "parent_section": null,
    "description": "The total number of electrons will be calculated by nelec + nelec_delta ."
  },
  {
    "name": "nupdown",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nupdown {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "0.0: no constrain apply to system. >0.0 : The different number of electrons between spin-up and spin-down channels. The range of value must be in [-nelec ~ nelec]. It is one type of constrainted DFT method, two Fermi energies will be calculated."
      }
    ],
    "parent_section": null,
    "description": "0.0: no constrain apply to system. >0.0 : The different number of electrons between spin-up and spin-down channels. The range of value must be in [-nelec ~ nelec]. It is one type of constrainted DFT method, two Fermi energies will be calculated."
  },
  {
    "name": "dft_functional",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dft_functional {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "Used the same as DFT functional as specified in the pseudopotential files.",
        "unit": null,
        "description": "In our package, the XC functional can either be set explicitly using the dft_functional keyword in INPUT file. If dft_functional is not specified, ABACUS will use the xc functional indicated in the pseudopotential file. On the other hand, if dft_functional is specified, it will overwrite the functional from pseudopotentials and performs calculation with whichever functional the user prefers. We further offer two ways of supplying exchange-correlation functional. The first is using ‘short-hand’ n"
      }
    ],
    "parent_section": null,
    "description": "In our package, the XC functional can either be set explicitly using the dft_functional keyword in INPUT file. If dft_functional is not specified, ABACUS will use the xc functional indicated in the pseudopotential file. On the other hand, if dft_functional is specified, it will overwrite the functional from pseudopotentials and performs calculation with whichever functional the user prefers. We further offer two ways of supplying exchange-correlation functional. The first is using ‘short-hand’ n"
  },
  {
    "name": "xc_temperature",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "xc_temperature {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Specifies temperature when using temperature-dependent XC functionals (KSDT and so on)."
      }
    ],
    "parent_section": null,
    "description": "Specifies temperature when using temperature-dependent XC functionals (KSDT and so on)."
  },
  {
    "name": "xc_exch_ext",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "xc_exch_ext {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "101 0.8040 0.2195149727645171",
        "unit": null,
        "description": "Customized parameterization on the exchange part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to LibXC . For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: gga_x_pbe.c ."
      }
    ],
    "parent_section": null,
    "description": "Customized parameterization on the exchange part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to LibXC . For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: gga_x_pbe.c ."
  },
  {
    "name": "xc_corr_ext",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "xc_corr_ext {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "130 0.06672455060314922 0.031090690869654895034 1.0",
        "unit": null,
        "description": "Customized parameterization on the correlation part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to LibXC . For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: gga_c_pbe.c ."
      }
    ],
    "parent_section": null,
    "description": "Customized parameterization on the correlation part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to LibXC . For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: gga_c_pbe.c ."
  },
  {
    "name": "pseudo_rcut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pseudo_rcut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "15",
        "unit": null,
        "description": "Cut-off of radial integration for pseudopotentials."
      }
    ],
    "parent_section": null,
    "description": "Cut-off of radial integration for pseudopotentials."
  },
  {
    "name": "pseudo_mesh",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pseudo_mesh {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "0: Use a mesh for radial integration of pseudopotentials. 1: Use the mesh that is consistent with quantum espresso"
      }
    ],
    "parent_section": null,
    "description": "0: Use a mesh for radial integration of pseudopotentials. 1: Use the mesh that is consistent with quantum espresso"
  },
  {
    "name": "nspin",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nspin {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The number of spin components of wave functions. 1: Spin degeneracy 2: Collinear spin polarized. 4: For the case of noncollinear polarized , nspin will be automatically set to 4 without being specified by the user."
      }
    ],
    "parent_section": null,
    "description": "The number of spin components of wave functions. 1: Spin degeneracy 2: Collinear spin polarized. 4: For the case of noncollinear polarized , nspin will be automatically set to 4 without being specified by the user."
  },
  {
    "name": "smearing_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "smearing_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "gauss",
        "unit": null,
        "description": "It indicates which occupation and smearing method is used in the calculation. fixed: fixed occupations (available for non-coductors only) gauss or gaussian: Gaussian smearing method. mp: methfessel-paxton smearing method; recommended for metals. mp2: 2-nd methfessel-paxton smearing method; recommended for metals. mv or cold: marzari-vanderbilt smearing method. fd: Fermi-Dirac smearing method: \\(f=1/\\{1+\\exp[(E-\\mu)/kT]\\}\\) and smearing_sigma below is the temperature \\(T\\) (in Ry)."
      }
    ],
    "parent_section": null,
    "description": "It indicates which occupation and smearing method is used in the calculation. fixed: fixed occupations (available for non-coductors only) gauss or gaussian: Gaussian smearing method. mp: methfessel-paxton smearing method; recommended for metals. mp2: 2-nd methfessel-paxton smearing method; recommended for metals. mv or cold: marzari-vanderbilt smearing method. fd: Fermi-Dirac smearing method: \\(f=1/\\{1+\\exp[(E-\\mu)/kT]\\}\\) and smearing_sigma below is the temperature \\(T\\) (in Ry)."
  },
  {
    "name": "smearing_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "smearing_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.015",
        "unit": null,
        "description": "Energy range for smearing."
      }
    ],
    "parent_section": null,
    "description": "Energy range for smearing."
  },
  {
    "name": "smearing_sigma_temp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "smearing_sigma_temp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "2 * smearing_sigma / kB.",
        "unit": null,
        "description": "Energy range for smearing, smearing_sigma = 1/2 kB smearing_sigma_temp ."
      }
    ],
    "parent_section": null,
    "description": "Energy range for smearing, smearing_sigma = 1/2 kB smearing_sigma_temp ."
  },
  {
    "name": "mixing_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "broyden",
        "unit": null,
        "description": "Charge mixing methods. plain: Just simple mixing. pulay: Standard Pulay method. P. Pulay Chemical Physics Letters, (1980) broyden: Simplified modified Broyden method. D.D. Johnson Physical Review B (1988) In general, the convergence of the Broyden method is slightly faster than that of the Pulay method."
      }
    ],
    "parent_section": null,
    "description": "Charge mixing methods. plain: Just simple mixing. pulay: Standard Pulay method. P. Pulay Chemical Physics Letters, (1980) broyden: Simplified modified Broyden method. D.D. Johnson Physical Review B (1988) In general, the convergence of the Broyden method is slightly faster than that of the Pulay method."
  },
  {
    "name": "mixing_beta",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_beta {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.8 for nspin=1 , 0.4 for nspin=2 and nspin=4 .",
        "unit": null,
        "description": "In general, the formula of charge mixing can be written as \\(\\rho_{new} = \\rho_{old} + \\beta * \\rho_{update}\\) , where \\(\\rho_{new}\\) represents the new charge density after charge mixing, \\(\\rho_{old}\\) represents the charge density in previous step, \\(\\rho_{update}\\) is obtained through various mixing methods, and \\(\\beta\\) is set by the parameter mixing_beta . A lower value of ‘mixing_beta’ results in less influence of \\(\\rho_{update}\\) on \\(\\rho_{new}\\) , making the self-consistent field (SC"
      }
    ],
    "parent_section": null,
    "description": "In general, the formula of charge mixing can be written as \\(\\rho_{new} = \\rho_{old} + \\beta * \\rho_{update}\\) , where \\(\\rho_{new}\\) represents the new charge density after charge mixing, \\(\\rho_{old}\\) represents the charge density in previous step, \\(\\rho_{update}\\) is obtained through various mixing methods, and \\(\\beta\\) is set by the parameter mixing_beta . A lower value of ‘mixing_beta’ results in less influence of \\(\\rho_{update}\\) on \\(\\rho_{new}\\) , making the self-consistent field (SC"
  },
  {
    "name": "mixing_beta_mag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_beta_mag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "4*mixing_beta , but the maximum value is 1.6.",
        "unit": null,
        "description": "Mixing parameter of magnetic density."
      }
    ],
    "parent_section": null,
    "description": "Mixing parameter of magnetic density."
  },
  {
    "name": "mixing_ndim",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_ndim {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "8",
        "unit": null,
        "description": "It indicates the mixing dimensions in Pulay or Broyden. Pulay and Broyden method use the density from previous mixing_ndim steps and do a charge mixing based on this density. For systems that are difficult to converge, one could try increasing the value of ‘mixing_ndim’ to enhance the stability of the self-consistent field (SCF) calculation."
      }
    ],
    "parent_section": null,
    "description": "It indicates the mixing dimensions in Pulay or Broyden. Pulay and Broyden method use the density from previous mixing_ndim steps and do a charge mixing based on this density. For systems that are difficult to converge, one could try increasing the value of ‘mixing_ndim’ to enhance the stability of the self-consistent field (SCF) calculation."
  },
  {
    "name": "mixing_restart",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_restart {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "If the density difference between input and output drho is smaller than mixing_restart , SCF will restart at next step which means SCF will restart by using output charge density from perivos iteration as input charge density directly, and start a new mixing. Notice that mixing_restart will only take effect once in one SCF."
      }
    ],
    "parent_section": null,
    "description": "If the density difference between input and output drho is smaller than mixing_restart , SCF will restart at next step which means SCF will restart by using output charge density from perivos iteration as input charge density directly, and start a new mixing. Notice that mixing_restart will only take effect once in one SCF."
  },
  {
    "name": "mixing_dmr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_dmr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "At n-th iteration which is calculated by drho<mixing_restart , SCF will start a mixing for real-space density matrix by using the same coefficiences as the mixing of charge density."
      }
    ],
    "parent_section": null,
    "description": "At n-th iteration which is calculated by drho<mixing_restart , SCF will start a mixing for real-space density matrix by using the same coefficiences as the mixing of charge density."
  },
  {
    "name": "mixing_gg0",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_gg0 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Whether to perfom Kerker scaling for charge density. 0: The high frequency wave vectors will be suppressed by multiplying a scaling factor \\(\\frac{k^2}{k^2+gg0^2}\\) . Setting mixing_gg0 = 1.0 is normally a good starting point. Kerker preconditioner will be automatically turned off if mixing_beta <= 0.1 . 0: No Kerker scaling is performed. For systems that are difficult to converge, particularly metallic systems, enabling Kerker scaling may aid in achieving convergence."
      }
    ],
    "parent_section": null,
    "description": "Whether to perfom Kerker scaling for charge density. 0: The high frequency wave vectors will be suppressed by multiplying a scaling factor \\(\\frac{k^2}{k^2+gg0^2}\\) . Setting mixing_gg0 = 1.0 is normally a good starting point. Kerker preconditioner will be automatically turned off if mixing_beta <= 0.1 . 0: No Kerker scaling is performed. For systems that are difficult to converge, particularly metallic systems, enabling Kerker scaling may aid in achieving convergence."
  },
  {
    "name": "mixing_gg0_mag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_gg0_mag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Whether to perfom Kerker preconditioner of magnetic density. Note: we do not recommand to open Kerker preconditioner of magnetic density unless the system is too hard to converge."
      }
    ],
    "parent_section": null,
    "description": "Whether to perfom Kerker preconditioner of magnetic density. Note: we do not recommand to open Kerker preconditioner of magnetic density unless the system is too hard to converge."
  },
  {
    "name": "mixing_gg0_min",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_gg0_min {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "The minimum kerker coefficient."
      }
    ],
    "parent_section": null,
    "description": "The minimum kerker coefficient."
  },
  {
    "name": "mixing_angle",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_angle {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-10.0",
        "unit": null,
        "description": "Normal broyden mixing can give the converged result for a given magnetic configuration. If one is not interested in the energies of a given magnetic configuration but wants to determine the ground state by relaxing the magnetic moments’ directions, one cannot rely on the standard Broyden mixing algorithm. To enhance the ability to find correct magnetic configuration for non-colinear calculations, ABACUS implements a promising mixing method proposed by J. Phys. Soc. Jpn. 82 (2013) 114706. Here, m"
      }
    ],
    "parent_section": null,
    "description": "Normal broyden mixing can give the converged result for a given magnetic configuration. If one is not interested in the energies of a given magnetic configuration but wants to determine the ground state by relaxing the magnetic moments’ directions, one cannot rely on the standard Broyden mixing algorithm. To enhance the ability to find correct magnetic configuration for non-colinear calculations, ABACUS implements a promising mixing method proposed by J. Phys. Soc. Jpn. 82 (2013) 114706. Here, m"
  },
  {
    "name": "mixing_tau",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_tau {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to mix the kinetic energy density. True: The kinetic energy density will also be mixed. It seems for general cases, SCF converges fine even without this mixing. However, if there is difficulty in converging SCF for meta-GGA, it might be helpful to turn this on. False: The kinetic energy density will not be mixed."
      }
    ],
    "parent_section": null,
    "description": "Whether to mix the kinetic energy density. True: The kinetic energy density will also be mixed. It seems for general cases, SCF converges fine even without this mixing. However, if there is difficulty in converging SCF for meta-GGA, it might be helpful to turn this on. False: The kinetic energy density will not be mixed."
  },
  {
    "name": "mixing_dftu",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "mixing_dftu {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to mix the occupation matrices. True: The occupation matrices will also be mixed by plain mixing. From experience this is not very helpful if the +U calculation does not converge. False: The occupation matrices will not be mixed."
      }
    ],
    "parent_section": null,
    "description": "Whether to mix the occupation matrices. True: The occupation matrices will also be mixed by plain mixing. From experience this is not very helpful if the +U calculation does not converge. False: The occupation matrices will not be mixed."
  },
  {
    "name": "gamma_only",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "gamma_only {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Whether to use gamma_only algorithm. 0: more than one k-point is used and the ABACUS is slower compared to the gamma only algorithm. 1: ABACUS uses gamma only, the algorithm is faster and you don’t need to specify the k-points file. Note: If gamma_only is set to 1, the KPT file will be overwritten. So make sure to turn off gamma_only for multi-k calculations."
      }
    ],
    "parent_section": null,
    "description": "Whether to use gamma_only algorithm. 0: more than one k-point is used and the ABACUS is slower compared to the gamma only algorithm. 1: ABACUS uses gamma only, the algorithm is faster and you don’t need to specify the k-points file. Note: If gamma_only is set to 1, the KPT file will be overwritten. So make sure to turn off gamma_only for multi-k calculations."
  },
  {
    "name": "scf_nmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_nmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "100",
        "unit": null,
        "description": "This variable indicates the maximal iteration number for electronic iterations."
      }
    ],
    "parent_section": null,
    "description": "This variable indicates the maximal iteration number for electronic iterations."
  },
  {
    "name": "scf_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0e-9 (plane-wave basis), or 1.0e-7 (localized atomic orbital basis).",
        "unit": null,
        "description": "It’s the density threshold for electronic iteration. It represents the charge density error between two sequential densities from electronic iterations. Usually for local orbitals, usually 1e-6 may be accurate enough."
      }
    ],
    "parent_section": null,
    "description": "It’s the density threshold for electronic iteration. It represents the charge density error between two sequential densities from electronic iterations. Usually for local orbitals, usually 1e-6 may be accurate enough."
  },
  {
    "name": "scf_ene_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_ene_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1.0. If the user does not set this parameter, it will not take effect.",
        "unit": null,
        "description": "It’s the energy threshold for electronic iteration. It represents the total energy error between two sequential densities from electronic iterations."
      }
    ],
    "parent_section": null,
    "description": "It’s the energy threshold for electronic iteration. It represents the total energy error between two sequential densities from electronic iterations."
  },
  {
    "name": "scf_thr_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_thr_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1 (plane-wave basis), or 2 (localized atomic orbital basis).",
        "unit": null,
        "description": "Choose the calculation method of convergence criterion. 1: the criterion is defined as \\(\\Delta\\rho_G = \\frac{1}{2}\\iint{\\frac{\\Delta\\rho(r)\\Delta\\rho(r')}{|r-r'|}d^3r d^3r'}\\) , which is used in SCF of PW basis with unit Ry. 2: the criterion is defined as \\(\\Delta\\rho_R = \\frac{1}{N_e}\\int{|\\Delta\\rho(r)|d^3r}\\) , where \\(N_e\\) is the number of electron, which is used in SCF of LCAO with unit dimensionless ."
      }
    ],
    "parent_section": null,
    "description": "Choose the calculation method of convergence criterion. 1: the criterion is defined as \\(\\Delta\\rho_G = \\frac{1}{2}\\iint{\\frac{\\Delta\\rho(r)\\Delta\\rho(r')}{|r-r'|}d^3r d^3r'}\\) , which is used in SCF of PW basis with unit Ry. 2: the criterion is defined as \\(\\Delta\\rho_R = \\frac{1}{N_e}\\int{|\\Delta\\rho(r)|d^3r}\\) , where \\(N_e\\) is the number of electron, which is used in SCF of LCAO with unit dimensionless ."
  },
  {
    "name": "scf_os_stop",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_os_stop {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "For systems that are difficult to converge, the SCF process may exhibit oscillations in charge density, preventing further progress toward the specified convergence criteria and resulting in continuous oscillation until the maximum number of steps is reached; this greatly wastes computational resources. To address this issue, this function allows ABACUS to terminate the SCF process early upon detecting oscillations, thus reducing subsequent meaningless calculations. The detection of oscillations"
      }
    ],
    "parent_section": null,
    "description": "For systems that are difficult to converge, the SCF process may exhibit oscillations in charge density, preventing further progress toward the specified convergence criteria and resulting in continuous oscillation until the maximum number of steps is reached; this greatly wastes computational resources. To address this issue, this function allows ABACUS to terminate the SCF process early upon detecting oscillations, thus reducing subsequent meaningless calculations. The detection of oscillations"
  },
  {
    "name": "scf_os_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_os_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-0.01",
        "unit": null,
        "description": "The slope threshold to determine if the SCF is stuck in a charge density oscillation. If the calculated slope is larger than scf_os_thr , stop the SCF."
      }
    ],
    "parent_section": null,
    "description": "The slope threshold to determine if the SCF is stuck in a charge density oscillation. If the calculated slope is larger than scf_os_thr , stop the SCF."
  },
  {
    "name": "scf_os_ndim",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "scf_os_ndim {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "mixing_ndim",
        "unit": null,
        "description": "To determine the number of old iterations’ drho used in slope calculations."
      }
    ],
    "parent_section": null,
    "description": "To determine the number of old iterations’ drho used in slope calculations."
  },
  {
    "name": "sc_os_ndim",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "sc_os_ndim {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "5",
        "unit": null,
        "description": "To determine the number of old iterations to judge oscillation, it occured, more accurate lambda with DeltaSpin method would be calculated, only for PW base."
      }
    ],
    "parent_section": null,
    "description": "To determine the number of old iterations to judge oscillation, it occured, more accurate lambda with DeltaSpin method would be calculated, only for PW base."
  },
  {
    "name": "chg_extrap",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "chg_extrap {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "first-order (geometry relaxations), second-order (molecular dynamics), else atomic",
        "unit": null,
        "description": "Methods to do extrapolation of density when ABACUS is doing geometry relaxations or molecular dynamics. atomic: atomic extrapolation. first-order: first-order extrapolation. second-order: second-order extrapolation."
      }
    ],
    "parent_section": null,
    "description": "Methods to do extrapolation of density when ABACUS is doing geometry relaxations or molecular dynamics. atomic: atomic extrapolation. first-order: first-order extrapolation. second-order: second-order extrapolation."
  },
  {
    "name": "lspinorb",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lspinorb {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to consider spin-orbit coupling (SOC) effect in the calculation. True : Consider spin-orbit coupling effect. When enabled: nspin is automatically set to 4 (noncollinear spin representation) Symmetry is automatically disabled (SOC breaks inversion symmetry) Requires full-relativistic pseudopotentials with has_so=true in the UPF header False : Do not consider spin-orbit coupling effect. Common Error : “no soc upf used for lspinorb calculation” - ensure you are using full-relativistic pseud"
      }
    ],
    "parent_section": null,
    "description": "Whether to consider spin-orbit coupling (SOC) effect in the calculation. True : Consider spin-orbit coupling effect. When enabled: nspin is automatically set to 4 (noncollinear spin representation) Symmetry is automatically disabled (SOC breaks inversion symmetry) Requires full-relativistic pseudopotentials with has_so=true in the UPF header False : Do not consider spin-orbit coupling effect. Common Error : “no soc upf used for lspinorb calculation” - ensure you are using full-relativistic pseud"
  },
  {
    "name": "noncolin",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "noncolin {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to allow non-collinear magnetic moments, where magnetization can point in arbitrary directions (x, y, z components) rather than being constrained to the z-axis. True : Allow non-collinear polarization. When enabled: nspin is automatically set to 4 Wave function dimension is doubled ( npol=2 ), and the number of occupied states is doubled Charge density has 4 components (Pauli spin matrices: ρ_total, ρ_x, ρ_y, ρ_z) Constraint : Cannot be used with gamma_only=true Can be combined with lspi"
      }
    ],
    "parent_section": null,
    "description": "Whether to allow non-collinear magnetic moments, where magnetization can point in arbitrary directions (x, y, z components) rather than being constrained to the z-axis. True : Allow non-collinear polarization. When enabled: nspin is automatically set to 4 Wave function dimension is doubled ( npol=2 ), and the number of occupied states is doubled Charge density has 4 components (Pauli spin matrices: ρ_total, ρ_x, ρ_y, ρ_z) Constraint : Cannot be used with gamma_only=true Can be combined with lspi"
  },
  {
    "name": "soc_lambda",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "soc_lambda {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Modulates the strength of spin-orbit coupling effect. Sometimes, for some real materials, both scalar-relativistic and full-relativistic pseudopotentials cannot describe the exact spin-orbit coupling. Artificial modulation may help in such cases. soc_lambda , which has value range [0.0, 1.0], is used to modulate SOC effect: soc_lambda 0.0 : Scalar-relativistic case (no SOC) soc_lambda 1.0 : Full-relativistic case (full SOC) Intermediate values: Partial-relativistic SOC (interpolation between sca"
      }
    ],
    "parent_section": null,
    "description": "Modulates the strength of spin-orbit coupling effect. Sometimes, for some real materials, both scalar-relativistic and full-relativistic pseudopotentials cannot describe the exact spin-orbit coupling. Artificial modulation may help in such cases. soc_lambda , which has value range [0.0, 1.0], is used to modulate SOC effect: soc_lambda 0.0 : Scalar-relativistic case (no SOC) soc_lambda 1.0 : Full-relativistic case (full SOC) Intermediate values: Partial-relativistic SOC (interpolation between sca"
  },
  {
    "name": "dfthalf_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dfthalf_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": null,
        "unit": null,
        "description": "Choose the type of DFT-1/2 calcutions. Currently, only the PW basis set is supported. 0: Do not consider DFT-1/2 correction. 1: Apply DFT-1/2(shell DFT-1/2) correction. In addition, the SEP_FILES keyword also needs to be added to the STRU file, followed by the DFT-1/2 settings for each element, listed in the same order as ATOMIC_SPECIES. The format is"
      }
    ],
    "parent_section": null,
    "description": "Choose the type of DFT-1/2 calcutions. Currently, only the PW basis set is supported. 0: Do not consider DFT-1/2 correction. 1: Apply DFT-1/2(shell DFT-1/2) correction. In addition, the SEP_FILES keyword also needs to be added to the STRU file, followed by the DFT-1/2 settings for each element, listed in the same order as ATOMIC_SPECIES. The format is"
  },
  {
    "name": "method_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "method_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2",
        "unit": null,
        "description": "Different methods to do stochastic DFT 1: Calculate \\(T_n(\\hat{h})\\ket{\\chi}\\) twice, where \\(T_n(x)\\) is the n-th order Chebyshev polynomial and \\(\\hat{h}=\\frac{\\hat{H}-\\bar{E}}{\\Delta E}\\) owning eigenvalues \\(\\in(-1,1)\\) . This method cost less memory but is slower. 2: Calculate \\(T_n(\\hat{h})\\ket{\\chi}\\) once but needs much more memory. This method is much faster. Besides, it calculates \\(N_e\\) with \\(\\bra{\\chi}\\sqrt{\\hat f}\\sqrt{\\hat f}\\ket{\\chi}\\) , which needs a smaller nche_sto . However"
      }
    ],
    "parent_section": null,
    "description": "Different methods to do stochastic DFT 1: Calculate \\(T_n(\\hat{h})\\ket{\\chi}\\) twice, where \\(T_n(x)\\) is the n-th order Chebyshev polynomial and \\(\\hat{h}=\\frac{\\hat{H}-\\bar{E}}{\\Delta E}\\) owning eigenvalues \\(\\in(-1,1)\\) . This method cost less memory but is slower. 2: Calculate \\(T_n(\\hat{h})\\ket{\\chi}\\) once but needs much more memory. This method is much faster. Besides, it calculates \\(N_e\\) with \\(\\bra{\\chi}\\sqrt{\\hat f}\\sqrt{\\hat f}\\ket{\\chi}\\) , which needs a smaller nche_sto . However"
  },
  {
    "name": "nbands_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nbands_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "256",
        "unit": null,
        "description": "The number of stochastic orbitals > 0: Perform stochastic DFT. Increasing the number of bands improves accuracy and reduces stochastic errors, which scale as \\(1/\\sqrt{N_{\\chi}}\\) ; To perform mixed stochastic-deterministic DFT, you should set nbands , which represents the number of KS orbitals. 0: Perform Kohn-Sham DFT. all: All complete basis sets are used to replace stochastic orbitals with the Chebyshev method (CT), resulting in the same results as KSDFT without stochastic errors."
      }
    ],
    "parent_section": null,
    "description": "The number of stochastic orbitals > 0: Perform stochastic DFT. Increasing the number of bands improves accuracy and reduces stochastic errors, which scale as \\(1/\\sqrt{N_{\\chi}}\\) ; To perform mixed stochastic-deterministic DFT, you should set nbands , which represents the number of KS orbitals. 0: Perform Kohn-Sham DFT. all: All complete basis sets are used to replace stochastic orbitals with the Chebyshev method (CT), resulting in the same results as KSDFT without stochastic errors."
  },
  {
    "name": "nche_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nche_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "100",
        "unit": null,
        "description": "Chebyshev expansion orders for stochastic DFT."
      }
    ],
    "parent_section": null,
    "description": "Chebyshev expansion orders for stochastic DFT."
  },
  {
    "name": "emin_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "emin_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Trial energy to guess the lower bound of eigen energies of the Hamiltonian Operator \\(\\hat{H}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Trial energy to guess the lower bound of eigen energies of the Hamiltonian Operator \\(\\hat{H}\\) ."
  },
  {
    "name": "emax_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "emax_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Trial energy to guess the upper bound of eigen energies of the Hamiltonian Operator \\(\\hat{H}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Trial energy to guess the upper bound of eigen energies of the Hamiltonian Operator \\(\\hat{H}\\) ."
  },
  {
    "name": "seed_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "seed_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "The random seed to generate stochastic orbitals. >= 0: Stochastic orbitals have the form of \\(\\exp(i2\\pi\\theta(G))\\) , where \\(\\theta\\) is a uniform distribution in \\((0,1)\\) . 0: the seed is decided by time(NULL). <= -1: Stochastic orbitals have the form of \\(\\pm1\\) with equal probability. -1: the seed is decided by time(NULL)."
      }
    ],
    "parent_section": null,
    "description": "The random seed to generate stochastic orbitals. >= 0: Stochastic orbitals have the form of \\(\\exp(i2\\pi\\theta(G))\\) , where \\(\\theta\\) is a uniform distribution in \\((0,1)\\) . 0: the seed is decided by time(NULL). <= -1: Stochastic orbitals have the form of \\(\\pm1\\) with equal probability. -1: the seed is decided by time(NULL)."
  },
  {
    "name": "initsto_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "initsto_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Stochastic wave functions are initialized in a large box generated by “4* initsto_ecut ”. initsto_ecut should be larger than ecutwfc . In this method, SDFT results are the same when using different cores. Besides, coefficients of the same G are the same when ecutwfc is rising to initsto_ecut. If it is smaller than ecutwfc , it will be turned off."
      }
    ],
    "parent_section": null,
    "description": "Stochastic wave functions are initialized in a large box generated by “4* initsto_ecut ”. initsto_ecut should be larger than ecutwfc . In this method, SDFT results are the same when using different cores. Besides, coefficients of the same G are the same when ecutwfc is rising to initsto_ecut. If it is smaller than ecutwfc , it will be turned off."
  },
  {
    "name": "initsto_freq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "initsto_freq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Frequency (once each initsto_freq steps) to generate new stochastic orbitals when running md. positive integer: Update stochastic orbitals 0: Never change stochastic orbitals."
      }
    ],
    "parent_section": null,
    "description": "Frequency (once each initsto_freq steps) to generate new stochastic orbitals when running md. positive integer: Update stochastic orbitals 0: Never change stochastic orbitals."
  },
  {
    "name": "npart_sto",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "npart_sto {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Make memory cost to 1/npart_sto times of the previous one when running the post process of SDFT like DOS or conductivities."
      }
    ],
    "parent_section": null,
    "description": "Make memory cost to 1/npart_sto times of the previous one when running the post process of SDFT like DOS or conductivities."
  },
  {
    "name": "relax_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "cg 1",
        "unit": null,
        "description": "The methods to do geometry optimization. the first element: cg: using the conjugate gradient (CG) algorithm. Note that there are two implementations of the conjugate gradient (CG) method, see relax_new . bfgs : using the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm. lbfgs: using the Limited-memory Broyden–Fletcher–Goldfarb–Shanno (LBFGS) algorithm. cg_bfgs: using the CG method for the initial steps, and switching to BFGS method when the force convergence is smaller than relax_cg_thr . sd: u"
      }
    ],
    "parent_section": null,
    "description": "The methods to do geometry optimization. the first element: cg: using the conjugate gradient (CG) algorithm. Note that there are two implementations of the conjugate gradient (CG) method, see relax_new . bfgs : using the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm. lbfgs: using the Limited-memory Broyden–Fletcher–Goldfarb–Shanno (LBFGS) algorithm. cg_bfgs: using the CG method for the initial steps, and switching to BFGS method when the force convergence is smaller than relax_cg_thr . sd: u"
  },
  {
    "name": "relax_new",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_new {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "At around the end of 2022 we made a new implementation of the Conjugate Gradient (CG) method for relax and cell-relax calculations. But the old implementation was also kept. True: use the new implementation of CG method for relax and cell-relax calculations. False: use the old implementation of CG method for relax and cell-relax calculations."
      }
    ],
    "parent_section": null,
    "description": "At around the end of 2022 we made a new implementation of the Conjugate Gradient (CG) method for relax and cell-relax calculations. But the old implementation was also kept. True: use the new implementation of CG method for relax and cell-relax calculations. False: use the old implementation of CG method for relax and cell-relax calculations."
  },
  {
    "name": "relax_scale_force",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_scale_force {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "The paramether controls the size of the first conjugate gradient step. A smaller value means the first step along a new CG direction is smaller. This might be helpful for large systems, where it is safer to take a smaller initial step to prevent the collapse of the whole configuration."
      }
    ],
    "parent_section": null,
    "description": "The paramether controls the size of the first conjugate gradient step. A smaller value means the first step along a new CG direction is smaller. This might be helpful for large systems, where it is safer to take a smaller initial step to prevent the collapse of the whole configuration."
  },
  {
    "name": "relax_nmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_nmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1 for SCF, 50 for relax and cell-relax calcualtions",
        "unit": null,
        "description": "The maximal number of ionic iteration steps. If set to 0, the code performs a quick “dry run”, stopping just after initialization. This is useful to check for input correctness and to have the summary printed."
      }
    ],
    "parent_section": null,
    "description": "The maximal number of ionic iteration steps. If set to 0, the code performs a quick “dry run”, stopping just after initialization. This is useful to check for input correctness and to have the summary printed."
  },
  {
    "name": "relax_cg_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_cg_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "When move-method is set to cg_bfgs , a mixed algorithm of conjugate gradient (CG) method and Broyden–Fletcher–Goldfarb–Shanno (BFGS) method is used. The ions first move according to CG method, then switched to BFGS method when the maximum of force on atoms is reduced below the CG force threshold, which is set by this parameter."
      }
    ],
    "parent_section": null,
    "description": "When move-method is set to cg_bfgs , a mixed algorithm of conjugate gradient (CG) method and Broyden–Fletcher–Goldfarb–Shanno (BFGS) method is used. The ions first move according to CG method, then switched to BFGS method when the maximum of force on atoms is reduced below the CG force threshold, which is set by this parameter."
  },
  {
    "name": "cal_force",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cal_force {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False if calculation is set to scf , True if calculation is set to cell-relax , relax , or md .",
        "unit": null,
        "description": "True : Calculate the force at the end of the electronic iteration False : No force calculation at the end of the electronic iteration"
      }
    ],
    "parent_section": null,
    "description": "True : Calculate the force at the end of the electronic iteration False : No force calculation at the end of the electronic iteration"
  },
  {
    "name": "force_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "force_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.001",
        "unit": null,
        "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to force_thr_ev except for the unit, you can choose either you like."
      }
    ],
    "parent_section": null,
    "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to force_thr_ev except for the unit, you can choose either you like."
  },
  {
    "name": "force_thr_ev",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "force_thr_ev {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0257112",
        "unit": null,
        "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to force_thr except for the unit. You may choose either you like."
      }
    ],
    "parent_section": null,
    "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to force_thr except for the unit. You may choose either you like."
  },
  {
    "name": "force_zero_out",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "force_zero_out {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "The atomic forces that are smaller than force_zero_out will be treated as zero."
      }
    ],
    "parent_section": null,
    "description": "The atomic forces that are smaller than force_zero_out will be treated as zero."
  },
  {
    "name": "relax_bfgs_w1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_bfgs_w1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information."
      }
    ],
    "parent_section": null,
    "description": "Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information."
  },
  {
    "name": "relax_bfgs_w2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_bfgs_w2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information."
      }
    ],
    "parent_section": null,
    "description": "Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information."
  },
  {
    "name": "relax_bfgs_rmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_bfgs_rmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.8",
        "unit": null,
        "description": "For geometry optimization. It stands for the maximal movement of all the atoms. The sum of the movements from all atoms can be increased during the optimization steps. However, it can not be larger than relax_bfgs_rmax ."
      }
    ],
    "parent_section": null,
    "description": "For geometry optimization. It stands for the maximal movement of all the atoms. The sum of the movements from all atoms can be increased during the optimization steps. However, it can not be larger than relax_bfgs_rmax ."
  },
  {
    "name": "relax_bfgs_rmin",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_bfgs_rmin {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-5",
        "unit": null,
        "description": "In old bfgs algorithm, it indicates the minimal movement of all the atoms. When the movement of all the atoms is smaller than relax_bfgs_rmin Bohr, and the force convergence is still not achieved, the calculation will break down. In the current default bfgs algorithm, this parameter is not used."
      }
    ],
    "parent_section": null,
    "description": "In old bfgs algorithm, it indicates the minimal movement of all the atoms. When the movement of all the atoms is smaller than relax_bfgs_rmin Bohr, and the force convergence is still not achieved, the calculation will break down. In the current default bfgs algorithm, this parameter is not used."
  },
  {
    "name": "relax_bfgs_init",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "relax_bfgs_init {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "For geometry optimization. It stands for the sum of initial movements of all of the atoms."
      }
    ],
    "parent_section": null,
    "description": "For geometry optimization. It stands for the sum of initial movements of all of the atoms."
  },
  {
    "name": "cal_stress",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cal_stress {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True if calculation is cell-relax , False otherwise.",
        "unit": null,
        "description": "True : Calculate the stress at the end of the electronic iteration False : No calculation of the stress at the end of the electronic iteration"
      }
    ],
    "parent_section": null,
    "description": "True : Calculate the stress at the end of the electronic iteration False : No calculation of the stress at the end of the electronic iteration"
  },
  {
    "name": "stress_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "stress_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "The threshold of the stress convergence. The threshold is compared with the largest component of the stress tensor."
      }
    ],
    "parent_section": null,
    "description": "The threshold of the stress convergence. The threshold is compared with the largest component of the stress tensor."
  },
  {
    "name": "press1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "press1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
      }
    ],
    "parent_section": null,
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
  },
  {
    "name": "press2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "press2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
      }
    ],
    "parent_section": null,
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
  },
  {
    "name": "press3",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "press3 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
      }
    ],
    "parent_section": null,
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress."
  },
  {
    "name": "fixed_axes",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "fixed_axes {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Axes that are fixed during cell relaxation. Possible choices are: None**: default; all of the axes can relax volume**: relaxation with fixed volume shape**: fix shape but change volume (i.e. only lattice constant changes) a: fix a axis during relaxation b: fix b axis during relaxation c: fix c axis during relaxation ab: fix both a and b axes during relaxation ac: fix both a and c axes during relaxation bc: fix both b and c axes during relaxation"
      }
    ],
    "parent_section": null,
    "description": "Axes that are fixed during cell relaxation. Possible choices are: None**: default; all of the axes can relax volume**: relaxation with fixed volume shape**: fix shape but change volume (i.e. only lattice constant changes) a: fix a axis during relaxation b: fix b axis during relaxation c: fix c axis during relaxation ab: fix both a and b axes during relaxation ac: fix both a and c axes during relaxation bc: fix both b and c axes during relaxation"
  },
  {
    "name": "fixed_ibrav",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "fixed_ibrav {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": null,
        "unit": null,
        "description": "True: the lattice type will be preserved during relaxation False: No restrictions are exerted during relaxation in terms of lattice type"
      }
    ],
    "parent_section": null,
    "description": "True: the lattice type will be preserved during relaxation False: No restrictions are exerted during relaxation in terms of lattice type"
  },
  {
    "name": "fixed_atoms",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "fixed_atoms {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: The direct coordinates of atoms will be preserved during variable-cell relaxation. False: No restrictions are exerted on positions of all atoms. However, users can still fix certain components of certain atoms by using the m keyword in STRU file. For the latter option, check the end of this instruction ."
      }
    ],
    "parent_section": null,
    "description": "True: The direct coordinates of atoms will be preserved during variable-cell relaxation. False: No restrictions are exerted on positions of all atoms. However, users can still fix certain components of certain atoms by using the m keyword in STRU file. For the latter option, check the end of this instruction ."
  },
  {
    "name": "cell_factor",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cell_factor {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.2",
        "unit": null,
        "description": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation."
      }
    ],
    "parent_section": null,
    "description": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation."
  },
  {
    "name": "out_freq_ion",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_freq_ion {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Controls the output interval in ionic steps . When set to a positive integer \\(N\\) , information such as charge density, local potential, electrostatic potential, Hamiltonian matrix, overlap matrix, density matrix, and Mulliken population analysis is printed every \\(N\\) ionic steps."
      }
    ],
    "parent_section": null,
    "description": "Controls the output interval in ionic steps . When set to a positive integer \\(N\\) , information such as charge density, local potential, electrostatic potential, Hamiltonian matrix, overlap matrix, density matrix, and Mulliken population analysis is printed every \\(N\\) ionic steps."
  },
  {
    "name": "out_freq_td",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_freq_td {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Controls the output interval in completed electronic evolution steps during RT-TDDFT calculations. When set to a positive integer \\(N\\) , detailed information (see out_freq_ion ) is printed every \\(N\\) electron time-evolution steps (i.e., every \\(N\\) STEP OF ELECTRON EVOLVE ). For example, if you wish to output information once per ionic step, you should set out_freq_td equal to estep_per_md , since one ionic step corresponds to estep_per_md electronic evolution steps."
      }
    ],
    "parent_section": null,
    "description": "Controls the output interval in completed electronic evolution steps during RT-TDDFT calculations. When set to a positive integer \\(N\\) , detailed information (see out_freq_ion ) is printed every \\(N\\) electron time-evolution steps (i.e., every \\(N\\) STEP OF ELECTRON EVOLVE ). For example, if you wish to output information once per ionic step, you should set out_freq_td equal to estep_per_md , since one ionic step corresponds to estep_per_md electronic evolution steps."
  },
  {
    "name": "out_freq_elec",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_freq_elec {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "scf_nmax",
        "unit": null,
        "description": "Output the charge density (only binary format, controlled by out_chg ), wavefunction (controlled by out_wfc_pw ) per out_freq_elec electronic iterations. Note that they are always output when converged or reach the maximum iterations scf_nmax ."
      }
    ],
    "parent_section": null,
    "description": "Output the charge density (only binary format, controlled by out_chg ), wavefunction (controlled by out_wfc_pw ) per out_freq_elec electronic iterations. Note that they are always output when converged or reach the maximum iterations scf_nmax ."
  },
  {
    "name": "out_chg",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_chg {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0 3",
        "unit": null,
        "description": "The first integer controls whether to output the charge density on real space grids: 1: Output the charge density (in Bohr^-3) on real space grids into the density files in the folder OUT.${suffix} . The files are named as: nspin = 1: chg.cube ; nspin = 2: chgs1.cube , and chgs2.cube ; nspin = 4: chgs1.cube , chgs2.cube , chgs3.cube , and chgs4.cube ; Note that by using the Meta-GGA functional, additional files containing the kinetic energy density will be output with the following names: nspin "
      }
    ],
    "parent_section": null,
    "description": "The first integer controls whether to output the charge density on real space grids: 1: Output the charge density (in Bohr^-3) on real space grids into the density files in the folder OUT.${suffix} . The files are named as: nspin = 1: chg.cube ; nspin = 2: chgs1.cube , and chgs2.cube ; nspin = 4: chgs1.cube , chgs2.cube , chgs3.cube , and chgs4.cube ; Note that by using the Meta-GGA functional, additional files containing the kinetic energy density will be output with the following names: nspin "
  },
  {
    "name": "out_pot",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_pot {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "1: Output the total local potential (i.e., local pseudopotential + Hartree potential + XC potential + external electric field (if exists) + dipole correction potential (if exists) + …) on real space grids (in Ry) into files in the folder OUT.${suffix} . The files are named as: nspin = 1: pots1.cube ; nspin = 2: pots1.cube and pots2.cube ; nspin = 4: pots1.cube , pots2.cube , pots3.cube , and pots4.cube 2: Output the electrostatic potential on real space grids into OUT.${suffix}/pot_es.cube . The"
      }
    ],
    "parent_section": null,
    "description": "1: Output the total local potential (i.e., local pseudopotential + Hartree potential + XC potential + external electric field (if exists) + dipole correction potential (if exists) + …) on real space grids (in Ry) into files in the folder OUT.${suffix} . The files are named as: nspin = 1: pots1.cube ; nspin = 2: pots1.cube and pots2.cube ; nspin = 4: pots1.cube , pots2.cube , pots3.cube , and pots4.cube 2: Output the electrostatic potential on real space grids into OUT.${suffix}/pot_es.cube . The"
  },
  {
    "name": "out_dmk",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_dmk {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the density matrix for each k-point into files in the folder OUT.${suffix} . The files are named as: For gamma only case: nspin = 1 and 4: dm_nao.csr ; nspin = 2: dms1_nao.csr and dms2_nao.csr for the two spin channels. For multi-k points case: nspin = 1 and 4: dmk1_nao.csr , dmk2_nao.csr , …; nspin = 2: dmk1s1_nao.csr … and dmk1s2_nao.csr … for the two spin channels."
      }
    ],
    "parent_section": null,
    "description": "Whether to output the density matrix for each k-point into files in the folder OUT.${suffix} . The files are named as: For gamma only case: nspin = 1 and 4: dm_nao.csr ; nspin = 2: dms1_nao.csr and dms2_nao.csr for the two spin channels. For multi-k points case: nspin = 1 and 4: dmk1_nao.csr , dmk2_nao.csr , …; nspin = 2: dmk1s1_nao.csr … and dmk1s2_nao.csr … for the two spin channels."
  },
  {
    "name": "out_dmr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_dmr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the density matrix with Bravias lattice vector R index into files in the folder OUT.${suffix} . The files are named as dmr{s}{spin index}{g}{geometry index}{_nao} + {\".csr\"} . Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and the sparse matrix format ‘csr’ is mentioned in out_mat_hs2 . Finally, if out_app_flag is set to false, the file name contains the optional ‘g’ index for each ionic step that may have different geometries, and if"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the density matrix with Bravias lattice vector R index into files in the folder OUT.${suffix} . The files are named as dmr{s}{spin index}{g}{geometry index}{_nao} + {\".csr\"} . Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and the sparse matrix format ‘csr’ is mentioned in out_mat_hs2 . Finally, if out_app_flag is set to false, the file name contains the optional ‘g’ index for each ionic step that may have different geometries, and if"
  },
  {
    "name": "out_wfc_pw",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wfc_pw {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder OUT.${suffix} . The files are named as wf{k}{k-point index}{s}{spin index}{g}{geometry index}{e}{electronic iteration index}{_pw} + {\".txt\"/\".dat\"} . Here, the s index refers to spin but the label will not show up for non-spin-polarized calculations, where s1 means spin up channel while s2 means spin down channel, and s4 refers to spinor wave functions that contains both spin channels with spin-orb"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder OUT.${suffix} . The files are named as wf{k}{k-point index}{s}{spin index}{g}{geometry index}{e}{electronic iteration index}{_pw} + {\".txt\"/\".dat\"} . Here, the s index refers to spin but the label will not show up for non-spin-polarized calculations, where s1 means spin up channel while s2 means spin down channel, and s4 refers to spinor wave functions that contains both spin channels with spin-orb"
  },
  {
    "name": "out_wfc_lcao",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wfc_lcao {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder OUT.${suffix} . The files are named as wf{s}{spin index}{k(optional)}{k-point index}{g(optional)}{geometry index1}{_nao} + {\".txt\"/\".dat\"} . Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and ‘s12’ refer to spinor wave functions that contains both spin channels with spin-orbital coupling or noncollinear calculations enabled. In addition, if ‘gamma_only’ i"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder OUT.${suffix} . The files are named as wf{s}{spin index}{k(optional)}{k-point index}{g(optional)}{geometry index1}{_nao} + {\".txt\"/\".dat\"} . Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and ‘s12’ refer to spinor wave functions that contains both spin channels with spin-orbital coupling or noncollinear calculations enabled. In addition, if ‘gamma_only’ i"
  },
  {
    "name": "out_dos",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_dos {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Whether to output the density of states (DOS). For more information, refer to the dos.md . 0: no output 1: output the density of states (DOS) nspin=1 or 4: doss1g{geom}_{basis}.txt , where geom is the geometry index when cell changes or ions move while basis is either pw or nao . nspin=2: doss1g{geom}_{basis}.txt and doss2g{geom}_{basis}.txt for two spin channles. 2: (LCAO) output the density of states (DOS) and the projected density of states (PDOS) 3: output the Fermi surface file (fermi.bxsf)"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the density of states (DOS). For more information, refer to the dos.md . 0: no output 1: output the density of states (DOS) nspin=1 or 4: doss1g{geom}_{basis}.txt , where geom is the geometry index when cell changes or ions move while basis is either pw or nao . nspin=2: doss1g{geom}_{basis}.txt and doss2g{geom}_{basis}.txt for two spin channles. 2: (LCAO) output the density of states (DOS) and the projected density of states (PDOS) 3: output the Fermi surface file (fermi.bxsf)"
  },
  {
    "name": "out_ldos",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_ldos {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Whether to output the local density of states (LDOS), optionally output precision can be set by a second parameter, default is 3. 0: no output 1: output the partial charge density for given bias (controlled by stm_bias ) in cube file format, which can be used to plot scanning tunneling spectroscopys to mimick STM images using the Python script plot.py . 2: output LDOS along a line in real space (controlled by ldos_line ). Parameters used to control DOS output are also valid for LDOS. 3: output b"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the local density of states (LDOS), optionally output precision can be set by a second parameter, default is 3. 0: no output 1: output the partial charge density for given bias (controlled by stm_bias ) in cube file format, which can be used to plot scanning tunneling spectroscopys to mimick STM images using the Python script plot.py . 2: output LDOS along a line in real space (controlled by ldos_line ). Parameters used to control DOS output are also valid for LDOS. 3: output b"
  },
  {
    "name": "out_band",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_band {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the eigenvalues of the Hamiltonian matrix (in eV) into the running log during electronic iterations and into a file at the end of calculations. The former can be used with the ‘out_freq_elec’ parameter while the latter option allows the output precision to be set via a second parameter, with a default value of 8. The output file names are: nspin = 1 or 4: eig.txt ; nspin = 2: eigs1.txt and eigs2.txt ; For more information, refer to the band.md"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the eigenvalues of the Hamiltonian matrix (in eV) into the running log during electronic iterations and into a file at the end of calculations. The former can be used with the ‘out_freq_elec’ parameter while the latter option allows the output precision to be set via a second parameter, with a default value of 8. The output file names are: nspin = 1 or 4: eig.txt ; nspin = 2: eigs1.txt and eigs2.txt ; For more information, refer to the band.md"
  },
  {
    "name": "out_proj_band",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_proj_band {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the projected band structure. For more information, refer to the band.md"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the projected band structure. For more information, refer to the band.md"
  },
  {
    "name": "out_stru",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_stru {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output structure files per ionic step in geometry relaxation calculations into OUT.${suffix}/STRU_ION${istep}_D , where ${istep} is the ionic step."
      }
    ],
    "parent_section": null,
    "description": "Whether to output structure files per ionic step in geometry relaxation calculations into OUT.${suffix}/STRU_ION${istep}_D , where ${istep} is the ionic step."
  },
  {
    "name": "out_level",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_level {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "ie",
        "unit": null,
        "description": "Control the output level of information in OUT.${suffix}/running_${calculation}.log . ie: electronic iteration level, which prints useful information for electronic iterations; i: geometry relaxation level, which prints some information for geometry relaxations additionally; m: molecular dynamics level, which does not print some information for simplicity."
      }
    ],
    "parent_section": null,
    "description": "Control the output level of information in OUT.${suffix}/running_${calculation}.log . ie: electronic iteration level, which prints useful information for electronic iterations; i: geometry relaxation level, which prints some information for geometry relaxations additionally; m: molecular dynamics level, which does not print some information for simplicity."
  },
  {
    "name": "out_alllog",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_alllog {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print information into individual logs from all ranks in an MPI run. True: Information from each rank will be written into individual files named OUT.${suffix}/running_${calculation}_${rank+1}.log . False: Information will only be written from rank 0 into a file named OUT.${suffix}/running_${calculation}.log ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print information into individual logs from all ranks in an MPI run. True: Information from each rank will be written into individual files named OUT.${suffix}/running_${calculation}_${rank+1}.log . False: Information will only be written from rank 0 into a file named OUT.${suffix}/running_${calculation}.log ."
  },
  {
    "name": "out_mat_hs",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_hs {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False 8",
        "unit": null,
        "description": "Whether to print the upper triangular part of the Hamiltonian matrices and overlap matrices for each k-point into files in the directory OUT.${suffix} . The second number controls precision. For more information, please refer to hs_matrix.md . Also controled by out_freq_ion and out_app_flag . For gamma only case: nspin = 1: hks1_nao.txt for the Hamiltonian matrix and sks1_nao.txt for the overlap matrix; nspin = 2: hks1_nao.txt and hks2_nao.txt for the Hamiltonian matrix and sks1_nao.txt for the "
      }
    ],
    "parent_section": null,
    "description": "Whether to print the upper triangular part of the Hamiltonian matrices and overlap matrices for each k-point into files in the directory OUT.${suffix} . The second number controls precision. For more information, please refer to hs_matrix.md . Also controled by out_freq_ion and out_app_flag . For gamma only case: nspin = 1: hks1_nao.txt for the Hamiltonian matrix and sks1_nao.txt for the overlap matrix; nspin = 2: hks1_nao.txt and hks2_nao.txt for the Hamiltonian matrix and sks1_nao.txt for the "
  },
  {
    "name": "out_mat_hs2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_hs2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print files containing the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) into files in the directory OUT.${suffix} . For more information, please refer to hs_matrix.md ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print files containing the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) into files in the directory OUT.${suffix} . For more information, please refer to hs_matrix.md ."
  },
  {
    "name": "out_mat_tk",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_tk {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False [8]",
        "unit": null,
        "description": "Whether to print the upper triangular part of the kinetic matrices for each k-point into OUT.${suffix}/tks1ki_nao.txt , where i is the index of k points. One may optionally provide a second parameter to specify the precision."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the upper triangular part of the kinetic matrices for each k-point into OUT.${suffix}/tks1ki_nao.txt , where i is the index of k points. One may optionally provide a second parameter to specify the precision."
  },
  {
    "name": "out_mat_r",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_r {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print the matrix representation of the position matrix into a file named rr.csr in the directory OUT.${suffix} . If calculation is set to get_s , the position matrix can be obtained without scf iterations. For more information, please refer to position_matrix.md ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the matrix representation of the position matrix into a file named rr.csr in the directory OUT.${suffix} . If calculation is set to get_s , the position matrix can be obtained without scf iterations. For more information, please refer to position_matrix.md ."
  },
  {
    "name": "out_mat_t",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_t {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Generate files containing the kinetic energy matrix \\(T(R)\\) . The format will be the same as the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) as mentioned in out_mat_hs2 . The name of the files will be trs1_nao.csr and so on. Also controled by out_freq_ion and out_app_flag ."
      }
    ],
    "parent_section": null,
    "description": "Generate files containing the kinetic energy matrix \\(T(R)\\) . The format will be the same as the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) as mentioned in out_mat_hs2 . The name of the files will be trs1_nao.csr and so on. Also controled by out_freq_ion and out_app_flag ."
  },
  {
    "name": "out_mat_dh",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_dh {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print files containing the derivatives of the Hamiltonian matrix. The format will be the same as the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) as mentioned in out_mat_hs2 . The name of the files will be dhrxs1_nao.csr , dhrys1_nao.csr , dhrzs1_nao.csr and so on. Also controled by out_freq_ion and out_app_flag ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print files containing the derivatives of the Hamiltonian matrix. The format will be the same as the Hamiltonian matrix \\(H(R)\\) and overlap matrix \\(S(R)\\) as mentioned in out_mat_hs2 . The name of the files will be dhrxs1_nao.csr , dhrys1_nao.csr , dhrzs1_nao.csr and so on. Also controled by out_freq_ion and out_app_flag ."
  },
  {
    "name": "out_mat_ds",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_ds {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print files containing the derivatives of the overlap matrix. The format will be the same as the overlap matrix \\(dH(R)\\) as mentioned in out_mat_dh . The name of the files will be dsrxs1.csr and so on. Also controled by out_freq_ion and out_app_flag . This feature can be used with calculation get_s ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print files containing the derivatives of the overlap matrix. The format will be the same as the overlap matrix \\(dH(R)\\) as mentioned in out_mat_dh . The name of the files will be dsrxs1.csr and so on. Also controled by out_freq_ion and out_app_flag . This feature can be used with calculation get_s ."
  },
  {
    "name": "out_mat_xc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_xc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print the upper triangular part of the exchange-correlation matrices in Kohn-Sham orbital representation: \\(\\braket{\\psi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\psi_j}\\) for each k point into files in the directory OUT.${suffix} , which is useful for the subsequent GW calculation (the code is still under development). (Note that currently DeePKS term is not included.) The files are named vxcs1k$i_nao.txt , where $i corresponds to the k point index. The band (KS o"
      }
    ],
    "parent_section": null,
    "description": "Whether to print the upper triangular part of the exchange-correlation matrices in Kohn-Sham orbital representation: \\(\\braket{\\psi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\psi_j}\\) for each k point into files in the directory OUT.${suffix} , which is useful for the subsequent GW calculation (the code is still under development). (Note that currently DeePKS term is not included.) The files are named vxcs1k$i_nao.txt , where $i corresponds to the k point index. The band (KS o"
  },
  {
    "name": "out_mat_xc2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_xc2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print the exchange-correlation matrices in numerical orbital representation: \\(\\braket{\\phi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\phi_j}(\\mathbf{R})\\) in CSR format in the directory OUT.${suffix} . (Note that currently DeePKS term is not included. ) The files are named Vxc_R_spin$s ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the exchange-correlation matrices in numerical orbital representation: \\(\\braket{\\phi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\phi_j}(\\mathbf{R})\\) in CSR format in the directory OUT.${suffix} . (Note that currently DeePKS term is not included. ) The files are named Vxc_R_spin$s ."
  },
  {
    "name": "out_mat_l",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mat_l {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False 8",
        "unit": null,
        "description": "Whether to print the expectation value of the angular momentum operator \\(\\hat{L}_x\\) , \\(\\hat{L}_y\\) , and \\(\\hat{L}_z\\) in the basis of the localized atomic orbitals. The files are named OUT.${suffix}/${suffix}_Lx.dat , OUT.${suffix}/${suffix}_Ly.dat , and OUT.${suffix}/${suffix}_Lz.dat . The second integer controls the precision of the output."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the expectation value of the angular momentum operator \\(\\hat{L}_x\\) , \\(\\hat{L}_y\\) , and \\(\\hat{L}_z\\) in the basis of the localized atomic orbitals. The files are named OUT.${suffix}/${suffix}_Lx.dat , OUT.${suffix}/${suffix}_Ly.dat , and OUT.${suffix}/${suffix}_Lz.dat . The second integer controls the precision of the output."
  },
  {
    "name": "out_xc_r",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_xc_r {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1 3",
        "unit": null,
        "description": "The first integer controls whether to output the exchange-correlation (in Bohr^-3) on real space grids using Libxc to folder OUT.${suffix} : 0: rho, amag, sigma, exc 1: vrho, vsigma 2: v2rho2, v2rhosigma, v2sigma2 3: v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3 4: v4rho4, v4rho3sigma, v4rho2sigma2, v4rhosigma3, v4sigma4 The meaning of the files is presented in Libxc The second integer controls the precision of the charge density output, if not given, will use 3 as default. The circle order of the "
      }
    ],
    "parent_section": null,
    "description": "The first integer controls whether to output the exchange-correlation (in Bohr^-3) on real space grids using Libxc to folder OUT.${suffix} : 0: rho, amag, sigma, exc 1: vrho, vsigma 2: v2rho2, v2rhosigma, v2sigma2 3: v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3 4: v4rho4, v4rho3sigma, v4rho2sigma2, v4rhosigma3, v4sigma4 The meaning of the files is presented in Libxc The second integer controls the precision of the charge density output, if not given, will use 3 as default. The circle order of the "
  },
  {
    "name": "out_eband_terms",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_eband_terms {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print the band energy terms separately in the file OUT.${suffix}/${term}_out.dat . The terms include the kinetic, pseudopotential (local + nonlocal), Hartree and exchange-correlation (including exact exchange if calculated)."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the band energy terms separately in the file OUT.${suffix}/${term}_out.dat . The terms include the kinetic, pseudopotential (local + nonlocal), Hartree and exchange-correlation (including exact exchange if calculated)."
  },
  {
    "name": "out_mul",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_mul {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print the Mulliken population analysis result into OUT.${suffix}/mulliken.txt . In molecular dynamics calculations, the output frequency is controlled by out_freq_ion ."
      }
    ],
    "parent_section": null,
    "description": "Whether to print the Mulliken population analysis result into OUT.${suffix}/mulliken.txt . In molecular dynamics calculations, the output frequency is controlled by out_freq_ion ."
  },
  {
    "name": "out_app_flag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_app_flag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "true",
        "unit": null,
        "description": "Whether to output \\(r(R)\\) , \\(H(R)\\) , \\(S(R)\\) , \\(T(R)\\) , \\(dH(R)\\) , \\(H(k)\\) , \\(S(k)\\) and \\(wfc(k)\\) matrices in an append manner during molecular dynamics calculations. Check input parameters out_mat_r , out_mat_hs2 , out_mat_t , out_mat_dh , out_mat_hs and out_wfc_lcao for more information."
      }
    ],
    "parent_section": null,
    "description": "Whether to output \\(r(R)\\) , \\(H(R)\\) , \\(S(R)\\) , \\(T(R)\\) , \\(dH(R)\\) , \\(H(k)\\) , \\(S(k)\\) and \\(wfc(k)\\) matrices in an append manner during molecular dynamics calculations. Check input parameters out_mat_r , out_mat_hs2 , out_mat_t , out_mat_dh , out_mat_hs and out_wfc_lcao for more information."
  },
  {
    "name": "out_ndigits",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_ndigits {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "8",
        "unit": null,
        "description": "Controls the length of decimal part of output data, such as charge density, Hamiltonian matrix, Overlap matrix and so on."
      }
    ],
    "parent_section": null,
    "description": "Controls the length of decimal part of output data, such as charge density, Hamiltonian matrix, Overlap matrix and so on."
  },
  {
    "name": "out_element_info",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_element_info {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to print element information into files in the directory OUT.${suffix}/${element_label} , including pseudopotential and orbital information of the element (in atomic Ryberg units)."
      }
    ],
    "parent_section": null,
    "description": "Whether to print element information into files in the directory OUT.${suffix}/${element_label} , including pseudopotential and orbital information of the element (in atomic Ryberg units)."
  },
  {
    "name": "restart_save",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "restart_save {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to save charge density files per ionic step, which are used to restart calculations. According to the value of read_file_dir : auto: These files are saved in folder OUT.${suffix}/restart/ ; other: These files are saved in folder ${read_file_dir}/restart/ . If EXX(exact exchange) is calculated (i.e. dft_fuctional ==hse/hf/pbe0/scan0 or rpa ==True ), the Hexx® files for each processor will also be saved in the above folder, which can be read in EXX calculation with restart_load ==True ."
      }
    ],
    "parent_section": null,
    "description": "Whether to save charge density files per ionic step, which are used to restart calculations. According to the value of read_file_dir : auto: These files are saved in folder OUT.${suffix}/restart/ ; other: These files are saved in folder ${read_file_dir}/restart/ . If EXX(exact exchange) is calculated (i.e. dft_fuctional ==hse/hf/pbe0/scan0 or rpa ==True ), the Hexx® files for each processor will also be saved in the above folder, which can be read in EXX calculation with restart_load ==True ."
  },
  {
    "name": "out_pchg",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_pchg {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Specifies the electronic states to calculate the charge densities \\(|\\psi_{i}(\\boldsymbol{r})|^{2}\\) with state index \\(i\\) for, using a space-separated string of 0s and 1s. Each digit in the string corresponds to a state, starting from the first state. A 1 indicates that the charge density should be calculated for that state, while a 0 means the state will be ignored. The parameter allows a compact and flexible notation (similar to ocp_set ), for example the syntax 1 4*0 5*1 0 is used to denote"
      }
    ],
    "parent_section": null,
    "description": "Specifies the electronic states to calculate the charge densities \\(|\\psi_{i}(\\boldsymbol{r})|^{2}\\) with state index \\(i\\) for, using a space-separated string of 0s and 1s. Each digit in the string corresponds to a state, starting from the first state. A 1 indicates that the charge density should be calculated for that state, while a 0 means the state will be ignored. The parameter allows a compact and flexible notation (similar to ocp_set ), for example the syntax 1 4*0 5*1 0 is used to denote"
  },
  {
    "name": "out_wfc_norm",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wfc_norm {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Specifies the electronic states to calculate the real-space wave function modulus (norm, or known as the envelope function) \\(|\\psi_i(\\boldsymbol{r})|\\) with state index \\(i\\) . The syntax and state selection rules are identical to out_pchg , but the output is the norm of the wave function. The outputs comprise multiple .cube files following the naming convention wfi[state]s[spin]k[kpoint].cube ."
      }
    ],
    "parent_section": null,
    "description": "Specifies the electronic states to calculate the real-space wave function modulus (norm, or known as the envelope function) \\(|\\psi_i(\\boldsymbol{r})|\\) with state index \\(i\\) . The syntax and state selection rules are identical to out_pchg , but the output is the norm of the wave function. The outputs comprise multiple .cube files following the naming convention wfi[state]s[spin]k[kpoint].cube ."
  },
  {
    "name": "out_wfc_re_im",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wfc_re_im {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Specifies the electronic states to calculate the real and imaginary parts of the wave function \\(\\text{Re}(\\psi_i(\\boldsymbol{r}))\\) and \\(\\text{Im}(\\psi_i(\\boldsymbol{r}))\\) with state index \\(i\\) . The syntax and state selection rules are identical to out_pchg , but the output contains both the real and imaginary components of the wave function. The outputs comprise multiple .cube files following the naming convention wfi[state]s[spin]k[kpoint][re/im].cube ."
      }
    ],
    "parent_section": null,
    "description": "Specifies the electronic states to calculate the real and imaginary parts of the wave function \\(\\text{Re}(\\psi_i(\\boldsymbol{r}))\\) and \\(\\text{Im}(\\psi_i(\\boldsymbol{r}))\\) with state index \\(i\\) . The syntax and state selection rules are identical to out_pchg , but the output contains both the real and imaginary components of the wave function. The outputs comprise multiple .cube files following the naming convention wfi[state]s[spin]k[kpoint][re/im].cube ."
  },
  {
    "name": "if_separate_k",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "if_separate_k {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Specifies whether to write the partial charge densities for all k-points to individual files or merge them. Warning : Enabling symmetry may produce unwanted results due to reduced k-point weights and symmetry operations in real space. Therefore when calculating partial charge densities, if you are not sure what you want exactly, it is strongly recommended to set symmetry = -1 . It is noteworthy that your symmetry setting should remain the same as that in the SCF procedure."
      }
    ],
    "parent_section": null,
    "description": "Specifies whether to write the partial charge densities for all k-points to individual files or merge them. Warning : Enabling symmetry may produce unwanted results due to reduced k-point weights and symmetry operations in real space. Therefore when calculating partial charge densities, if you are not sure what you want exactly, it is strongly recommended to set symmetry = -1 . It is noteworthy that your symmetry setting should remain the same as that in the SCF procedure."
  },
  {
    "name": "out_elf",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_elf {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0 3",
        "unit": null,
        "description": "Whether to output the electron localization function (ELF) in the folder OUT.${suffix} . The files are named as nspin = 1: ELF.cube: \\({\\rm{ELF}} = \\frac{1}{1+\\chi^2}\\) , \\(\\chi = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i}|^2} - \\frac{|\\nabla\\rho|^2}{8\\rho}}{\\frac{3}{10}(3\\pi^2)^{2/3}\\rho^{5/3}}\\) ; nspin = 2: ELF_SPIN1.cube, ELF_SPIN2.cube: \\({\\rm{ELF}}_\\sigma = \\frac{1}{1+\\chi_\\sigma^2}\\) , \\(\\chi_\\sigma = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i,\\sigma}|^2} - \\frac{|\\nabla\\rho_\\sigma|^"
      }
    ],
    "parent_section": null,
    "description": "Whether to output the electron localization function (ELF) in the folder OUT.${suffix} . The files are named as nspin = 1: ELF.cube: \\({\\rm{ELF}} = \\frac{1}{1+\\chi^2}\\) , \\(\\chi = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i}|^2} - \\frac{|\\nabla\\rho|^2}{8\\rho}}{\\frac{3}{10}(3\\pi^2)^{2/3}\\rho^{5/3}}\\) ; nspin = 2: ELF_SPIN1.cube, ELF_SPIN2.cube: \\({\\rm{ELF}}_\\sigma = \\frac{1}{1+\\chi_\\sigma^2}\\) , \\(\\chi_\\sigma = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i,\\sigma}|^2} - \\frac{|\\nabla\\rho_\\sigma|^"
  },
  {
    "name": "out_spillage",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_spillage {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "This output is only intentively needed by the ABACUS numerical atomic orbital generation workflow. This parameter is used to control whether to output the overlap integrals between truncated spherical Bessel functions (TSBFs) and plane-wave basis expanded wavefunctions (named as OVERLAP_Q ), and between TSBFs (named as OVERLAP_Sq ), also their first order derivatives. The output files are named starting with orb_matrix . A value of 2 would enable the output."
      }
    ],
    "parent_section": null,
    "description": "This output is only intentively needed by the ABACUS numerical atomic orbital generation workflow. This parameter is used to control whether to output the overlap integrals between truncated spherical Bessel functions (TSBFs) and plane-wave basis expanded wavefunctions (named as OVERLAP_Q ), and between TSBFs (named as OVERLAP_Sq ), also their first order derivatives. The output files are named starting with orb_matrix . A value of 2 would enable the output."
  },
  {
    "name": "dos_edelta_ev",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_edelta_ev {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "The step size in writing Density of States (DOS)"
      }
    ],
    "parent_section": null,
    "description": "The step size in writing Density of States (DOS)"
  },
  {
    "name": "dos_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.07",
        "unit": null,
        "description": "The width of the Gaussian factor when obtaining smeared Density of States (DOS)"
      }
    ],
    "parent_section": null,
    "description": "The width of the Gaussian factor when obtaining smeared Density of States (DOS)"
  },
  {
    "name": "dos_scale",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_scale {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "Defines the energy range of DOS output as (emax-emin)*(1+dos_scale), centered at (emax+emin)/2. This parameter will be used when dos_emin and dos_emax are not set."
      }
    ],
    "parent_section": null,
    "description": "Defines the energy range of DOS output as (emax-emin)*(1+dos_scale), centered at (emax+emin)/2. This parameter will be used when dos_emin and dos_emax are not set."
  },
  {
    "name": "dos_emin_ev",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_emin_ev {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "Minimal eigenenergy of \\(\\hat{H}\\)",
        "unit": null,
        "description": "The minimal range for Density of States (DOS) If set, “dos_scale” will be ignored."
      }
    ],
    "parent_section": null,
    "description": "The minimal range for Density of States (DOS) If set, “dos_scale” will be ignored."
  },
  {
    "name": "dos_emax_ev",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_emax_ev {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "Maximal eigenenergy of \\(\\hat{H}\\)",
        "unit": null,
        "description": "The maximal range for Density of States (DOS) If set, “dos_scale” will be ignored."
      }
    ],
    "parent_section": null,
    "description": "The maximal range for Density of States (DOS) If set, “dos_scale” will be ignored."
  },
  {
    "name": "dos_nche",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dos_nche {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "100",
        "unit": null,
        "description": "The order of Chebyshev expansions when using Stochastic Density Functional Theory (SDFT) to calculate DOS."
      }
    ],
    "parent_section": null,
    "description": "The order of Chebyshev expansions when using Stochastic Density Functional Theory (SDFT) to calculate DOS."
  },
  {
    "name": "stm_bias",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "stm_bias {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "The bias voltage used to calculate local density of states to simulate scanning tunneling microscope, see details in out_ldos . When using three parameters: The first parameter specifies the initial bias voltage value. The second parameter defines the voltage increment (step size between consecutive bias values). The third parameter determines the total number of voltage points"
      }
    ],
    "parent_section": null,
    "description": "The bias voltage used to calculate local density of states to simulate scanning tunneling microscope, see details in out_ldos . When using three parameters: The first parameter specifies the initial bias voltage value. The second parameter defines the voltage increment (step size between consecutive bias values). The third parameter determines the total number of voltage points"
  },
  {
    "name": "ldos_line",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ldos_line {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0 0.0 0.0 0.0 0.0 1.0 100",
        "unit": null,
        "description": "Specify the path of the three-dimensional space and display LDOS in the form of a two-dimensional color chart, see details in out_ldos . The first three paramenters are the direct coordinates of the start point, the next three paramenters are the direct coordinates of the end point, and the final one is the number of points along the path, whose default is 100."
      }
    ],
    "parent_section": null,
    "description": "Specify the path of the three-dimensional space and display LDOS in the form of a two-dimensional color chart, see details in out_ldos . The first three paramenters are the direct coordinates of the start point, the next three paramenters are the direct coordinates of the end point, and the final one is the number of points along the path, whose default is 100."
  },
  {
    "name": "bessel_nao_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_nao_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "ecutwfc",
        "unit": null,
        "description": "“Energy cutoff” (in Ry) of spherical Bessel functions. The number of spherical Bessel functions that constitute the radial parts of NAOs is determined by sqrt( bessel_nao_ecut ) \\(\\times\\) bessel_nao_rcut / \\(\\pi\\) ."
      }
    ],
    "parent_section": null,
    "description": "“Energy cutoff” (in Ry) of spherical Bessel functions. The number of spherical Bessel functions that constitute the radial parts of NAOs is determined by sqrt( bessel_nao_ecut ) \\(\\times\\) bessel_nao_rcut / \\(\\pi\\) ."
  },
  {
    "name": "bessel_nao_tolerence",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_nao_tolerence {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0e-12",
        "unit": null,
        "description": "Tolerance when searching for the zeros of spherical Bessel functions."
      }
    ],
    "parent_section": null,
    "description": "Tolerance when searching for the zeros of spherical Bessel functions."
  },
  {
    "name": "bessel_nao_rcut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_nao_rcut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "6.0",
        "unit": null,
        "description": "Cutoff radius (in Bohr) and the common node of spherical Bessel functions used to construct the NAOs."
      }
    ],
    "parent_section": null,
    "description": "Cutoff radius (in Bohr) and the common node of spherical Bessel functions used to construct the NAOs."
  },
  {
    "name": "bessel_nao_smooth",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_nao_smooth {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "If True, NAOs will be smoothed near the cutoff radius by \\(1-\\exp\\left(-\\frac{(r-r_{cut})^2}{2\\sigma^2}\\right)\\) . See bessel_nao_rcut for \\(r_{cut}\\) and bessel_nao_sigma for \\(\\sigma\\) ."
      }
    ],
    "parent_section": null,
    "description": "If True, NAOs will be smoothed near the cutoff radius by \\(1-\\exp\\left(-\\frac{(r-r_{cut})^2}{2\\sigma^2}\\right)\\) . See bessel_nao_rcut for \\(r_{cut}\\) and bessel_nao_sigma for \\(\\sigma\\) ."
  },
  {
    "name": "bessel_nao_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_nao_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "Smoothing range (in Bohr). See also bessel_nao_smooth ."
      }
    ],
    "parent_section": null,
    "description": "Smoothing range (in Bohr). See also bessel_nao_smooth ."
  },
  {
    "name": "deepks_out_labels",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_out_labels {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Print labels and descriptors for DeePKS in OUT.${suffix}. The names of these files start with “deepks”. 0 : No output. 1 : Output intermediate files needed during DeePKS training. 2 : Output target labels for label preperation. The label files are named as deepks_<property>.npy or deepks_<property>.csr , where the units and formats are the same as label files <property>.npy or <property>.csr required for training, except that the first dimension ( nframes ) is excluded. System structrue files ar"
      }
    ],
    "parent_section": null,
    "description": "Print labels and descriptors for DeePKS in OUT.${suffix}. The names of these files start with “deepks”. 0 : No output. 1 : Output intermediate files needed during DeePKS training. 2 : Output target labels for label preperation. The label files are named as deepks_<property>.npy or deepks_<property>.csr , where the units and formats are the same as label files <property>.npy or <property>.csr required for training, except that the first dimension ( nframes ) is excluded. System structrue files ar"
  },
  {
    "name": "deepks_out_freq_elec",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_out_freq_elec {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "When deepks_out_freq_elec is greater than 0, print labels and descriptors for DeePKS in OUT.${suffix}/DeePKS_Labels_Elec per deepks_out_freq_elec electronic iterations, with suffix _e* to distinguish different steps. Often used with deepks_out_labels equals 1."
      }
    ],
    "parent_section": null,
    "description": "When deepks_out_freq_elec is greater than 0, print labels and descriptors for DeePKS in OUT.${suffix}/DeePKS_Labels_Elec per deepks_out_freq_elec electronic iterations, with suffix _e* to distinguish different steps. Often used with deepks_out_labels equals 1."
  },
  {
    "name": "deepks_out_base",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_out_base {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Print labels and descriptors calculated by base functional ( determined by deepks_out_base ) and target functional ( determined by dft_functional ) for DeePKS in per deepks_out_freq_elec electronic iterations. The SCF process, labels and descriptors output of the target functional are all consistent with those when the target functional is used alone. The only additional output under this configuration is the labels of the base functional. Often used with deepks_out_labels equals 1."
      }
    ],
    "parent_section": null,
    "description": "Print labels and descriptors calculated by base functional ( determined by deepks_out_base ) and target functional ( determined by dft_functional ) for DeePKS in per deepks_out_freq_elec electronic iterations. The SCF process, labels and descriptors output of the target functional are all consistent with those when the target functional is used alone. The only additional output under this configuration is the labels of the base functional. Often used with deepks_out_labels equals 1."
  },
  {
    "name": "deepks_scf",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_scf {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "perform self-consistent field iteration in DeePKS method"
      }
    ],
    "parent_section": null,
    "description": "perform self-consistent field iteration in DeePKS method"
  },
  {
    "name": "deepks_equiv",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_equiv {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "whether to use equivariant version of DeePKS"
      }
    ],
    "parent_section": null,
    "description": "whether to use equivariant version of DeePKS"
  },
  {
    "name": "deepks_model",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_model {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "the path of the trained, traced neural network model file generated by deepks-kit"
      }
    ],
    "parent_section": null,
    "description": "the path of the trained, traced neural network model file generated by deepks-kit"
  },
  {
    "name": "bessel_descriptor_lmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_lmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2",
        "unit": null,
        "description": "the maximum angular momentum of the Bessel functions generated as the projectors in DeePKS"
      }
    ],
    "parent_section": null,
    "description": "the maximum angular momentum of the Bessel functions generated as the projectors in DeePKS"
  },
  {
    "name": "bessel_descriptor_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "same as ecutwfc",
        "unit": null,
        "description": "energy cutoff of Bessel functions"
      }
    ],
    "parent_section": null,
    "description": "energy cutoff of Bessel functions"
  },
  {
    "name": "bessel_descriptor_tolerence",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_tolerence {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0e-12",
        "unit": null,
        "description": "tolerance for searching the zeros of Bessel functions"
      }
    ],
    "parent_section": null,
    "description": "tolerance for searching the zeros of Bessel functions"
  },
  {
    "name": "bessel_descriptor_rcut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_rcut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "6.0",
        "unit": null,
        "description": "cutoff radius of Bessel functions"
      }
    ],
    "parent_section": null,
    "description": "cutoff radius of Bessel functions"
  },
  {
    "name": "bessel_descriptor_smooth",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_smooth {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "smooth the Bessel functions at radius cutoff"
      }
    ],
    "parent_section": null,
    "description": "smooth the Bessel functions at radius cutoff"
  },
  {
    "name": "bessel_descriptor_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "bessel_descriptor_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "smooth parameter at the cutoff radius of projectors"
      }
    ],
    "parent_section": null,
    "description": "smooth parameter at the cutoff radius of projectors"
  },
  {
    "name": "deepks_bandgap",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_bandgap {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "include bandgap label for DeePKS training 0: Don’t include bandgap label 1: Include target bandgap label (see deepks_band_range for more details) 2: Include multiple bandgap label (see deepks_band_range for more details) 3: Used for systems containing H atoms. Here HOMO is defined as the max occupation except H atoms and the bandgap label is the energy between HOMO and (HOMO + 1)"
      }
    ],
    "parent_section": null,
    "description": "include bandgap label for DeePKS training 0: Don’t include bandgap label 1: Include target bandgap label (see deepks_band_range for more details) 2: Include multiple bandgap label (see deepks_band_range for more details) 3: Used for systems containing H atoms. Here HOMO is defined as the max occupation except H atoms and the bandgap label is the energy between HOMO and (HOMO + 1)"
  },
  {
    "name": "deepks_band_range",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_band_range {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1 0",
        "unit": null,
        "description": "The first value should not be larger than the second one and the meaning differs in different cases below deepks_bandgap is 1: Bandgap label is the energy between LUMO + deepks_band_range[0] and LUMO + deepks_band_range[1] . If not set, it will calculate energy between HOMO and LUMO states. deepks_bandgap is 2: Bandgap labels are energies between HOMO and all states in range [ LUMO + deepks_band_range[0] , LUMO + deepks_band_range[1] ] (Thus there are deepks_band_range[1] - deepks_band_range[0] "
      }
    ],
    "parent_section": null,
    "description": "The first value should not be larger than the second one and the meaning differs in different cases below deepks_bandgap is 1: Bandgap label is the energy between LUMO + deepks_band_range[0] and LUMO + deepks_band_range[1] . If not set, it will calculate energy between HOMO and LUMO states. deepks_bandgap is 2: Bandgap labels are energies between HOMO and all states in range [ LUMO + deepks_band_range[0] , LUMO + deepks_band_range[1] ] (Thus there are deepks_band_range[1] - deepks_band_range[0] "
  },
  {
    "name": "deepks_v_delta",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_v_delta {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Include V_delta/V_delta_R (Hamiltonian in k/real space) label for DeePKS training. When deepks_out_labels is true and deepks_v_delta > 0 (k space), ABACUS will output deepks_hbase.npy , deepks_vdelta.npy and deepks_htot.npy (htot=hbase+vdelta). When deepks_out_labels is true and deepks_v_delta < 0 (real space), ABACUS will output deepks_hrtot.csr , deepks_hrdelta.csr . Some more files output for different settings. NOTICE: To match the unit Normally used in DeePKS, the unit of Hamiltonian in k s"
      }
    ],
    "parent_section": null,
    "description": "Include V_delta/V_delta_R (Hamiltonian in k/real space) label for DeePKS training. When deepks_out_labels is true and deepks_v_delta > 0 (k space), ABACUS will output deepks_hbase.npy , deepks_vdelta.npy and deepks_htot.npy (htot=hbase+vdelta). When deepks_out_labels is true and deepks_v_delta < 0 (real space), ABACUS will output deepks_hrtot.csr , deepks_hrdelta.csr . Some more files output for different settings. NOTICE: To match the unit Normally used in DeePKS, the unit of Hamiltonian in k s"
  },
  {
    "name": "deepks_out_unittest",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "deepks_out_unittest {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "generate files for constructing DeePKS unit test"
      }
    ],
    "parent_section": null,
    "description": "generate files for constructing DeePKS unit test"
  },
  {
    "name": "of_kinetic",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_kinetic {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "wt",
        "unit": null,
        "description": "The type of KEDF (kinetic energy density functional). Analytical functionals: wt : Wang-Teter. tf : Thomas-Fermi. vw : von Weizsäcker. tf+ : TF \\(\\rm{\\lambda}\\) vW, the parameter \\(\\rm{\\lambda}\\) can be set by of_vw_weight . lkt : Luo-Karasiev-Trickey. xwm : Xu-Wang-Ma Machine learning (ML) based functionals: ml : ML-based KEDF allows for greater flexibility, enabling users to set related ML model parameters themselves. see ML-KEDF: machine learning based kinetic energy density functional for OF"
      }
    ],
    "parent_section": null,
    "description": "The type of KEDF (kinetic energy density functional). Analytical functionals: wt : Wang-Teter. tf : Thomas-Fermi. vw : von Weizsäcker. tf+ : TF \\(\\rm{\\lambda}\\) vW, the parameter \\(\\rm{\\lambda}\\) can be set by of_vw_weight . lkt : Luo-Karasiev-Trickey. xwm : Xu-Wang-Ma Machine learning (ML) based functionals: ml : ML-based KEDF allows for greater flexibility, enabling users to set related ML model parameters themselves. see ML-KEDF: machine learning based kinetic energy density functional for OF"
  },
  {
    "name": "of_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "tn",
        "unit": null,
        "description": "The optimization method used in OFDFT. cg1 : Polak-Ribiere. Standard CG algorithm. cg2 : Hager-Zhang (generally faster than cg1). tn : Truncated Newton algorithm."
      }
    ],
    "parent_section": null,
    "description": "The optimization method used in OFDFT. cg1 : Polak-Ribiere. Standard CG algorithm. cg2 : Hager-Zhang (generally faster than cg1). tn : Truncated Newton algorithm."
  },
  {
    "name": "of_conv",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_conv {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "energy",
        "unit": null,
        "description": "Criterion used to check the convergence of OFDFT. energy : Ttotal energy changes less than of_tole . potential : The norm of potential is less than of_tolp . both : Both energy and potential must satisfy the convergence criterion."
      }
    ],
    "parent_section": null,
    "description": "Criterion used to check the convergence of OFDFT. energy : Ttotal energy changes less than of_tole . potential : The norm of potential is less than of_tolp . both : Both energy and potential must satisfy the convergence criterion."
  },
  {
    "name": "of_tole",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_tole {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "2e-6",
        "unit": null,
        "description": "Tolerance of the energy change for determining the convergence."
      }
    ],
    "parent_section": null,
    "description": "Tolerance of the energy change for determining the convergence."
  },
  {
    "name": "of_tolp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_tolp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-5",
        "unit": null,
        "description": "Tolerance of potential for determining the convergence."
      }
    ],
    "parent_section": null,
    "description": "Tolerance of potential for determining the convergence."
  },
  {
    "name": "of_tf_weight",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_tf_weight {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Weight of TF KEDF (kinetic energy density functional)."
      }
    ],
    "parent_section": null,
    "description": "Weight of TF KEDF (kinetic energy density functional)."
  },
  {
    "name": "of_vw_weight",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_vw_weight {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Weight of vW KEDF (kinetic energy density functional)."
      }
    ],
    "parent_section": null,
    "description": "Weight of vW KEDF (kinetic energy density functional)."
  },
  {
    "name": "of_wt_alpha",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_wt_alpha {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "\\(5/6\\)",
        "unit": null,
        "description": "Parameter alpha of WT KEDF (kinetic energy density functional)."
      }
    ],
    "parent_section": null,
    "description": "Parameter alpha of WT KEDF (kinetic energy density functional)."
  },
  {
    "name": "of_wt_beta",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_wt_beta {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "\\(5/6\\)",
        "unit": null,
        "description": "Parameter beta of WT KEDF (kinetic energy density functional)."
      }
    ],
    "parent_section": null,
    "description": "Parameter beta of WT KEDF (kinetic energy density functional)."
  },
  {
    "name": "of_wt_rho0",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_wt_rho0 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "The average density of system."
      }
    ],
    "parent_section": null,
    "description": "The average density of system."
  },
  {
    "name": "of_hold_rho0",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_hold_rho0 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to fix the average density rho0. True : rho0 will be fixed even if the volume of system has changed, it will be set to True automatically if of_wt_rho0 is not zero. False : rho0 will change if volume of system has changed."
      }
    ],
    "parent_section": null,
    "description": "Whether to fix the average density rho0. True : rho0 will be fixed even if the volume of system has changed, it will be set to True automatically if of_wt_rho0 is not zero. False : rho0 will change if volume of system has changed."
  },
  {
    "name": "of_lkt_a",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_lkt_a {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.3",
        "unit": null,
        "description": "Parameter a of LKT KEDF (kinetic energy density functional)."
      }
    ],
    "parent_section": null,
    "description": "Parameter a of LKT KEDF (kinetic energy density functional)."
  },
  {
    "name": "of_xwm_rho_ref",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_xwm_rho_ref {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Reference charge density for XWM kinetic energy functional. If set to 0, the program will use average charge density."
      }
    ],
    "parent_section": null,
    "description": "Reference charge density for XWM kinetic energy functional. If set to 0, the program will use average charge density."
  },
  {
    "name": "of_xwm_kappa",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_xwm_kappa {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Parameter \\(\\kappa\\) for XWM kinetic energy functional. See PHYSICAL REVIEW B 100, 205132 (2019) for optimal values."
      }
    ],
    "parent_section": null,
    "description": "Parameter \\(\\kappa\\) for XWM kinetic energy functional. See PHYSICAL REVIEW B 100, 205132 (2019) for optimal values."
  },
  {
    "name": "of_read_kernel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_read_kernel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to read in the kernel file. True : The kernel of WT KEDF (kinetic energy density functional) will be filled from the file specified by of_kernel_file . False : The kernel of WT KEDF (kinetic energy density functional) will be filled from formula."
      }
    ],
    "parent_section": null,
    "description": "Whether to read in the kernel file. True : The kernel of WT KEDF (kinetic energy density functional) will be filled from the file specified by of_kernel_file . False : The kernel of WT KEDF (kinetic energy density functional) will be filled from formula."
  },
  {
    "name": "of_kernel_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_kernel_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "WTkernel.txt",
        "unit": null,
        "description": "The name of WT kernel file."
      }
    ],
    "parent_section": null,
    "description": "The name of WT kernel file."
  },
  {
    "name": "of_full_pw",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_full_pw {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to use full planewaves. True : Ecut will be ignored while collecting planewaves, so that all planewaves will be used in FFT. False : Only use the planewaves inside ecut, the same as KSDFT."
      }
    ],
    "parent_section": null,
    "description": "Whether to use full planewaves. True : Ecut will be ignored while collecting planewaves, so that all planewaves will be used in FFT. False : Only use the planewaves inside ecut, the same as KSDFT."
  },
  {
    "name": "of_full_pw_dim",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_full_pw_dim {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Specify the parity of FFT dimensions. 0 : either odd or even. 1 : odd only. 2 : even only. Note: Even dimensions may cause slight errors in FFT. It should be ignorable in ofdft calculation, but it may make Cardinal B-spline interpolation unstable, so please set of_full_pw_dim = 1 if nbspline != -1 ."
      }
    ],
    "parent_section": null,
    "description": "Specify the parity of FFT dimensions. 0 : either odd or even. 1 : odd only. 2 : even only. Note: Even dimensions may cause slight errors in FFT. It should be ignorable in ofdft calculation, but it may make Cardinal B-spline interpolation unstable, so please set of_full_pw_dim = 1 if nbspline != -1 ."
  },
  {
    "name": "of_ml_gene_data",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_gene_data {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Controls the generation of machine learning training data. When enabled, training data in .npy format will be saved in the directory OUT.${suffix}/MLKEDF_Descriptors/ . The generated descriptors are categorized as follows: Local/Semilocal Descriptors. Files are named as {var}.npy , where {var} corresponds to the descriptor type: gamma : Enabled by of_ml_gamma p : Enabled by of_ml_p q : Enabled by of_ml_q tanhp : Enabled by of_ml_tanhp tanhq : Enabled by of_ml_tanhq Nonlocal Descriptors generated"
      }
    ],
    "parent_section": null,
    "description": "Controls the generation of machine learning training data. When enabled, training data in .npy format will be saved in the directory OUT.${suffix}/MLKEDF_Descriptors/ . The generated descriptors are categorized as follows: Local/Semilocal Descriptors. Files are named as {var}.npy , where {var} corresponds to the descriptor type: gamma : Enabled by of_ml_gamma p : Enabled by of_ml_p q : Enabled by of_ml_q tanhp : Enabled by of_ml_tanhp tanhq : Enabled by of_ml_tanhq Nonlocal Descriptors generated"
  },
  {
    "name": "of_ml_device",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_device {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "cpu",
        "unit": null,
        "description": "Run Neural Network on GPU or CPU. cpu : CPU gpu : GPU"
      }
    ],
    "parent_section": null,
    "description": "Run Neural Network on GPU or CPU. cpu : CPU gpu : GPU"
  },
  {
    "name": "of_ml_feg",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_feg {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "The method to incorporate the Free Electron Gas (FEG) limit: \\(F_\\theta |_{\\rm{FEG}} = 1\\) , where \\(F_\\theta\\) is enhancement factor of Pauli energy. 0 : Do not incorporate the FEG limit. 1 : Incorporate the FEG limit by translation: \\(F_\\theta = F^{\\rm{NN}}_\\theta - F^{\\rm{NN}}_\\theta|_{\\rm{FEG}} + 1\\) . 3 : Incorporate the FEG limit by nonlinear transformation: \\(F_\\theta = f(F^{\\rm{NN}}_\\theta - F^{\\rm{NN}}_\\theta|_{\\rm{FEG}} + \\ln(e - 1))\\) , where \\(f = \\ln(1 + e^x)\\) is softplus function,"
      }
    ],
    "parent_section": null,
    "description": "The method to incorporate the Free Electron Gas (FEG) limit: \\(F_\\theta |_{\\rm{FEG}} = 1\\) , where \\(F_\\theta\\) is enhancement factor of Pauli energy. 0 : Do not incorporate the FEG limit. 1 : Incorporate the FEG limit by translation: \\(F_\\theta = F^{\\rm{NN}}_\\theta - F^{\\rm{NN}}_\\theta|_{\\rm{FEG}} + 1\\) . 3 : Incorporate the FEG limit by nonlinear transformation: \\(F_\\theta = f(F^{\\rm{NN}}_\\theta - F^{\\rm{NN}}_\\theta|_{\\rm{FEG}} + \\ln(e - 1))\\) , where \\(f = \\ln(1 + e^x)\\) is softplus function,"
  },
  {
    "name": "of_ml_nkernel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_nkernel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Number of kernel functions."
      }
    ],
    "parent_section": null,
    "description": "Number of kernel functions."
  },
  {
    "name": "of_ml_kernel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_kernel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the type of the \\(i\\) -th kernel function. 1 : Wang-Teter kernel function. 2 : Modified Yukawa function: \\(k_{\\rm{F}}^2\\frac{\\exp{({-\\alpha k_{\\rm{F}}|\\mathbf{r}-\\mathbf{r}'|})}}{|\\mathbf{r}-\\mathbf{r}'|}\\) , and \\(\\alpha\\) is specified by of_ml_yukawa_alpha . 3 : Truncated kinetic kernel (TKK), the file containing TKK is specified by of_ml_kernel_file ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the type of the \\(i\\) -th kernel function. 1 : Wang-Teter kernel function. 2 : Modified Yukawa function: \\(k_{\\rm{F}}^2\\frac{\\exp{({-\\alpha k_{\\rm{F}}|\\mathbf{r}-\\mathbf{r}'|})}}{|\\mathbf{r}-\\mathbf{r}'|}\\) , and \\(\\alpha\\) is specified by of_ml_yukawa_alpha . 3 : Truncated kinetic kernel (TKK), the file containing TKK is specified by of_ml_kernel_file ."
  },
  {
    "name": "of_ml_kernel_scaling",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_kernel_scaling {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the RECIPROCAL of scaling parameter \\(\\lambda\\) of the \\(i\\) -th kernel function. \\(w_i(\\mathbf{r}-\\mathbf{r}') = \\lambda^3 w_i'(\\lambda(\\mathbf{r}-\\mathbf{r}'))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the RECIPROCAL of scaling parameter \\(\\lambda\\) of the \\(i\\) -th kernel function. \\(w_i(\\mathbf{r}-\\mathbf{r}') = \\lambda^3 w_i'(\\lambda(\\mathbf{r}-\\mathbf{r}'))\\) ."
  },
  {
    "name": "of_ml_yukawa_alpha",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_yukawa_alpha {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the parameter \\(\\alpha\\) of \\(i\\) -th kernel function. ONLY used for Yukawa kernel function."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the parameter \\(\\alpha\\) of \\(i\\) -th kernel function. ONLY used for Yukawa kernel function."
  },
  {
    "name": "of_ml_kernel_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_kernel_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the file containint the \\(i\\) -th kernel function. ONLY used for TKK."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the file containint the \\(i\\) -th kernel function. ONLY used for TKK."
  },
  {
    "name": "of_ml_gamma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_gamma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Local descriptor: \\(\\gamma(\\mathbf{r}) = (\\rho(\\mathbf{r}) / \\rho_0)^{1/3}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Local descriptor: \\(\\gamma(\\mathbf{r}) = (\\rho(\\mathbf{r}) / \\rho_0)^{1/3}\\) ."
  },
  {
    "name": "of_ml_p",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_p {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Semi-local descriptor: \\(p(\\mathbf{r}) = \\frac{|\\nabla \\rho(\\mathbf{r})|^2} {[2 (3 \\pi^2)^{1/3} \\rho^{4/3}(\\mathbf{r})]^2}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Semi-local descriptor: \\(p(\\mathbf{r}) = \\frac{|\\nabla \\rho(\\mathbf{r})|^2} {[2 (3 \\pi^2)^{1/3} \\rho^{4/3}(\\mathbf{r})]^2}\\) ."
  },
  {
    "name": "of_ml_q",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_q {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Semi-local descriptor: \\(q(\\mathbf{r}) = \\frac{\\nabla^2 \\rho(\\mathbf{r})} {[4 (3 \\pi^2)^{2/3} \\rho^{5/3}(\\mathbf{r})]}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Semi-local descriptor: \\(q(\\mathbf{r}) = \\frac{\\nabla^2 \\rho(\\mathbf{r})} {[4 (3 \\pi^2)^{2/3} \\rho^{5/3}(\\mathbf{r})]}\\) ."
  },
  {
    "name": "of_ml_tanhp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Semi-local descriptor: \\(\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Semi-local descriptor: \\(\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_tanhq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Semi-local descriptor: \\(\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Semi-local descriptor: \\(\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_chi_p",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_chi_p {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Hyperparameter \\(\\chi_p\\) : \\(\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Hyperparameter \\(\\chi_p\\) : \\(\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_chi_q",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_chi_q {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "False",
        "unit": null,
        "description": "Hyperparameter \\(\\chi_q\\) : \\(\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Hyperparameter \\(\\chi_q\\) : \\(\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_gammanl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_gammanl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\gamma_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\gamma(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\gamma_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\gamma(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_pnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_pnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(p_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') p(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(p_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') p(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_qnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_qnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(q_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') q(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(q_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') q(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_xi",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_xi {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\xi(\\mathbf{r}) = \\frac{\\int{w_i(\\mathbf{r}-\\mathbf{r}') \\rho^{1/3}(\\mathbf{r}') dr'}}{\\rho^{1/3}(\\mathbf{r})}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\xi(\\mathbf{r}) = \\frac{\\int{w_i(\\mathbf{r}-\\mathbf{r}') \\rho^{1/3}(\\mathbf{r}') dr'}}{\\rho^{1/3}(\\mathbf{r})}\\) ."
  },
  {
    "name": "of_ml_tanhxi",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhxi {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_tanhxi_nl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhxi_nl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{\\xi}(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{\\xi}(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_tanh_pnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanh_pnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}\\) ."
  },
  {
    "name": "of_ml_tanh_qnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanh_qnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}\\) ."
  },
  {
    "name": "of_ml_tanhp_nl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhp_nl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{p}(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{p}(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_tanhq_nl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_tanhq_nl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{q}(\\mathbf{r}') dr'}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element controls the non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{q}(\\mathbf{r}') dr'}\\) ."
  },
  {
    "name": "of_ml_chi_xi",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_chi_xi {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_\\xi\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_\\xi\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))\\) ."
  },
  {
    "name": "of_ml_chi_pnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_chi_pnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_{p_{\\rm{nl}}}\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_{p_{\\rm{nl}}}\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}\\) ."
  },
  {
    "name": "of_ml_chi_qnl",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_chi_qnl {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_{q_{\\rm{nl}}}\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Containing nkernel (see of_ml_nkernel ) elements. The \\(i\\) -th element specifies the hyperparameter \\(\\chi_{q_{\\rm{nl}}}\\) of non-local descriptor defined by the \\(i\\) -th kernel function \\(w_i(\\mathbf{r}-\\mathbf{r}')\\) : \\(\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}\\) ."
  },
  {
    "name": "of_ml_local_test",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_ml_local_test {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "FOR TEST. Read in the density, and output the F and Pauli potential."
      }
    ],
    "parent_section": null,
    "description": "FOR TEST. Read in the density, and output the F and Pauli potential."
  },
  {
    "name": "of_cd",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_cd {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Added the current dependent(CD) potential. ( https://doi.org/10.1103/PhysRevB.98.144302 ) True: Added the CD potential. False: Not added the CD potential."
      }
    ],
    "parent_section": null,
    "description": "Added the current dependent(CD) potential. ( https://doi.org/10.1103/PhysRevB.98.144302 ) True: Added the CD potential. False: Not added the CD potential."
  },
  {
    "name": "of_mcd_alpha",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "of_mcd_alpha {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "The value of the parameter alpha in modified CD potential method. mCDPotenial=alpha*CDPotenial(proposed in paper PhysRevB.98.144302)"
      }
    ],
    "parent_section": null,
    "description": "The value of the parameter alpha in modified CD potential method. mCDPotenial=alpha*CDPotenial(proposed in paper PhysRevB.98.144302)"
  },
  {
    "name": "efield_flag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "efield_flag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Added the electric field. True: A saw-like potential simulating an electric field is added to the bare ionic potential. False: Not added the electric field."
      }
    ],
    "parent_section": null,
    "description": "Added the electric field. True: A saw-like potential simulating an electric field is added to the bare ionic potential. False: Not added the electric field."
  },
  {
    "name": "dip_cor_flag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dip_cor_flag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": null,
        "unit": null,
        "description": "Added a dipole correction to the bare ionic potential. True：A dipole correction is also added to the bare ionic potential. False: A dipole correction is not added to the bare ionic potential."
      }
    ],
    "parent_section": null,
    "description": "Added a dipole correction to the bare ionic potential. True：A dipole correction is also added to the bare ionic potential. False: A dipole correction is not added to the bare ionic potential."
  },
  {
    "name": "efield_dir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "efield_dir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2",
        "unit": null,
        "description": "The direction of the electric field or dipole correction is parallel to the reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points, efield_dir can set to 0, 1 or 2. 0: parallel to \\(b_1=\\frac{2\\pi(a_2\\times a_3)}{a_1\\cdot(a_2\\times a_3)}\\) 1: parallel to \\(b_2=\\frac{2\\pi(a_3\\times a_1)}{a_1\\cdot(a_2\\times a_3)}\\) 2: parallel to \\(b_3=\\frac{2\\pi(a_1\\times a_2)}{a_1\\cdot(a_2\\times a_3)}\\)"
      }
    ],
    "parent_section": null,
    "description": "The direction of the electric field or dipole correction is parallel to the reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points, efield_dir can set to 0, 1 or 2. 0: parallel to \\(b_1=\\frac{2\\pi(a_2\\times a_3)}{a_1\\cdot(a_2\\times a_3)}\\) 1: parallel to \\(b_2=\\frac{2\\pi(a_3\\times a_1)}{a_1\\cdot(a_2\\times a_3)}\\) 2: parallel to \\(b_3=\\frac{2\\pi(a_1\\times a_2)}{a_1\\cdot(a_2\\times a_3)}\\)"
  },
  {
    "name": "efield_pos_max",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "efield_pos_max {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "Autoset to center of vacuum - width of vacuum / 20",
        "unit": null,
        "description": "Position of the maximum of the saw-like potential along crystal axis efield_dir, within the unit cell, 0 <= efield_pos_max < 1."
      }
    ],
    "parent_section": null,
    "description": "Position of the maximum of the saw-like potential along crystal axis efield_dir, within the unit cell, 0 <= efield_pos_max < 1."
  },
  {
    "name": "efield_pos_dec",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "efield_pos_dec {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "Autoset to width of vacuum / 10",
        "unit": null,
        "description": "Zone in the unit cell where the saw-like potential decreases, 0 < efield_pos_dec < 1."
      }
    ],
    "parent_section": null,
    "description": "Zone in the unit cell where the saw-like potential decreases, 0 < efield_pos_dec < 1."
  },
  {
    "name": "efield_amp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "efield_amp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "Amplitude of the electric field. The saw-like potential increases with slope efield_amp in the region from efield_pos_max+efield_pos_dec-1) to (efield_pos_max), then decreases until (efield_pos_max+efield_pos_dec), in units of the crystal vector efield_dir."
      }
    ],
    "parent_section": null,
    "description": "Amplitude of the electric field. The saw-like potential increases with slope efield_amp in the region from efield_pos_max+efield_pos_dec-1) to (efield_pos_max), then decreases until (efield_pos_max+efield_pos_dec), in units of the crystal vector efield_dir."
  },
  {
    "name": "gate_flag",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "gate_flag {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Controls the addition of compensating charge by a charged plate for charged cells. true: A charged plate is placed at the zgate position to add compensating charge. The direction is determined by efield_dir . false: No compensating charge is added."
      }
    ],
    "parent_section": null,
    "description": "Controls the addition of compensating charge by a charged plate for charged cells. true: A charged plate is placed at the zgate position to add compensating charge. The direction is determined by efield_dir . false: No compensating charge is added."
  },
  {
    "name": "zgate",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "zgate {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.5",
        "unit": null,
        "description": "Position of the charged plate in the unit cell"
      }
    ],
    "parent_section": null,
    "description": "Position of the charged plate in the unit cell"
  },
  {
    "name": "block",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "block {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Controls the addition of a potential barrier to prevent electron spillover. true: A potential barrier is added from block_down to block_up with a height of block_height . If dip_cor_flag is set to true, efield_pos_dec is used to smoothly increase and decrease the potential barrier. false: No potential barrier is added."
      }
    ],
    "parent_section": null,
    "description": "Controls the addition of a potential barrier to prevent electron spillover. true: A potential barrier is added from block_down to block_up with a height of block_height . If dip_cor_flag is set to true, efield_pos_dec is used to smoothly increase and decrease the potential barrier. false: No potential barrier is added."
  },
  {
    "name": "block_down",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "block_down {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.45",
        "unit": null,
        "description": "Lower beginning of the potential barrier"
      }
    ],
    "parent_section": null,
    "description": "Lower beginning of the potential barrier"
  },
  {
    "name": "block_up",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "block_up {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.55",
        "unit": null,
        "description": "Upper beginning of the potential barrier"
      }
    ],
    "parent_section": null,
    "description": "Upper beginning of the potential barrier"
  },
  {
    "name": "block_height",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "block_height {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "Height of the potential barrier"
      }
    ],
    "parent_section": null,
    "description": "Height of the potential barrier"
  },
  {
    "name": "exx_fock_alpha",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_fock_alpha {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "see hybrid_func_params",
        "unit": null,
        "description": "Fraction of full-ranged Fock exchange 1/r ( \\(\\alpha\\) ) in range-separated hybrid funtionals, so that \\(E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Fraction of full-ranged Fock exchange 1/r ( \\(\\alpha\\) ) in range-separated hybrid funtionals, so that \\(E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}\\) ."
  },
  {
    "name": "exx_erfc_alpha",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_erfc_alpha {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "see hybrid_func_params",
        "unit": null,
        "description": "Fraction of short-ranged Fock exchange erfc(wr)/r ( \\(\\beta\\) ) in range-separated hybrid funtionals, so that \\(E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Fraction of short-ranged Fock exchange erfc(wr)/r ( \\(\\beta\\) ) in range-separated hybrid funtionals, so that \\(E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}\\) ."
  },
  {
    "name": "exx_erfc_omega",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_erfc_omega {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "see hybrid_func_params",
        "unit": null,
        "description": "Range-separation parameter in exchange, such that \\(1/r=\\text{erfc}(\\omega r)/r+\\text{erf}(\\omega r)/r\\)"
      }
    ],
    "parent_section": null,
    "description": "Range-separation parameter in exchange, such that \\(1/r=\\text{erfc}(\\omega r)/r+\\text{erf}(\\omega r)/r\\)"
  },
  {
    "name": "exx_separate_loop",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_separate_loop {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "There are two types of iterative approaches provided by ABACUS to evaluate Fock exchange. False: Start with a GGA-Loop, and then Hybrid-Loop, in which EXX Hamiltonian \\(H_{exx}\\) is updated with electronic iterations. True: A two-step method is employed, i.e. in the inner iterations, density matrix is updated, while in the outer iterations, \\(H_{exx}\\) is calculated based on density matrix that converges in the inner iteration."
      }
    ],
    "parent_section": null,
    "description": "There are two types of iterative approaches provided by ABACUS to evaluate Fock exchange. False: Start with a GGA-Loop, and then Hybrid-Loop, in which EXX Hamiltonian \\(H_{exx}\\) is updated with electronic iterations. True: A two-step method is employed, i.e. in the inner iterations, density matrix is updated, while in the outer iterations, \\(H_{exx}\\) is calculated based on density matrix that converges in the inner iteration."
  },
  {
    "name": "exx_hybrid_step",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_hybrid_step {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "100",
        "unit": null,
        "description": "The maximal iteration number of the outer-loop, where the Fock exchange is calculated"
      }
    ],
    "parent_section": null,
    "description": "The maximal iteration number of the outer-loop, where the Fock exchange is calculated"
  },
  {
    "name": "exx_mixing_beta",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_mixing_beta {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Mixing parameter for densty matrix in each iteration of the outer-loop"
      }
    ],
    "parent_section": null,
    "description": "Mixing parameter for densty matrix in each iteration of the outer-loop"
  },
  {
    "name": "exx_fock_lambda",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_fock_lambda {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.3",
        "unit": null,
        "description": "It is used to compensate for divergence points at G=0 in the evaluation of Fock exchange using lcao_in_pw method."
      }
    ],
    "parent_section": null,
    "description": "It is used to compensate for divergence points at G=0 in the evaluation of Fock exchange using lcao_in_pw method."
  },
  {
    "name": "exx_pca_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_pca_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-4",
        "unit": null,
        "description": "To accelerate the evaluation of four-center integrals ( \\(ik|jl\\) ), the product of atomic orbitals are expanded in the basis of auxiliary basis functions (ABF): \\(\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}\\) . The size of the ABF (i.e. number of \\(P_{a}\\) ) is reduced using principal component analysis. When a large PCA threshold is used, the number of ABF will be reduced, hence the calculation becomes faster. However, this comes at the cost of computational accuracy. A relatively safe choic"
      }
    ],
    "parent_section": null,
    "description": "To accelerate the evaluation of four-center integrals ( \\(ik|jl\\) ), the product of atomic orbitals are expanded in the basis of auxiliary basis functions (ABF): \\(\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}\\) . The size of the ABF (i.e. number of \\(P_{a}\\) ) is reduced using principal component analysis. When a large PCA threshold is used, the number of ABF will be reduced, hence the calculation becomes faster. However, this comes at the cost of computational accuracy. A relatively safe choic"
  },
  {
    "name": "exx_c_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_c_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-4",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . Smaller components (less than exx_c_threshold) of the \\(C^{a}_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . Smaller components (less than exx_c_threshold) of the \\(C^{a}_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
  },
  {
    "name": "exx_cs_inv_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_cs_inv_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1",
        "unit": null,
        "description": "By default, the Coulomb matrix inversion required for obtaining LRI coefficients is performed using LU decomposition. However, this approach may suffer from numerical instabilities when a large set of auxiliary basis functions (ABFs) is employed. When exx_cs_inv_thr > 0 , the inversion is instead carried out via matrix diagonalization. Eigenvalues smaller than exx_cs_inv_thr are discarded to improve numerical stability. A relatively safe and commonly recommended value is 1e-5 ."
      }
    ],
    "parent_section": null,
    "description": "By default, the Coulomb matrix inversion required for obtaining LRI coefficients is performed using LU decomposition. However, this approach may suffer from numerical instabilities when a large set of auxiliary basis functions (ABFs) is employed. When exx_cs_inv_thr > 0 , the inversion is instead carried out via matrix diagonalization. Eigenvalues smaller than exx_cs_inv_thr are discarded to improve numerical stability. A relatively safe and commonly recommended value is 1e-5 ."
  },
  {
    "name": "exx_v_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_v_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-1",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no trunca"
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no trunca"
  },
  {
    "name": "exx_dm_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_dm_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-4",
        "unit": null,
        "description": "The Fock exchange can be expressed as \\(\\sum_{k,l}(ik|jl)D_{kl}\\) where D is the density matrix. Smaller values of the density matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
      }
    ],
    "parent_section": null,
    "description": "The Fock exchange can be expressed as \\(\\sum_{k,l}(ik|jl)D_{kl}\\) where D is the density matrix. Smaller values of the density matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
  },
  {
    "name": "exx_c_grad_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_c_grad_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-4",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . \\(\\nabla C^{a}_{ik}\\) is used in force. Smaller components (less than exx_c_grad_threshold) of the \\(\\nabla C^{a}_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . \\(\\nabla C^{a}_{ik}\\) is used in force. Smaller components (less than exx_c_grad_threshold) of the \\(\\nabla C^{a}_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
  },
  {
    "name": "exx_v_grad_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_v_grad_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-1",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. \\(\\nabla V_{ab}\\) is used in force. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the"
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. \\(\\nabla V_{ab}\\) is used in force. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the"
  },
  {
    "name": "exx_c_grad_r_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_c_grad_r_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-4",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . \\(\\nabla C^{a}_{ik} * R_{ik}\\) is used in stress. Smaller components (less than exx_c_grad_r_threshold) of the \\(\\nabla C^{a}_{ik} * R_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . \\(\\nabla C^{a}_{ik} * R_{ik}\\) is used in stress. Smaller components (less than exx_c_grad_r_threshold) of the \\(\\nabla C^{a}_{ik} * R_{ik}\\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4."
  },
  {
    "name": "exx_v_grad_r_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_v_grad_r_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-1",
        "unit": null,
        "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. \\(\\nabla V_{ab} *R_{ab}\\) is used in force and stress. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively"
      }
    ],
    "parent_section": null,
    "description": "See also the entry exx_pca_threshold . With the approximation \\(\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}\\) , the four-center integral in Fock exchange is expressed as \\((ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\\) , where \\(V_{ab}=(P_{a}|P_{b})\\) is a double-center integral. \\(\\nabla V_{ab} *R_{ab}\\) is used in force and stress. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively"
  },
  {
    "name": "exx_ccp_threshold",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_ccp_threshold {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-8",
        "unit": null,
        "description": "It is related to the cutoff of on-site Coulomb potentials. (Currently not used)"
      }
    ],
    "parent_section": null,
    "description": "It is related to the cutoff of on-site Coulomb potentials. (Currently not used)"
  },
  {
    "name": "exx_ccp_rmesh_times",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_ccp_rmesh_times {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "5: if dft_functional ==hf/pbe0/scan0/muller/power/wp22 1.5: if dft_functional ==hse/cwp22 1: else",
        "unit": null,
        "description": "This parameter determines how many times larger the radial mesh required for calculating Columb potential is to that of atomic orbitals. The value should be larger than 0. Reducing this value can effectively increase the speed of self-consistent calculations using hybrid functionals."
      }
    ],
    "parent_section": null,
    "description": "This parameter determines how many times larger the radial mesh required for calculating Columb potential is to that of atomic orbitals. The value should be larger than 0. Reducing this value can effectively increase the speed of self-consistent calculations using hybrid functionals."
  },
  {
    "name": "exx_opt_orb_lmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_opt_orb_lmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "The maximum l of the spherical Bessel functions, when the radial part of opt-ABFs are generated as linear combinations of spherical Bessel functions. A reasonable choice is 2."
      }
    ],
    "parent_section": null,
    "description": "The maximum l of the spherical Bessel functions, when the radial part of opt-ABFs are generated as linear combinations of spherical Bessel functions. A reasonable choice is 2."
  },
  {
    "name": "exx_opt_orb_ecut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_opt_orb_ecut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "The cut-off of plane wave expansion, when the plane wave basis is used to optimize the radial ABFs. A reasonable choice is 60."
      }
    ],
    "parent_section": null,
    "description": "The cut-off of plane wave expansion, when the plane wave basis is used to optimize the radial ABFs. A reasonable choice is 60."
  },
  {
    "name": "exx_opt_orb_tolerence",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_opt_orb_tolerence {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1E-12",
        "unit": null,
        "description": "The threshold when solving for the zeros of spherical Bessel functions. A reasonable choice is 1e-12."
      }
    ],
    "parent_section": null,
    "description": "The threshold when solving for the zeros of spherical Bessel functions. A reasonable choice is 1e-12."
  },
  {
    "name": "exx_real_number",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_real_number {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "depends on the gamma_only option True: if gamma_only False: else",
        "unit": null,
        "description": "True: Enforce LibRI to use double data type. False: Enforce LibRI to use complex data type. Setting it to True can effectively improve the speed of self-consistent calculations with hybrid functionals."
      }
    ],
    "parent_section": null,
    "description": "True: Enforce LibRI to use double data type. False: Enforce LibRI to use complex data type. Setting it to True can effectively improve the speed of self-consistent calculations with hybrid functionals."
  },
  {
    "name": "exx_singularity_correction",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_singularity_correction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "default",
        "unit": null,
        "description": "spencer: see Phys. Rev. B 77, 193110 (2008). revised_spencer: see Phys. Rev. Mater. 5, 013807 (2021). Set the scheme of Coulomb singularity correction."
      }
    ],
    "parent_section": null,
    "description": "spencer: see Phys. Rev. B 77, 193110 (2008). revised_spencer: see Phys. Rev. Mater. 5, 013807 (2021). Set the scheme of Coulomb singularity correction."
  },
  {
    "name": "rpa_ccp_rmesh_times",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "rpa_ccp_rmesh_times {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "10",
        "unit": null,
        "description": "How many times larger the radial mesh required is to that of atomic orbitals in the postprocess calculation of the bare Coulomb matrix for RPA, GW, etc."
      }
    ],
    "parent_section": null,
    "description": "How many times larger the radial mesh required is to that of atomic orbitals in the postprocess calculation of the bare Coulomb matrix for RPA, GW, etc."
  },
  {
    "name": "exx_symmetry_realspace",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_symmetry_realspace {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "False: only rotate k-space density matrix D(k) from irreducible k-points to accelerate diagonalization True: rotate both D(k) and Hexx® to accelerate both diagonalization and EXX calculation"
      }
    ],
    "parent_section": null,
    "description": "False: only rotate k-space density matrix D(k) from irreducible k-points to accelerate diagonalization True: rotate both D(k) and Hexx® to accelerate both diagonalization and EXX calculation"
  },
  {
    "name": "out_ri_cv",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_ri_cv {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Whether to output the coefficient tensor C® and ABFs-representation Coulomb matrix V® for each atom pair and cell in real space."
      }
    ],
    "parent_section": null,
    "description": "Whether to output the coefficient tensor C® and ABFs-representation Coulomb matrix V® for each atom pair and cell in real space."
  },
  {
    "name": "exxace",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exxace {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to use the ACE method ( https://doi.org/10.1021/acs.jctc.6b00092 ) to accelerate the calculation the Fock exchange matrix. Should be set to true most of the time. True: Use the ACE method to calculate the Fock exchange operator. False: Use the traditional method to calculate the Fock exchange operator."
      }
    ],
    "parent_section": null,
    "description": "Whether to use the ACE method ( https://doi.org/10.1021/acs.jctc.6b00092 ) to accelerate the calculation the Fock exchange matrix. Should be set to true most of the time. True: Use the ACE method to calculate the Fock exchange operator. False: Use the traditional method to calculate the Fock exchange operator."
  },
  {
    "name": "exx_gamma_extrapolation",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_gamma_extrapolation {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to use the gamma point extrapolation method to calculate the Fock exchange operator. See https://doi.org/10.1103/PhysRevB.79.205114 for details. Should be set to true most of the time."
      }
    ],
    "parent_section": null,
    "description": "Whether to use the gamma point extrapolation method to calculate the Fock exchange operator. See https://doi.org/10.1103/PhysRevB.79.205114 for details. Should be set to true most of the time."
  },
  {
    "name": "ecutexx",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ecutexx {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "same as ecutrho",
        "unit": null,
        "description": "The energy cutoff for EXX (Fock) exchange operator in plane wave basis calculations. Reducing ecutexx below ecutrho may significantly accelerate EXX computations. This speed improvement comes with a reduced numerical accuracy in the exchange energy calculation."
      }
    ],
    "parent_section": null,
    "description": "The energy cutoff for EXX (Fock) exchange operator in plane wave basis calculations. Reducing ecutexx below ecutrho may significantly accelerate EXX computations. This speed improvement comes with a reduced numerical accuracy in the exchange energy calculation."
  },
  {
    "name": "exx_thr_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_thr_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "density",
        "unit": null,
        "description": "The type of threshold used to judge whether the outer loop has converged in the separate loop EXX calculation. energy: use the change of exact exchange energy to judge convergence. density: if the change of charge density difference between two successive outer loop iterations is seen as converged according to scf_thr , then the outer loop is seen as converged."
      }
    ],
    "parent_section": null,
    "description": "The type of threshold used to judge whether the outer loop has converged in the separate loop EXX calculation. energy: use the change of exact exchange energy to judge convergence. density: if the change of charge density difference between two successive outer loop iterations is seen as converged according to scf_thr , then the outer loop is seen as converged."
  },
  {
    "name": "exx_ene_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "exx_ene_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-5",
        "unit": null,
        "description": "The threshold for the change of exact exchange energy to judge convergence of the outer loop in the separate loop EXX calculation."
      }
    ],
    "parent_section": null,
    "description": "The threshold for the change of exact exchange energy to judge convergence of the outer loop in the separate loop EXX calculation."
  },
  {
    "name": "md_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "nvt",
        "unit": null,
        "description": "Control the algorithm to integrate the equation of motion for molecular dynamics (MD), see md.md in detail. fire: a MD-based relaxation algorithm, named fast inertial relaxation engine. nve: NVE ensemble with velocity Verlet algorithm. nvt: NVT ensemble, see md_thermostat in detail. npt: Nose-Hoover style NPT ensemble, see md_pmode in detail. langevin: NVT ensemble with Langevin thermostat, see md_damp in detail. msst: MSST method, see msst_direction , msst_vel , msst_qmass , msst_vis , msst_tsc"
      }
    ],
    "parent_section": null,
    "description": "Control the algorithm to integrate the equation of motion for molecular dynamics (MD), see md.md in detail. fire: a MD-based relaxation algorithm, named fast inertial relaxation engine. nve: NVE ensemble with velocity Verlet algorithm. nvt: NVT ensemble, see md_thermostat in detail. npt: Nose-Hoover style NPT ensemble, see md_pmode in detail. langevin: NVT ensemble with Langevin thermostat, see md_damp in detail. msst: MSST method, see msst_direction , msst_vel , msst_qmass , msst_vis , msst_tsc"
  },
  {
    "name": "md_nstep",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_nstep {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "10",
        "unit": null,
        "description": "The total number of molecular dynamics steps."
      }
    ],
    "parent_section": null,
    "description": "The total number of molecular dynamics steps."
  },
  {
    "name": "md_dt",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_dt {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "The time step used in molecular dynamics calculations."
      }
    ],
    "parent_section": null,
    "description": "The time step used in molecular dynamics calculations."
  },
  {
    "name": "md_thermostat",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_thermostat {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "nhc",
        "unit": null,
        "description": "Specify the temperature control method used in NVT ensemble. nhc: Nose-Hoover chain, see md_tfreq and md_tchain in detail. anderson: Anderson thermostat, see md_nraise in detail. berendsen: Berendsen thermostat, see md_nraise in detail. rescaling: velocity Rescaling method 1, see md_tolerance in detail. rescale_v: velocity Rescaling method 2, see md_nraise in detail."
      }
    ],
    "parent_section": null,
    "description": "Specify the temperature control method used in NVT ensemble. nhc: Nose-Hoover chain, see md_tfreq and md_tchain in detail. anderson: Anderson thermostat, see md_nraise in detail. berendsen: Berendsen thermostat, see md_nraise in detail. rescaling: velocity Rescaling method 1, see md_tolerance in detail. rescale_v: velocity Rescaling method 2, see md_nraise in detail."
  },
  {
    "name": "md_tfirst",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_tfirst {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "The temperature used in molecular dynamics calculations. If md_tfirst is unset or less than zero, init_vel is autoset to be true . If init_vel is true , the initial temperature will be determined by the velocities read from STRU . In this case, if velocities are unspecified in STRU , the initial temperature is set to zero. If md_tfirst is set to a positive value and init_vel is true simultaneously, please make sure they are consistent, otherwise abacus will exit immediately. Note that md_tlast i"
      }
    ],
    "parent_section": null,
    "description": "The temperature used in molecular dynamics calculations. If md_tfirst is unset or less than zero, init_vel is autoset to be true . If init_vel is true , the initial temperature will be determined by the velocities read from STRU . In this case, if velocities are unspecified in STRU , the initial temperature is set to zero. If md_tfirst is set to a positive value and init_vel is true simultaneously, please make sure they are consistent, otherwise abacus will exit immediately. Note that md_tlast i"
  },
  {
    "name": "md_tlast",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_tlast {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "The temperature used in molecular dynamics calculations. If md_tfirst is unset or less than zero, init_vel is autoset to be true . If init_vel is true , the initial temperature will be determined by the velocities read from STRU . In this case, if velocities are unspecified in STRU , the initial temperature is set to zero. If md_tfirst is set to a positive value and init_vel is true simultaneously, please make sure they are consistent, otherwise abacus will exit immediately. Note that md_tlast i"
      }
    ],
    "parent_section": null,
    "description": "The temperature used in molecular dynamics calculations. If md_tfirst is unset or less than zero, init_vel is autoset to be true . If init_vel is true , the initial temperature will be determined by the velocities read from STRU . In this case, if velocities are unspecified in STRU , the initial temperature is set to zero. If md_tfirst is set to a positive value and init_vel is true simultaneously, please make sure they are consistent, otherwise abacus will exit immediately. Note that md_tlast i"
  },
  {
    "name": "md_restart",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_restart {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Control whether to restart molecular dynamics calculations and time-dependent density functional theory calculations. True: ABACUS will read in ${read_file_dir}/Restart_md.txt to determine the current step ${md_step} , then read in the corresponding STRU_MD_${md_step} in the folder OUT.$suffix/STRU/ automatically. For tddft, ABACUS will also read in WFC_NAO_K${kpoint} of the last step (You need to set out_wfc_lcao=1 and out_app_flag=0 to obtain this file). False: ABACUS will start molecular dyna"
      }
    ],
    "parent_section": null,
    "description": "Control whether to restart molecular dynamics calculations and time-dependent density functional theory calculations. True: ABACUS will read in ${read_file_dir}/Restart_md.txt to determine the current step ${md_step} , then read in the corresponding STRU_MD_${md_step} in the folder OUT.$suffix/STRU/ automatically. For tddft, ABACUS will also read in WFC_NAO_K${kpoint} of the last step (You need to set out_wfc_lcao=1 and out_app_flag=0 to obtain this file). False: ABACUS will start molecular dyna"
  },
  {
    "name": "md_restartfreq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_restartfreq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "5",
        "unit": null,
        "description": "The output frequency of OUT.${suffix}/Restart_md.txt and structural files in the directory OUT.${suffix}/STRIU/ , which are used to restart molecular dynamics calculations, see md_restart in detail."
      }
    ],
    "parent_section": null,
    "description": "The output frequency of OUT.${suffix}/Restart_md.txt and structural files in the directory OUT.${suffix}/STRIU/ , which are used to restart molecular dynamics calculations, see md_restart in detail."
  },
  {
    "name": "md_dumpfreq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_dumpfreq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The output frequency of OUT.${suffix}/MD_dump in molecular dynamics calculations, which including the information of lattices and atoms."
      }
    ],
    "parent_section": null,
    "description": "The output frequency of OUT.${suffix}/MD_dump in molecular dynamics calculations, which including the information of lattices and atoms."
  },
  {
    "name": "dump_force",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dump_force {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to output atomic forces into the file OUT.${suffix}/MD_dump ."
      }
    ],
    "parent_section": null,
    "description": "Whether to output atomic forces into the file OUT.${suffix}/MD_dump ."
  },
  {
    "name": "dump_vel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dump_vel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to output atomic velocities into the file OUT.${suffix}/MD_dump ."
      }
    ],
    "parent_section": null,
    "description": "Whether to output atomic velocities into the file OUT.${suffix}/MD_dump ."
  },
  {
    "name": "dump_virial",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dump_virial {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to output lattice virials into the file OUT.${suffix}/MD_dump ."
      }
    ],
    "parent_section": null,
    "description": "Whether to output lattice virials into the file OUT.${suffix}/MD_dump ."
  },
  {
    "name": "md_seed",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_seed {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1",
        "unit": null,
        "description": "The random seed to initialize random numbers used in molecular dynamics calculations. < 0: No srand() function is called. >= 0: The function srand(md_seed) is called."
      }
    ],
    "parent_section": null,
    "description": "The random seed to initialize random numbers used in molecular dynamics calculations. < 0: No srand() function is called. >= 0: The function srand(md_seed) is called."
  },
  {
    "name": "md_tfreq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_tfreq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1/40/md_dt",
        "unit": null,
        "description": "Control the frequency of temperature oscillations during the simulation. If it is too large, the temperature will fluctuate violently; if it is too small, the temperature will take a very long time to equilibrate with the atomic system. Note: It is a system-dependent empirical parameter, ranging from 1/(40*md_dt) to 1/(100*md_dt). An improper choice might lead to the failure of jobs."
      }
    ],
    "parent_section": null,
    "description": "Control the frequency of temperature oscillations during the simulation. If it is too large, the temperature will fluctuate violently; if it is too small, the temperature will take a very long time to equilibrate with the atomic system. Note: It is a system-dependent empirical parameter, ranging from 1/(40*md_dt) to 1/(100*md_dt). An improper choice might lead to the failure of jobs."
  },
  {
    "name": "md_tchain",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_tchain {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Number of thermostats coupled with the particles in the NVT/NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion."
      }
    ],
    "parent_section": null,
    "description": "Number of thermostats coupled with the particles in the NVT/NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion."
  },
  {
    "name": "md_pmode",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_pmode {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "iso",
        "unit": null,
        "description": "Specify the cell fluctuation mode in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion. iso: The three diagonal elements of the lattice are fluctuated isotropically. aniso: The three diagonal elements of the lattice are fluctuated anisotropically. tri: The lattice must be a lower-triangular matrix, and all six freedoms are fluctuated."
      }
    ],
    "parent_section": null,
    "description": "Specify the cell fluctuation mode in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion. iso: The three diagonal elements of the lattice are fluctuated isotropically. aniso: The three diagonal elements of the lattice are fluctuated anisotropically. tri: The lattice must be a lower-triangular matrix, and all six freedoms are fluctuated."
  },
  {
    "name": "ref_cell_factor",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ref_cell_factor {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Construct a reference cell bigger than the initial cell. The reference cell has to be large enough so that the lattice vectors of the fluctuating cell do not exceed the reference lattice vectors during MD. Typically, 1.02 ~ 1.10 is sufficient. However, the cell fluctuations depend on the specific system and thermodynamic conditions. So users must test for a proper choice. This parameters should be used in conjunction with erf_ecut , erf_height , and erf_sigma ."
      }
    ],
    "parent_section": null,
    "description": "Construct a reference cell bigger than the initial cell. The reference cell has to be large enough so that the lattice vectors of the fluctuating cell do not exceed the reference lattice vectors during MD. Typically, 1.02 ~ 1.10 is sufficient. However, the cell fluctuations depend on the specific system and thermodynamic conditions. So users must test for a proper choice. This parameters should be used in conjunction with erf_ecut , erf_height , and erf_sigma ."
  },
  {
    "name": "md_pcouple",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_pcouple {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "The coupled lattice vectors will scale proportionally in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion. none: Three lattice vectors scale independently. xyz: Lattice vectors x, y, and z scale proportionally. xy: Lattice vectors x and y scale proportionally. xz: Lattice vectors x and z scale proportionally. yz: Lattice vectors y and z scale proportionally."
      }
    ],
    "parent_section": null,
    "description": "The coupled lattice vectors will scale proportionally in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion. none: Three lattice vectors scale independently. xyz: Lattice vectors x, y, and z scale proportionally. xy: Lattice vectors x and y scale proportionally. xz: Lattice vectors x and z scale proportionally. yz: Lattice vectors y and z scale proportionally."
  },
  {
    "name": "md_pfirst",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_pfirst {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1.0",
        "unit": null,
        "description": "The target pressure used in NPT ensemble simulations, the default value of md_plast is md_pfirst . If md_plast is set to be different from md_pfirst , ABACUS will automatically change the target pressure from md_pfirst to md_plast ."
      }
    ],
    "parent_section": null,
    "description": "The target pressure used in NPT ensemble simulations, the default value of md_plast is md_pfirst . If md_plast is set to be different from md_pfirst , ABACUS will automatically change the target pressure from md_pfirst to md_plast ."
  },
  {
    "name": "md_plast",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_plast {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1.0",
        "unit": null,
        "description": "The target pressure used in NPT ensemble simulations, the default value of md_plast is md_pfirst . If md_plast is set to be different from md_pfirst , ABACUS will automatically change the target pressure from md_pfirst to md_plast ."
      }
    ],
    "parent_section": null,
    "description": "The target pressure used in NPT ensemble simulations, the default value of md_plast is md_pfirst . If md_plast is set to be different from md_pfirst , ABACUS will automatically change the target pressure from md_pfirst to md_plast ."
  },
  {
    "name": "md_pfreq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_pfreq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1/400/md_dt",
        "unit": null,
        "description": "The frequency of pressure oscillations during the NPT ensemble simulation. If it is too large, the pressure will fluctuate violently; if it is too small, the pressure will take a very long time to equilibrate with the atomic system. Note: It is a system-dependent empirical parameter. An improper choice might lead to the failure of jobs."
      }
    ],
    "parent_section": null,
    "description": "The frequency of pressure oscillations during the NPT ensemble simulation. If it is too large, the pressure will fluctuate violently; if it is too small, the pressure will take a very long time to equilibrate with the atomic system. Note: It is a system-dependent empirical parameter. An improper choice might lead to the failure of jobs."
  },
  {
    "name": "md_pchain",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_pchain {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The number of thermostats coupled with the barostat in the NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion."
      }
    ],
    "parent_section": null,
    "description": "The number of thermostats coupled with the barostat in the NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion."
  },
  {
    "name": "lj_rule",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lj_rule {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2",
        "unit": null,
        "description": "The Lennard-Jones potential between two atoms equals: $ \\(V_{LJ}(r_{ij})=4\\epsilon_{ij}\\left(\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right)=\\frac{C_{ij}^{(12)}}{{r_{ij}}^{12}}-\\frac{C_{ij}^{(6)}}{{r_{ij}}^{6}}.\\) $ The parameters lj_epsilon and lj_sigma should be multiple-component vectors. For example, there are two choices in the calculations of 3 atom species: Supply six-component vectors that describe the interactions between all possible atom"
      }
    ],
    "parent_section": null,
    "description": "The Lennard-Jones potential between two atoms equals: $ \\(V_{LJ}(r_{ij})=4\\epsilon_{ij}\\left(\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right)=\\frac{C_{ij}^{(12)}}{{r_{ij}}^{12}}-\\frac{C_{ij}^{(6)}}{{r_{ij}}^{6}}.\\) $ The parameters lj_epsilon and lj_sigma should be multiple-component vectors. For example, there are two choices in the calculations of 3 atom species: Supply six-component vectors that describe the interactions between all possible atom"
  },
  {
    "name": "lj_eshift",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lj_eshift {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "It True, the LJ potential is shifted by a constant such that it is zero at the cut-off distance."
      }
    ],
    "parent_section": null,
    "description": "It True, the LJ potential is shifted by a constant such that it is zero at the cut-off distance."
  },
  {
    "name": "lj_rcut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lj_rcut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "Cut-off radius for Leonard Jones potential, beyond which the interaction will be neglected. It can be a single value, which means that all pairs of atoms types share the same cut-off radius. Otherwise, it should be a multiple-component vector, containing \\(N(N+1)/2\\) values, see details in lj_rule ."
      }
    ],
    "parent_section": null,
    "description": "Cut-off radius for Leonard Jones potential, beyond which the interaction will be neglected. It can be a single value, which means that all pairs of atoms types share the same cut-off radius. Otherwise, it should be a multiple-component vector, containing \\(N(N+1)/2\\) values, see details in lj_rule ."
  },
  {
    "name": "lj_epsilon",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lj_epsilon {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "The vector representing the \\(\\epsilon\\) matrix for Leonard Jones potential. See details in lj_rule ."
      }
    ],
    "parent_section": null,
    "description": "The vector representing the \\(\\epsilon\\) matrix for Leonard Jones potential. See details in lj_rule ."
  },
  {
    "name": "lj_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "lj_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "The vector representing the \\(\\sigma\\) matrix for Leonard Jones potential. See details in lj_rule ."
      }
    ],
    "parent_section": null,
    "description": "The vector representing the \\(\\sigma\\) matrix for Leonard Jones potential. See details in lj_rule ."
  },
  {
    "name": "pot_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pot_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "graph.pb",
        "unit": null,
        "description": "The filename of DP/NEP potential files, see md.md in detail."
      }
    ],
    "parent_section": null,
    "description": "The filename of DP/NEP potential files, see md.md in detail."
  },
  {
    "name": "dp_rescaling",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dp_rescaling {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "Rescaling factor to use a temperature-dependent DP. Energy, stress and force calculated by DP will be multiplied by this factor."
      }
    ],
    "parent_section": null,
    "description": "Rescaling factor to use a temperature-dependent DP. Energy, stress and force calculated by DP will be multiplied by this factor."
  },
  {
    "name": "dp_fparam",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dp_fparam {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "{}",
        "unit": null,
        "description": "The frame parameter for dp potential. The array size is dim_fparam, then all frames are assumed to be provided with the same fparam."
      }
    ],
    "parent_section": null,
    "description": "The frame parameter for dp potential. The array size is dim_fparam, then all frames are assumed to be provided with the same fparam."
  },
  {
    "name": "dp_aparam",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dp_aparam {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "{}",
        "unit": null,
        "description": "The atomic parameter for dp potential. The array size can be (1) natoms x dim_aparam, then all frames are assumed to be provided with the same aparam; (2) dim_aparam, then all frames and atoms are assumed to be provided with the same aparam."
      }
    ],
    "parent_section": null,
    "description": "The atomic parameter for dp potential. The array size can be (1) natoms x dim_aparam, then all frames are assumed to be provided with the same aparam; (2) dim_aparam, then all frames and atoms are assumed to be provided with the same aparam."
  },
  {
    "name": "msst_direction",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "msst_direction {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "2",
        "unit": null,
        "description": "The direction of the shock wave in the MSST method. 0: x direction 1: y direction 2: z direction"
      }
    ],
    "parent_section": null,
    "description": "The direction of the shock wave in the MSST method. 0: x direction 1: y direction 2: z direction"
  },
  {
    "name": "msst_vel",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "msst_vel {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "The velocity of the shock wave in the MSST method."
      }
    ],
    "parent_section": null,
    "description": "The velocity of the shock wave in the MSST method."
  },
  {
    "name": "msst_vis",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "msst_vis {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.0",
        "unit": null,
        "description": "Artificial viscosity in the MSST method."
      }
    ],
    "parent_section": null,
    "description": "Artificial viscosity in the MSST method."
  },
  {
    "name": "msst_tscale",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "msst_tscale {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "The reduction percentage of the initial temperature used to compress volume in the MSST method."
      }
    ],
    "parent_section": null,
    "description": "The reduction percentage of the initial temperature used to compress volume in the MSST method."
  },
  {
    "name": "msst_qmass",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "msst_qmass {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "Inertia of the extended system variable. You should set a number larger than 0."
      }
    ],
    "parent_section": null,
    "description": "Inertia of the extended system variable. You should set a number larger than 0."
  },
  {
    "name": "md_damp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_damp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0",
        "unit": null,
        "description": "The damping parameter used to add fictitious force in the Langevin method."
      }
    ],
    "parent_section": null,
    "description": "The damping parameter used to add fictitious force in the Langevin method."
  },
  {
    "name": "md_tolerance",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_tolerance {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "100.0",
        "unit": null,
        "description": "The temperature tolerance for velocity rescaling. Velocities are rescaled if the current and target temperature differ more than md_tolerance ."
      }
    ],
    "parent_section": null,
    "description": "The temperature tolerance for velocity rescaling. Velocities are rescaled if the current and target temperature differ more than md_tolerance ."
  },
  {
    "name": "md_nraise",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "md_nraise {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Anderson: The “collision frequency” parameter is given as 1/ md_nraise . Berendsen: The “rise time” parameter is given in units of the time step: tau = md_nraise * md_dt , so md_dt /tau = 1/ md_nraise . Rescale_v: Every md_nraise steps the current temperature is rescaled to the target temperature."
      }
    ],
    "parent_section": null,
    "description": "Anderson: The “collision frequency” parameter is given as 1/ md_nraise . Berendsen: The “rise time” parameter is given in units of the time step: tau = md_nraise * md_dt , so md_dt /tau = 1/ md_nraise . Rescale_v: Every md_nraise steps the current temperature is rescaled to the target temperature."
  },
  {
    "name": "cal_syns",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cal_syns {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether the asynchronous overlap matrix is calculated for Hefei-NAMD."
      }
    ],
    "parent_section": null,
    "description": "Whether the asynchronous overlap matrix is calculated for Hefei-NAMD."
  },
  {
    "name": "dmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.01",
        "unit": null,
        "description": "The maximum displacement of all atoms in one step. This parameter is useful when cal_syns = True."
      }
    ],
    "parent_section": null,
    "description": "The maximum displacement of all atoms in one step. This parameter is useful when cal_syns = True."
  },
  {
    "name": "dft_plus_u",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "dft_plus_u {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Determines whether to calculate the plus U correction, which is especially important for correlated electrons. 1: Calculate plus U correction with radius-adjustable localized projections (with parameter onsite_radius ). 2: Calculate plus U correction using first zeta of NAOs as projections (this is old method for testing). 0: Do not calculate plus U correction."
      }
    ],
    "parent_section": null,
    "description": "Determines whether to calculate the plus U correction, which is especially important for correlated electrons. 1: Calculate plus U correction with radius-adjustable localized projections (with parameter onsite_radius ). 2: Calculate plus U correction using first zeta of NAOs as projections (this is old method for testing). 0: Do not calculate plus U correction."
  },
  {
    "name": "orbital_corr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "orbital_corr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "-1",
        "unit": null,
        "description": "Specifies which orbits need plus U correction for each atom type ( \\(l_1,l_2,l_3,\\ldots\\) for atom type 1, 2, 3, respectively). -1: The plus U correction will not be calculated for this atom. 1: For p-electron orbits, the plus U correction is needed. 2: For d-electron orbits, the plus U correction is needed. 3: For f-electron orbits, the plus U correction is needed."
      }
    ],
    "parent_section": null,
    "description": "Specifies which orbits need plus U correction for each atom type ( \\(l_1,l_2,l_3,\\ldots\\) for atom type 1, 2, 3, respectively). -1: The plus U correction will not be calculated for this atom. 1: For p-electron orbits, the plus U correction is needed. 2: For d-electron orbits, the plus U correction is needed. 3: For f-electron orbits, the plus U correction is needed."
  },
  {
    "name": "hubbard_u",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "hubbard_u {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "Specifies the Hubbard Coulomb interaction parameter U (eV) in plus U correction, which should be specified for each atom unless the Yukawa potential is used."
      }
    ],
    "parent_section": null,
    "description": "Specifies the Hubbard Coulomb interaction parameter U (eV) in plus U correction, which should be specified for each atom unless the Yukawa potential is used."
  },
  {
    "name": "yukawa_potential",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "yukawa_potential {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Determines whether to use the local screen Coulomb potential method to calculate the values of U and J. True: hubbard_u does not need to be specified. False: hubbard_u does need to be specified."
      }
    ],
    "parent_section": null,
    "description": "Determines whether to use the local screen Coulomb potential method to calculate the values of U and J. True: hubbard_u does not need to be specified. False: hubbard_u does need to be specified."
  },
  {
    "name": "yukawa_lambda",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "yukawa_lambda {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "Calculated on the fly.",
        "unit": null,
        "description": "The screen length of Yukawa potential. If left to default, the screen length will be calculated as an average of the entire system. It’s better to stick to the default setting unless there is a very good reason."
      }
    ],
    "parent_section": null,
    "description": "The screen length of Yukawa potential. If left to default, the screen length will be calculated as an average of the entire system. It’s better to stick to the default setting unless there is a very good reason."
  },
  {
    "name": "uramping",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "uramping {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1.0.",
        "unit": null,
        "description": "Once uramping > 0.15 eV. DFT+U calculations will start SCF with U = 0 eV, namely normal LDA/PBE calculations. Once SCF restarts when drho<mixing_restart , U value will increase by uramping eV. SCF will repeat above calcuations until U values reach target defined in hubbard_u . As for uramping=1.0 eV , the recommendations of mixing_restart is around 5e-4 ."
      }
    ],
    "parent_section": null,
    "description": "Once uramping > 0.15 eV. DFT+U calculations will start SCF with U = 0 eV, namely normal LDA/PBE calculations. Once SCF restarts when drho<mixing_restart , U value will increase by uramping eV. SCF will repeat above calcuations until U values reach target defined in hubbard_u . As for uramping=1.0 eV , the recommendations of mixing_restart is around 5e-4 ."
  },
  {
    "name": "omc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "omc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": null,
        "unit": null,
        "description": "The parameter controls the form of occupation matrix control used. 0: No occupation matrix control is performed, and the onsite density matrix will be calculated from wavefunctions in each SCF step. 1: The first SCF step will use an initial density matrix read from a file named [initial_onsite.dm](http://initial_onsite.dm/) , but for later steps, the onsite density matrix will be updated. 2: The same onsite density matrix from initial_onsite.dm will be used throughout the entire calculation."
      }
    ],
    "parent_section": null,
    "description": "The parameter controls the form of occupation matrix control used. 0: No occupation matrix control is performed, and the onsite density matrix will be calculated from wavefunctions in each SCF step. 1: The first SCF step will use an initial density matrix read from a file named [initial_onsite.dm](http://initial_onsite.dm/) , but for later steps, the onsite density matrix will be updated. 2: The same onsite density matrix from initial_onsite.dm will be used throughout the entire calculation."
  },
  {
    "name": "onsite_radius",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "onsite_radius {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "3.0",
        "unit": null,
        "description": "The Onsite-radius parameter facilitates modulation of the single-zeta portion of numerical atomic orbitals for projections for DFT+U. The modulation algorithm includes a smooth truncation applied directly to the tail of the original orbital, followed by normalization. Consider the function: $ \\( g(r;\\sigma)=\\begin{cases} 1-\\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right), & r < r_c\\\\ 0, & r \\geq r_c \\end{cases} \\) $ where \\(\\sigma\\) is a parameter that controls the smoothing interval. A normalized "
      }
    ],
    "parent_section": null,
    "description": "The Onsite-radius parameter facilitates modulation of the single-zeta portion of numerical atomic orbitals for projections for DFT+U. The modulation algorithm includes a smooth truncation applied directly to the tail of the original orbital, followed by normalization. Consider the function: $ \\( g(r;\\sigma)=\\begin{cases} 1-\\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right), & r < r_c\\\\ 0, & r \\geq r_c \\end{cases} \\) $ where \\(\\sigma\\) is a parameter that controls the smoothing interval. A normalized "
  },
  {
    "name": "vdw_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "Specifies the method used for Van der Waals (VdW) correction. Available options are: d2 : Grimme’s D2 dispersion correction method d3_0 : Grimme’s DFT-D3(0) dispersion correction method (zero-damping) d3_bj : Grimme’s DFTD3(BJ) dispersion correction method (BJ-damping) none : no vdW correction"
      }
    ],
    "parent_section": null,
    "description": "Specifies the method used for Van der Waals (VdW) correction. Available options are: d2 : Grimme’s D2 dispersion correction method d3_0 : Grimme’s DFT-D3(0) dispersion correction method (zero-damping) d3_bj : Grimme’s DFTD3(BJ) dispersion correction method (BJ-damping) none : no vdW correction"
  },
  {
    "name": "vdw_s6",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_s6 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.75: if vdw_method is set to d2",
        "unit": null,
        "description": "This scale factor is used to optimize the interaction energy deviations in van der Waals (vdW) corrected calculations. The recommended values of this parameter are dependent on the chosen vdW correction method and the DFT functional being used. For DFT-D2, the recommended values are 0.75 (PBE), 1.2 (BLYP), 1.05 (B-P86), 1.0 (TPSS), and 1.05 (B3LYP). If not set, will use values of PBE functional. For DFT-D3, recommended values with different DFT functionals can be found on the here . If not set, "
      }
    ],
    "parent_section": null,
    "description": "This scale factor is used to optimize the interaction energy deviations in van der Waals (vdW) corrected calculations. The recommended values of this parameter are dependent on the chosen vdW correction method and the DFT functional being used. For DFT-D2, the recommended values are 0.75 (PBE), 1.2 (BLYP), 1.05 (B-P86), 1.0 (TPSS), and 1.05 (B3LYP). If not set, will use values of PBE functional. For DFT-D3, recommended values with different DFT functionals can be found on the here . If not set, "
  },
  {
    "name": "vdw_s8",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_s8 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "This scale factor is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
      }
    ],
    "parent_section": null,
    "description": "This scale factor is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
  },
  {
    "name": "vdw_a1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_a1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "This damping function parameter is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
      }
    ],
    "parent_section": null,
    "description": "This damping function parameter is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
  },
  {
    "name": "vdw_a2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_a2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": null,
        "unit": null,
        "description": "This damping function parameter is only relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
      }
    ],
    "parent_section": null,
    "description": "This damping function parameter is only relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the webpage . If not set, will search in ABACUS built-in dataset based on the dft_functional keywords. User set value will overwrite the searched value."
  },
  {
    "name": "vdw_d",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_d {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "20",
        "unit": null,
        "description": "Controls the damping rate of the damping function in the DFT-D2 method."
      }
    ],
    "parent_section": null,
    "description": "Controls the damping rate of the damping function in the DFT-D2 method."
  },
  {
    "name": "vdw_abc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_abc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "False",
        "unit": null,
        "description": "Determines whether three-body terms are calculated for DFT-D3 methods. True: ABACUS will calculate the three-body term. False: The three-body term is not included."
      }
    ],
    "parent_section": null,
    "description": "Determines whether three-body terms are calculated for DFT-D3 methods. True: ABACUS will calculate the three-body term. False: The three-body term is not included."
  },
  {
    "name": "vdw_cutoff_type",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_cutoff_type {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "radius",
        "unit": null,
        "description": "Determines the method used for specifying the cutoff radius in periodic systems when applying Van der Waals correction. Available options are: radius : The supercell is selected within a sphere centered at the origin with a radius defined by vdw_cutoff_radius . period : The extent of the supercell is explicitly specified using the vdw_cutoff_period keyword."
      }
    ],
    "parent_section": null,
    "description": "Determines the method used for specifying the cutoff radius in periodic systems when applying Van der Waals correction. Available options are: radius : The supercell is selected within a sphere centered at the origin with a radius defined by vdw_cutoff_radius . period : The extent of the supercell is explicitly specified using the vdw_cutoff_period keyword."
  },
  {
    "name": "vdw_cutoff_radius",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_cutoff_radius {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "56.6918 if vdw_method is set to d2 95 if vdw_method is set to d3_0 or d3_bj",
        "unit": null,
        "description": "Defines the radius of the cutoff sphere when vdw_cutoff_type is set to radius . The default values depend on the chosen vdw_method ."
      }
    ],
    "parent_section": null,
    "description": "Defines the radius of the cutoff sphere when vdw_cutoff_type is set to radius . The default values depend on the chosen vdw_method ."
  },
  {
    "name": "vdw_radius_unit",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_radius_unit {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "Bohr",
        "unit": null,
        "description": "Specify the unit of vdw_cutoff_radius . Available options are: A (Angstrom) Bohr"
      }
    ],
    "parent_section": null,
    "description": "Specify the unit of vdw_cutoff_radius . Available options are: A (Angstrom) Bohr"
  },
  {
    "name": "vdw_cutoff_period",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_cutoff_period {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "3 3 3",
        "unit": null,
        "description": "The three integers supplied here explicitly specify the extent of the supercell in the directions of the three basis lattice vectors."
      }
    ],
    "parent_section": null,
    "description": "The three integers supplied here explicitly specify the extent of the supercell in the directions of the three basis lattice vectors."
  },
  {
    "name": "vdw_cn_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_cn_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "40",
        "unit": null,
        "description": "The cutoff radius when calculating coordination numbers."
      }
    ],
    "parent_section": null,
    "description": "The cutoff radius when calculating coordination numbers."
  },
  {
    "name": "vdw_cn_thr_unit",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vdw_cn_thr_unit {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "Bohr",
        "unit": null,
        "description": "Unit of the coordination number cutoff ( vdw_cn_thr ). Available options are: A (Angstrom) Bohr"
      }
    ],
    "parent_section": null,
    "description": "Unit of the coordination number cutoff ( vdw_cn_thr ). Available options are: A (Angstrom) Bohr"
  },
  {
    "name": "berry_phase",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "berry_phase {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "false",
        "unit": null,
        "description": "Controls the calculation of Berry phase true: Calculate Berry phase. false: Do not calculate Berry phase."
      }
    ],
    "parent_section": null,
    "description": "Controls the calculation of Berry phase true: Calculate Berry phase. false: Do not calculate Berry phase."
  },
  {
    "name": "gdir",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "gdir {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "3",
        "unit": null,
        "description": "The direction of the polarization in the lattice vector for Berry phase calculation 1: Calculate the polarization in the direction of the lattice vector a_1 defined in the STRU file. 2: Calculate the polarization in the direction of the lattice vector a_2 defined in the STRU file. 3: Calculate the polarization in the direction of the lattice vector a_3 defined in the STRU file."
      }
    ],
    "parent_section": null,
    "description": "The direction of the polarization in the lattice vector for Berry phase calculation 1: Calculate the polarization in the direction of the lattice vector a_1 defined in the STRU file. 2: Calculate the polarization in the direction of the lattice vector a_2 defined in the STRU file. 3: Calculate the polarization in the direction of the lattice vector a_3 defined in the STRU file."
  },
  {
    "name": "towannier90",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "towannier90 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Controls the generation of files for the Wannier90 code. 1: Generate files for the Wannier90 code. 0: Do not generate files for the Wannier90 code."
      }
    ],
    "parent_section": null,
    "description": "Controls the generation of files for the Wannier90 code. 1: Generate files for the Wannier90 code. 0: Do not generate files for the Wannier90 code."
  },
  {
    "name": "nnkpfile",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nnkpfile {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "seedname.nnkp",
        "unit": null,
        "description": "The file name generated when running “wannier90 -pp …” command"
      }
    ],
    "parent_section": null,
    "description": "The file name generated when running “wannier90 -pp …” command"
  },
  {
    "name": "wannier_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "wannier_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Only available on LCAO basis, using different methods to generate “*.mmn” file and “*.amn” file. 1: Calculated using the lcao_in_pw method, the calculation accuracy can be improved by increasing ecutwfc to maintain consistency with the pw basis set results. 2: The overlap between atomic orbitals is calculated using grid integration. The radial grid points are generated using the Gauss-Legendre method, while the spherical grid points are generated using the Lebedev-Laikov method."
      }
    ],
    "parent_section": null,
    "description": "Only available on LCAO basis, using different methods to generate “*.mmn” file and “*.amn” file. 1: Calculated using the lcao_in_pw method, the calculation accuracy can be improved by increasing ecutwfc to maintain consistency with the pw basis set results. 2: The overlap between atomic orbitals is calculated using grid integration. The radial grid points are generated using the Gauss-Legendre method, while the spherical grid points are generated using the Lebedev-Laikov method."
  },
  {
    "name": "wannier_spin",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "wannier_spin {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "up",
        "unit": null,
        "description": "The spin direction for the Wannier function calculation when nspin is set to 2 up : Calculate spin up for the Wannier function. down : Calculate spin down for the Wannier function."
      }
    ],
    "parent_section": null,
    "description": "The spin direction for the Wannier function calculation when nspin is set to 2 up : Calculate spin up for the Wannier function. down : Calculate spin down for the Wannier function."
  },
  {
    "name": "out_wannier_mmn",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wannier_mmn {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Write the “*.mmn” file or not. 0: don’t write the “*.mmn” file. 1: write the “*.mmn” file."
      }
    ],
    "parent_section": null,
    "description": "Write the “*.mmn” file or not. 0: don’t write the “*.mmn” file. 1: write the “*.mmn” file."
  },
  {
    "name": "out_wannier_amn",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wannier_amn {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Write the “*.amn” file or not. 0: don’t write the “*.amn” file. 1: write the “*.amn” file."
      }
    ],
    "parent_section": null,
    "description": "Write the “*.amn” file or not. 0: don’t write the “*.amn” file. 1: write the “*.amn” file."
  },
  {
    "name": "out_wannier_eig",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wannier_eig {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Write the “*.eig” file or not. 0: don’t write the “*.eig” file. 1: write the “*.eig” file."
      }
    ],
    "parent_section": null,
    "description": "Write the “*.eig” file or not. 0: don’t write the “*.eig” file. 1: write the “*.eig” file."
  },
  {
    "name": "out_wannier_unk",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wannier_unk {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "0",
        "unit": null,
        "description": "Write the “UNK.*” file or not. 0: don’t write the “UNK.*” file. 1: write the “UNK.*” file."
      }
    ],
    "parent_section": null,
    "description": "Write the “UNK.*” file or not. 0: don’t write the “UNK.*” file. 1: write the “UNK.*” file."
  },
  {
    "name": "out_wannier_wvfn_formatted",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_wannier_wvfn_formatted {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Write the “UNK.*” file in ASCII format or binary format. 0: write the “UNK.*” file in binary format. 1: write the “UNK.*” file in ASCII format (text file format)."
      }
    ],
    "parent_section": null,
    "description": "Write the “UNK.*” file in ASCII format or binary format. 0: write the “UNK.*” file in binary format. 1: write the “UNK.*” file in ASCII format (text file format)."
  },
  {
    "name": "estep_per_md",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "estep_per_md {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The number of electronic propagation steps between two ionic steps."
      }
    ],
    "parent_section": null,
    "description": "The number of electronic propagation steps between two ionic steps."
  },
  {
    "name": "td_dt",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_dt {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "md_dt / estep_per_md",
        "unit": null,
        "description": "The time step used in electronic propagation. Setting td_dt will reset the value of md_dt to td_dt * estep_per_md ."
      }
    ],
    "parent_section": null,
    "description": "The time step used in electronic propagation. Setting td_dt will reset the value of md_dt to td_dt * estep_per_md ."
  },
  {
    "name": "td_edm",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_edm {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Method to calculate the energy-density matrix, mainly affects the calculation of force and stress. 0: Using the original formula: \\(\\mathrm{EDM}_{\\mu\\nu}=\\frac{1}{2} \\sum_{\\eta \\zeta}\\left(S_{\\mu \\eta}^{-1} H_{\\eta \\zeta} \\rho_{\\zeta \\nu}+\\rho_{\\mu \\eta} H_{\\eta \\zeta} S_{\\zeta \\nu}^{-1}\\right)\\) . 1: Using the formula for ground state (deprecated): \\(\\mathrm{EDM}_{\\mu\\nu}=\\sum_n^{\\mathrm{occ}} c_{\\mu,n} f_n \\epsilon_n c_{n,\\nu}\\) . Note that this usually does not hold if wave function is not th"
      }
    ],
    "parent_section": null,
    "description": "Method to calculate the energy-density matrix, mainly affects the calculation of force and stress. 0: Using the original formula: \\(\\mathrm{EDM}_{\\mu\\nu}=\\frac{1}{2} \\sum_{\\eta \\zeta}\\left(S_{\\mu \\eta}^{-1} H_{\\eta \\zeta} \\rho_{\\zeta \\nu}+\\rho_{\\mu \\eta} H_{\\eta \\zeta} S_{\\zeta \\nu}^{-1}\\right)\\) . 1: Using the formula for ground state (deprecated): \\(\\mathrm{EDM}_{\\mu\\nu}=\\sum_n^{\\mathrm{occ}} c_{\\mu,n} f_n \\epsilon_n c_{n,\\nu}\\) . Note that this usually does not hold if wave function is not th"
  },
  {
    "name": "td_print_eij",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_print_eij {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-1",
        "unit": null,
        "description": "Controls the printing of Hamiltonian matrix elements \\(E_{ij}=\\Braket{\\psi_i|\\hat{H}|\\psi_j}\\) . \\(<0\\) : Suppress all \\(E_{ij}\\) output. \\(\\geqslant 0\\) : Print only elements with ​​either \\(|\\text{Re}(E_{ij})|\\) or \\(|\\text{Im}(E_{ij})|\\) ​​ exceeding td_print_eij ."
      }
    ],
    "parent_section": null,
    "description": "Controls the printing of Hamiltonian matrix elements \\(E_{ij}=\\Braket{\\psi_i|\\hat{H}|\\psi_j}\\) . \\(<0\\) : Suppress all \\(E_{ij}\\) output. \\(\\geqslant 0\\) : Print only elements with ​​either \\(|\\text{Re}(E_{ij})|\\) or \\(|\\text{Im}(E_{ij})|\\) ​​ exceeding td_print_eij ."
  },
  {
    "name": "td_propagator",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_propagator {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Methods of electronic propagation: \\(\\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_2) = U(t_2,t_1) \\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_1)\\) . 0: Crank-Nicolson, based on matrix inversion: \\(U = \\dfrac{S_{\\boldsymbol{k}}-\\mathrm{i} H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}{S_{\\boldsymbol{k}}+\\mathrm{i} H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}\\) . 1: 4th-order Taylor expansion of exponential: \\(U = I + \\hat{A} + \\frac{1}{2}\\hat{A}^2 + \\frac{1}{6}\\hat{A}^3 + \\frac{1}{24}\\hat{A}^4\\) , where \\"
      }
    ],
    "parent_section": null,
    "description": "Methods of electronic propagation: \\(\\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_2) = U(t_2,t_1) \\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_1)\\) . 0: Crank-Nicolson, based on matrix inversion: \\(U = \\dfrac{S_{\\boldsymbol{k}}-\\mathrm{i} H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}{S_{\\boldsymbol{k}}+\\mathrm{i} H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}\\) . 1: 4th-order Taylor expansion of exponential: \\(U = I + \\hat{A} + \\frac{1}{2}\\hat{A}^2 + \\frac{1}{6}\\hat{A}^3 + \\frac{1}{24}\\hat{A}^4\\) , where \\"
  },
  {
    "name": "td_vext",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_vext {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: Add a laser-material interaction (external electric field). False: No external electric field."
      }
    ],
    "parent_section": null,
    "description": "True: Add a laser-material interaction (external electric field). False: No external electric field."
  },
  {
    "name": "td_vext_dire",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_vext_dire {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "1 Note: The axes refer to the absolute Cartesian coordinate system, which is independent of lattice vectors or reciprocal space definitions.​ This is different from efield_dir , which is used in ground-state KSDFT.",
        "unit": null,
        "description": "Specifies the direction(s) of the external electric field when td_vext is enabled. For example, td_vext_dire 1 2 indicates that external electric fields are applied to both the x and y directions simultaneously. Electric field parameters can also be written as strings. For example, td_gauss_phase 0 1.5707963 indicates that the Gaussian type electric fields in the x and y directions have a phase delay of \\(\\pi/2\\) . See below for more electric field parameters. 1: The external field direction is "
      }
    ],
    "parent_section": null,
    "description": "Specifies the direction(s) of the external electric field when td_vext is enabled. For example, td_vext_dire 1 2 indicates that external electric fields are applied to both the x and y directions simultaneously. Electric field parameters can also be written as strings. For example, td_gauss_phase 0 1.5707963 indicates that the Gaussian type electric fields in the x and y directions have a phase delay of \\(\\pi/2\\) . See below for more electric field parameters. 1: The external field direction is "
  },
  {
    "name": "td_stype",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_stype {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Type of electric field in the space domain, i.e. the gauge of the electric field. 0: Length gauge. 1: Velocity gauge. 2: Hybrid gauge. See J. Chem. Theory Comput. 2025, 21, 3335−3341 for more information."
      }
    ],
    "parent_section": null,
    "description": "Type of electric field in the space domain, i.e. the gauge of the electric field. 0: Length gauge. 1: Velocity gauge. 2: Hybrid gauge. See J. Chem. Theory Comput. 2025, 21, 3335−3341 for more information."
  },
  {
    "name": "td_ttype",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_ttype {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0",
        "unit": null,
        "description": "Type of electric field in the time domain. 0: Gaussian type function: \\[ E(t) = A \\cos\\left[2\\pi f(t-t_0)+\\varphi\\right]\\exp\\left[-\\frac{(t-t_0)^2}{2\\sigma^2}\\right] \\] 1: Trapezoid function: \\[\\begin{split} E(t) = \\begin{cases} A \\cos(2\\pi f t + \\varphi) \\cdot \\dfrac{t}{t_1}, & t < t_1 \\\\ A \\cos(2\\pi f t + \\varphi), & t_1 \\leqslant t \\leqslant t_2 \\\\ A \\cos(2\\pi f t + \\varphi) \\left(1 - \\dfrac{t - t_2}{t_3 - t_2}\\right), & t_2 < t < t_3 \\\\ 0, & t \\geqslant t_3 \\end{cases} \\end{split}\\] 2: Trigo"
      }
    ],
    "parent_section": null,
    "description": "Type of electric field in the time domain. 0: Gaussian type function: \\[ E(t) = A \\cos\\left[2\\pi f(t-t_0)+\\varphi\\right]\\exp\\left[-\\frac{(t-t_0)^2}{2\\sigma^2}\\right] \\] 1: Trapezoid function: \\[\\begin{split} E(t) = \\begin{cases} A \\cos(2\\pi f t + \\varphi) \\cdot \\dfrac{t}{t_1}, & t < t_1 \\\\ A \\cos(2\\pi f t + \\varphi), & t_1 \\leqslant t \\leqslant t_2 \\\\ A \\cos(2\\pi f t + \\varphi) \\left(1 - \\dfrac{t - t_2}{t_3 - t_2}\\right), & t_2 < t < t_3 \\\\ 0, & t \\geqslant t_3 \\end{cases} \\end{split}\\] 2: Trigo"
  },
  {
    "name": "td_tstart",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_tstart {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The initial time step when the time-dependent electric field is activated."
      }
    ],
    "parent_section": null,
    "description": "The initial time step when the time-dependent electric field is activated."
  },
  {
    "name": "td_tend",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_tend {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1000",
        "unit": null,
        "description": "The final time step when the time-dependent electric field is deactivated. The field remains active between td_tstart and td_tend ."
      }
    ],
    "parent_section": null,
    "description": "The final time step when the time-dependent electric field is deactivated. The field remains active between td_tstart and td_tend ."
  },
  {
    "name": "td_lcut1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_lcut1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.05",
        "unit": null,
        "description": "The lower bound of the interval in the length gauge RT-TDDFT, where \\(x\\) is the fractional coordinate: \\( E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases} \\)"
      }
    ],
    "parent_section": null,
    "description": "The lower bound of the interval in the length gauge RT-TDDFT, where \\(x\\) is the fractional coordinate: \\( E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases} \\)"
  },
  {
    "name": "td_lcut2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_lcut2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.95",
        "unit": null,
        "description": "The upper bound of the interval in the length gauge RT-TDDFT, where \\(x\\) is the fractional coordinate: \\( E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases} \\)"
      }
    ],
    "parent_section": null,
    "description": "The upper bound of the interval in the length gauge RT-TDDFT, where \\(x\\) is the fractional coordinate: \\( E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases} \\)"
  },
  {
    "name": "td_gauss_freq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_gauss_freq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "22.13",
        "unit": null,
        "description": "Frequency \\(f\\) of the Gaussian type electric field."
      }
    ],
    "parent_section": null,
    "description": "Frequency \\(f\\) of the Gaussian type electric field."
  },
  {
    "name": "td_gauss_phase",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_gauss_phase {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.0",
        "unit": null,
        "description": "Phase \\(\\varphi\\) of the Gaussian type electric field."
      }
    ],
    "parent_section": null,
    "description": "Phase \\(\\varphi\\) of the Gaussian type electric field."
  },
  {
    "name": "td_gauss_sigma",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_gauss_sigma {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "30.0",
        "unit": null,
        "description": "Pulse width (standard deviation) \\(\\sigma\\) of the Gaussian type electric field."
      }
    ],
    "parent_section": null,
    "description": "Pulse width (standard deviation) \\(\\sigma\\) of the Gaussian type electric field."
  },
  {
    "name": "td_gauss_t0",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_gauss_t0 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "100",
        "unit": null,
        "description": "Step number of the time center \\(t_0\\) of the Gaussian type electric field."
      }
    ],
    "parent_section": null,
    "description": "Step number of the time center \\(t_0\\) of the Gaussian type electric field."
  },
  {
    "name": "td_gauss_amp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_gauss_amp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.25",
        "unit": null,
        "description": "Amplitude \\(A\\) of the Gaussian type electric field."
      }
    ],
    "parent_section": null,
    "description": "Amplitude \\(A\\) of the Gaussian type electric field."
  },
  {
    "name": "td_trape_freq",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_freq {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "1.60",
        "unit": null,
        "description": "Frequency \\(f\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Frequency \\(f\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trape_phase",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_phase {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.0",
        "unit": null,
        "description": "Phase \\(\\varphi\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Phase \\(\\varphi\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trape_t1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_t1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "1875",
        "unit": null,
        "description": "Step number of the time interval \\(t_1\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Step number of the time interval \\(t_1\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trape_t2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_t2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "5625",
        "unit": null,
        "description": "Step number of the time interval \\(t_2\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Step number of the time interval \\(t_2\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trape_t3",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_t3 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "7500",
        "unit": null,
        "description": "Step number of the time interval \\(t_3\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Step number of the time interval \\(t_3\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trape_amp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trape_amp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "2.74",
        "unit": null,
        "description": "Amplitude \\(A\\) of the trapezoid type electric field."
      }
    ],
    "parent_section": null,
    "description": "Amplitude \\(A\\) of the trapezoid type electric field."
  },
  {
    "name": "td_trigo_freq1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trigo_freq1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "1.164656",
        "unit": null,
        "description": "Frequency \\(f_1\\) of the trigonometric type electric field."
      }
    ],
    "parent_section": null,
    "description": "Frequency \\(f_1\\) of the trigonometric type electric field."
  },
  {
    "name": "td_trigo_freq2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trigo_freq2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.029116",
        "unit": null,
        "description": "Frequency \\(f_2\\) of the trigonometric type electric field."
      }
    ],
    "parent_section": null,
    "description": "Frequency \\(f_2\\) of the trigonometric type electric field."
  },
  {
    "name": "td_trigo_phase1",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trigo_phase1 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.0",
        "unit": null,
        "description": "Phase \\(\\varphi_1\\) of the trigonometric type electric field."
      }
    ],
    "parent_section": null,
    "description": "Phase \\(\\varphi_1\\) of the trigonometric type electric field."
  },
  {
    "name": "td_trigo_phase2",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trigo_phase2 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "0.0",
        "unit": null,
        "description": "Phase \\(\\varphi_2\\) of the trigonometric type electric field."
      }
    ],
    "parent_section": null,
    "description": "Phase \\(\\varphi_2\\) of the trigonometric type electric field."
  },
  {
    "name": "td_trigo_amp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_trigo_amp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "2.74",
        "unit": null,
        "description": "Amplitude \\(A\\) of the trigonometric type electric field."
      }
    ],
    "parent_section": null,
    "description": "Amplitude \\(A\\) of the trigonometric type electric field."
  },
  {
    "name": "td_heavi_t0",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_heavi_t0 {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "100",
        "unit": null,
        "description": "Step number of the switch time \\(t_0\\) of the Heaviside type electric field."
      }
    ],
    "parent_section": null,
    "description": "Step number of the switch time \\(t_0\\) of the Heaviside type electric field."
  },
  {
    "name": "td_heavi_amp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "td_heavi_amp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": "1.0",
        "unit": null,
        "description": "Amplitude \\(A\\) of the Heaviside type electric field."
      }
    ],
    "parent_section": null,
    "description": "Amplitude \\(A\\) of the Heaviside type electric field."
  },
  {
    "name": "out_dipole",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_dipole {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: Output electric dipole moment. False: Do not output electric dipole moment."
      }
    ],
    "parent_section": null,
    "description": "True: Output electric dipole moment. False: Do not output electric dipole moment."
  },
  {
    "name": "out_current",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_current {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: Output current. False: Do not output current."
      }
    ],
    "parent_section": null,
    "description": "True: Output current. False: Do not output current."
  },
  {
    "name": "out_current_k",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_current_k {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "True: Output current for each k-points separately. False: Output current in total."
      }
    ],
    "parent_section": null,
    "description": "True: Output current for each k-points separately. False: Output current in total."
  },
  {
    "name": "out_efield",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_efield {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to output the electric field data to files. When enabled, writes real-time electric field values (unit: ​​V/Å​​) into files named efield_[num].txt , where [num] is the ​​sequential index of the electric field ranges from 0 to N-1 for N configured fields. It is noteworthy that the field type sequence follows td_ttype , while the direction sequence follows td_vext_dire . True: Output electric field. False: Do not output electric field."
      }
    ],
    "parent_section": null,
    "description": "Whether to output the electric field data to files. When enabled, writes real-time electric field values (unit: ​​V/Å​​) into files named efield_[num].txt , where [num] is the ​​sequential index of the electric field ranges from 0 to N-1 for N configured fields. It is noteworthy that the field type sequence follows td_ttype , while the direction sequence follows td_vext_dire . True: Output electric field. False: Do not output electric field."
  },
  {
    "name": "out_vecpot",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "out_vecpot {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Output vector potential or not (unit: a.u.). True: Output vector potential into file At.dat . False: Do not output vector potential."
      }
    ],
    "parent_section": null,
    "description": "Output vector potential or not (unit: a.u.). True: Output vector potential into file At.dat . False: Do not output vector potential."
  },
  {
    "name": "init_vecpot_file",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "init_vecpot_file {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Initialize vector potential through file or not. True: Initialize vector potential from file At.dat (unit: a.u.). It consists of four columns, representing the step number and vector potential on each direction. False: Calculate vector potential by integrating the electric field."
      }
    ],
    "parent_section": null,
    "description": "Initialize vector potential through file or not. True: Initialize vector potential from file At.dat (unit: a.u.). It consists of four columns, representing the step number and vector potential on each direction. False: Calculate vector potential by integrating the electric field."
  },
  {
    "name": "ocp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ocp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": ""
      }
    ],
    "parent_section": null,
    "description": ""
  },
  {
    "name": "ocp_set",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "ocp_set {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "STRING",
        "default_value": null,
        "unit": null,
        "description": "If ocp is set to 1, ocp_set must be provided as a string specifying the occupation numbers for each band across all k-points. The format follows a space-separated pattern, where occupations are assigned sequentially to bands for each k-point. A shorthand notation N*x can be used to repeat a value x for N bands. Example: 1 10*1 0 1 represents occupations for 13 bands, where the 12th band is fully unoccupied ( 0 ), and all others are occupied ( 1 ). For a system with multiple k-points, the occupat"
      }
    ],
    "parent_section": null,
    "description": "If ocp is set to 1, ocp_set must be provided as a string specifying the occupation numbers for each band across all k-points. The format follows a space-separated pattern, where occupations are assigned sequentially to bands for each k-point. A shorthand notation N*x can be used to repeat a value x for N bands. Example: 1 10*1 0 1 represents occupations for 13 bands, where the 12th band is fully unoccupied ( 0 ), and all others are occupied ( 1 ). For a system with multiple k-points, the occupat"
  },
  {
    "name": "t_in_h",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "t_in_h {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Specify whether to include kinetic term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to include kinetic term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
  },
  {
    "name": "vl_in_h",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vl_in_h {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Specify whether to include local pseudopotential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to include local pseudopotential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
  },
  {
    "name": "vnl_in_h",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vnl_in_h {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Specify whether to include non-local pseudopotential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to include non-local pseudopotential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
  },
  {
    "name": "vh_in_h",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vh_in_h {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Specify whether to include Hartree potential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to include Hartree potential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
  },
  {
    "name": "vion_in_h",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "vion_in_h {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "1",
        "unit": null,
        "description": "Specify whether to include local ionic potential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to include local ionic potential term in obtaining the Hamiltonian matrix. 0: No. 1: Yes."
  },
  {
    "name": "test_force",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "test_force {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "0",
        "unit": null,
        "description": "Specify whether to output the detailed components in forces. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to output the detailed components in forces. 0: No. 1: Yes."
  },
  {
    "name": "test_stress",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "test_stress {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "0",
        "unit": null,
        "description": "Specify whether to output the detailed components in stress. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to output the detailed components in stress. 0: No. 1: Yes."
  },
  {
    "name": "test_skip_ewald",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "test_skip_ewald {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "0",
        "unit": null,
        "description": "Specify whether to skip the calculation of the ewald energy. 0: No. 1: Yes."
      }
    ],
    "parent_section": null,
    "description": "Specify whether to skip the calculation of the ewald energy. 0: No. 1: Yes."
  },
  {
    "name": "cal_cond",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cal_cond {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to calculate electronic conductivities."
      }
    ],
    "parent_section": null,
    "description": "Whether to calculate electronic conductivities."
  },
  {
    "name": "cond_che_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_che_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-8",
        "unit": null,
        "description": "Control the error of Chebyshev expansions for conductivities."
      }
    ],
    "parent_section": null,
    "description": "Control the error of Chebyshev expansions for conductivities."
  },
  {
    "name": "cond_dw",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_dw {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.1",
        "unit": null,
        "description": "Frequency interval ( \\(\\mathrm{d}\\omega\\) ) for frequency-dependent conductivities."
      }
    ],
    "parent_section": null,
    "description": "Frequency interval ( \\(\\mathrm{d}\\omega\\) ) for frequency-dependent conductivities."
  },
  {
    "name": "cond_wcut",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_wcut {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "10.0",
        "unit": null,
        "description": "Cutoff frequency for frequency-dependent conductivities."
      }
    ],
    "parent_section": null,
    "description": "Cutoff frequency for frequency-dependent conductivities."
  },
  {
    "name": "cond_dt",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_dt {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.02",
        "unit": null,
        "description": "Time interval ( \\(\\mathrm{d}t\\) ) to integrate Onsager coefficients."
      }
    ],
    "parent_section": null,
    "description": "Time interval ( \\(\\mathrm{d}t\\) ) to integrate Onsager coefficients."
  },
  {
    "name": "cond_dtbatch",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_dtbatch {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "exp(iH*dt*cond_dtbatch) is expanded with Chebyshev expansion to calculate conductivities. It is faster but costs more memory. If cond_dtbatch = 0 : Autoset this parameter to make expansion orders larger than 100."
      }
    ],
    "parent_section": null,
    "description": "exp(iH*dt*cond_dtbatch) is expanded with Chebyshev expansion to calculate conductivities. It is faster but costs more memory. If cond_dtbatch = 0 : Autoset this parameter to make expansion orders larger than 100."
  },
  {
    "name": "cond_smear",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_smear {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Smearing method for conductivities 1: Gaussian smearing 2: Lorentzian smearing"
      }
    ],
    "parent_section": null,
    "description": "Smearing method for conductivities 1: Gaussian smearing 2: Lorentzian smearing"
  },
  {
    "name": "cond_fwhm",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_fwhm {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.4",
        "unit": null,
        "description": "FWHM for conductivities. For Gaussian smearing, \\(\\mathrm{FWHM}=2\\sqrt{2\\ln2}s\\) ; for Lorentzian smearing, \\(\\mathrm{FWHM}=2\\gamma\\) ."
      }
    ],
    "parent_section": null,
    "description": "FWHM for conductivities. For Gaussian smearing, \\(\\mathrm{FWHM}=2\\sqrt{2\\ln2}s\\) ; for Lorentzian smearing, \\(\\mathrm{FWHM}=2\\gamma\\) ."
  },
  {
    "name": "cond_nonlocal",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "cond_nonlocal {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to consider nonlocal potential correction when calculating velocity matrix \\(\\bra{\\psi_i}\\hat{v}\\ket{\\psi_j}\\) . True: \\(m\\hat{v}=\\hat{p}+\\frac{im}{\\hbar}[\\hat{V}_{NL},\\hat{r}]\\) . False: \\(m\\hat{v}\\approx\\hat{p}\\) ."
      }
    ],
    "parent_section": null,
    "description": "Whether to consider nonlocal potential correction when calculating velocity matrix \\(\\bra{\\psi_i}\\hat{v}\\ket{\\psi_j}\\) . True: \\(m\\hat{v}=\\hat{p}+\\frac{im}{\\hbar}[\\hat{V}_{NL},\\hat{r}]\\) . False: \\(m\\hat{v}\\approx\\hat{p}\\) ."
  },
  {
    "name": "imp_sol",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "imp_sol {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Calculate implicit solvation correction"
      }
    ],
    "parent_section": null,
    "description": "Calculate implicit solvation correction"
  },
  {
    "name": "eb_k",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "eb_k {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "80",
        "unit": null,
        "description": "The relative permittivity of the bulk solvent, 80 for water"
      }
    ],
    "parent_section": null,
    "description": "The relative permittivity of the bulk solvent, 80 for water"
  },
  {
    "name": "tau",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "tau {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1.0798e-05",
        "unit": null,
        "description": "The effective surface tension parameter that describes the cavitation, the dispersion, and the repulsion interaction between the solute and the solvent which are not captured by the electrostatic terms"
      }
    ],
    "parent_section": null,
    "description": "The effective surface tension parameter that describes the cavitation, the dispersion, and the repulsion interaction between the solute and the solvent which are not captured by the electrostatic terms"
  },
  {
    "name": "sigma_k",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "sigma_k {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.6",
        "unit": null,
        "description": "The width of the diffuse cavity that is implicitly determined by the electronic structure of the solute"
      }
    ],
    "parent_section": null,
    "description": "The width of the diffuse cavity that is implicitly determined by the electronic structure of the solute"
  },
  {
    "name": "nc_k",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "nc_k {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.00037",
        "unit": null,
        "description": "The value of the electron density at which the dielectric cavity forms"
      }
    ],
    "parent_section": null,
    "description": "The value of the electron density at which the dielectric cavity forms"
  },
  {
    "name": "pexsi_npole",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_npole {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "40",
        "unit": null,
        "description": "The number of poles used in the pole expansion method, should be a even number."
      }
    ],
    "parent_section": null,
    "description": "The number of poles used in the pole expansion method, should be a even number."
  },
  {
    "name": "pexsi_inertia",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_inertia {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether inertia counting is used at the very beginning."
      }
    ],
    "parent_section": null,
    "description": "Whether inertia counting is used at the very beginning."
  },
  {
    "name": "pexsi_nmax",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_nmax {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "80",
        "unit": null,
        "description": "Maximum number of PEXSI iterations after each inertia counting procedure."
      }
    ],
    "parent_section": null,
    "description": "Maximum number of PEXSI iterations after each inertia counting procedure."
  },
  {
    "name": "pexsi_comm",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_comm {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to construct PSelInv communication pattern."
      }
    ],
    "parent_section": null,
    "description": "Whether to construct PSelInv communication pattern."
  },
  {
    "name": "pexsi_storage",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_storage {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether to use symmetric storage space used by the Selected Inversion algorithm for symmetric matrices."
      }
    ],
    "parent_section": null,
    "description": "Whether to use symmetric storage space used by the Selected Inversion algorithm for symmetric matrices."
  },
  {
    "name": "pexsi_ordering",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_ordering {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "0",
        "unit": null,
        "description": "Ordering strategy for factorization and selected inversion. 0: Parallel ordering using ParMETIS, 1: Sequential ordering using METIS, 2: Multiple minimum degree ordering"
      }
    ],
    "parent_section": null,
    "description": "Ordering strategy for factorization and selected inversion. 0: Parallel ordering using ParMETIS, 1: Sequential ordering using METIS, 2: Multiple minimum degree ordering"
  },
  {
    "name": "pexsi_row_ordering",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_row_ordering {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Row permutation strategy for factorization and selected inversion, 0: No row permutation, 1: Make the diagonal entry of the matrix larger than the off-diagonal entries."
      }
    ],
    "parent_section": null,
    "description": "Row permutation strategy for factorization and selected inversion, 0: No row permutation, 1: Make the diagonal entry of the matrix larger than the off-diagonal entries."
  },
  {
    "name": "pexsi_nproc",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_nproc {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "Number of processors for PARMETIS. Only used if pexsi_ordering == 0."
      }
    ],
    "parent_section": null,
    "description": "Number of processors for PARMETIS. Only used if pexsi_ordering == 0."
  },
  {
    "name": "pexsi_symm",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_symm {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "True",
        "unit": null,
        "description": "Whether the matrix is symmetric."
      }
    ],
    "parent_section": null,
    "description": "Whether the matrix is symmetric."
  },
  {
    "name": "pexsi_trans",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_trans {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "BOOL",
        "default_value": "False",
        "unit": null,
        "description": "Whether to factorize the transpose of the matrix."
      }
    ],
    "parent_section": null,
    "description": "Whether to factorize the transpose of the matrix."
  },
  {
    "name": "pexsi_method",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_method {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The pole expansion method to be used. 1 for Cauchy Contour Integral method, 2 for Moussa optimized method."
      }
    ],
    "parent_section": null,
    "description": "The pole expansion method to be used. 1 for Cauchy Contour Integral method, 2 for Moussa optimized method."
  },
  {
    "name": "pexsi_nproc_pole",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_nproc_pole {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "INT",
        "default_value": "1",
        "unit": null,
        "description": "The point parallelizaion of PEXSI. Recommend two points parallelization."
      }
    ],
    "parent_section": null,
    "description": "The point parallelizaion of PEXSI. Recommend two points parallelization."
  },
  {
    "name": "pexsi_temp",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_temp {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.015",
        "unit": null,
        "description": "Temperature in Fermi-Dirac distribution, in Ry, should have the same effect as the smearing sigma when smearing method is set to Fermi-Dirac."
      }
    ],
    "parent_section": null,
    "description": "Temperature in Fermi-Dirac distribution, in Ry, should have the same effect as the smearing sigma when smearing method is set to Fermi-Dirac."
  },
  {
    "name": "pexsi_gap",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_gap {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "Spectral gap, this can be set to be 0 in most cases."
      }
    ],
    "parent_section": null,
    "description": "Spectral gap, this can be set to be 0 in most cases."
  },
  {
    "name": "pexsi_delta_e",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_delta_e {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "20",
        "unit": null,
        "description": "Upper bound for the spectral radius of \\(S^{-1} H\\) ."
      }
    ],
    "parent_section": null,
    "description": "Upper bound for the spectral radius of \\(S^{-1} H\\) ."
  },
  {
    "name": "pexsi_mu_lower",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu_lower {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "-10",
        "unit": null,
        "description": "Initial guess of lower bound for mu."
      }
    ],
    "parent_section": null,
    "description": "Initial guess of lower bound for mu."
  },
  {
    "name": "pexsi_mu_upper",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu_upper {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "10",
        "unit": null,
        "description": "Initial guess of upper bound for mu."
      }
    ],
    "parent_section": null,
    "description": "Initial guess of upper bound for mu."
  },
  {
    "name": "pexsi_mu",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0",
        "unit": null,
        "description": "Initial guess for mu (for the solver)."
      }
    ],
    "parent_section": null,
    "description": "Initial guess for mu (for the solver)."
  },
  {
    "name": "pexsi_mu_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.05",
        "unit": null,
        "description": "Stopping criterion in terms of the chemical potential for the inertia counting procedure."
      }
    ],
    "parent_section": null,
    "description": "Stopping criterion in terms of the chemical potential for the inertia counting procedure."
  },
  {
    "name": "pexsi_mu_expand",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu_expand {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.3",
        "unit": null,
        "description": "If the chemical potential is not in the initial interval, the interval is expanded by this value."
      }
    ],
    "parent_section": null,
    "description": "If the chemical potential is not in the initial interval, the interval is expanded by this value."
  },
  {
    "name": "pexsi_mu_guard",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_mu_guard {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.2",
        "unit": null,
        "description": "Safe guard criterion in terms of the chemical potential to reinvoke the inertia counting procedure."
      }
    ],
    "parent_section": null,
    "description": "Safe guard criterion in terms of the chemical potential to reinvoke the inertia counting procedure."
  },
  {
    "name": "pexsi_elec_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_elec_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "0.001",
        "unit": null,
        "description": "Stopping criterion of the PEXSI iteration in terms of the number of electrons compared to numElectronExact."
      }
    ],
    "parent_section": null,
    "description": "Stopping criterion of the PEXSI iteration in terms of the number of electrons compared to numElectronExact."
  },
  {
    "name": "pexsi_zero_thr",
    "software": "ABACUS",
    "paradigm": "KEY_VALUE",
    "syntax_template": "pexsi_zero_thr {value}",
    "arguments": [
      {
        "name": "value",
        "dtype": "FLOAT",
        "default_value": "1e-10",
        "unit": null,
        "description": "if the absolute value of CCS matrix element is less than this value, it will be considered as zero."
      }
    ],
    "parent_section": null,
    "description": "if the absolute value of CCS matrix element is less than this value, it will be considered as zero."
  }
]