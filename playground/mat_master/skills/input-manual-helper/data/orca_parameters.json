{
  "software": "ORCA",
  "parameters": [
    {
      "name": "The SHARK Integral Package and Task DriverÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: The SHARK Integral Package and Task DriverÂ"
        }
      ],
      "parent_section": "shark",
      "description": "ORCA: The SHARK Integral Package and Task DriverÂ"
    },
    {
      "name": "PrefaceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "PrefaceÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting with ORCA 5.0 very large changes have taken place in the way\nthat the program handles integrals and integral related tasks like\nbuilding Fock matrices. SHARK is a powerful and efficient infrastructure\nthat greatly facilitates the handling of these tasks. This allows\ndevelopers to write highly streamlined code with optimal performance and\na high degree of reliability. Compared to the way O"
        }
      ],
      "parent_section": "shark",
      "description": "Starting with ORCA 5.0 very large changes have taken place in the way\nthat the program handles integrals and integral related tasks like\nbuilding Fock matrices. SHARK is a powerful and efficient infrastructure\nthat greatly facilitates the handling of these tasks. This allows\ndevelopers to write highly streamlined code with optimal performance and\na high degree of reliability. Compared to the way O"
    },
    {
      "name": "The SHARK integral algorithmÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The SHARK integral algorithmÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "One cornerstone of SHARK is a new integral algorithm that allows for\nhighly efficient evaluation of molecular integrals. The algorithm is\nbased on the beautiful McMurchie-Davidson algorithm which leads to the\nfollowing equation for a given two-electron integral:"
        }
      ],
      "parent_section": "shark",
      "description": "One cornerstone of SHARK is a new integral algorithm that allows for\nhighly efficient evaluation of molecular integrals. The algorithm is\nbased on the beautiful McMurchie-Davidson algorithm which leads to the\nfollowing equation for a given two-electron integral:"
    },
    {
      "name": "SHARK and libintÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "SHARK and libintÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Up to ORCA 4.2.1, ORCA has almost entirely relied on the libint2\nintegral library which is known to be very efficient and powerful.\nStarting from ORCA 5.0, both SHARK and libint are used for integral\nevaluations and libint is fully integrated into the SHARK programming\nenvironment. Integrals that are only available in one of the packages\nare done with this package (e. g. GIAO, SOC and Spin-Spin in"
        }
      ],
      "parent_section": "shark",
      "description": "Up to ORCA 4.2.1, ORCA has almost entirely relied on the libint2\nintegral library which is known to be very efficient and powerful.\nStarting from ORCA 5.0, both SHARK and libint are used for integral\nevaluations and libint is fully integrated into the SHARK programming\nenvironment. Integrals that are only available in one of the packages\nare done with this package (e. g. GIAO, SOC and Spin-Spin in"
    },
    {
      "name": "Basis set typesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Basis set typesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "One significant aspect of molecular integral evaluation is the type of\ncontraction that is present in a Gaussian basis set. The most general\ntype of basis set is met in the âgeneral contractionâ scheme. Here all\nprimitive Gaussian basis functions of a given angular momentum are\ncollected in a vector\\(\\left\\{\\phi  \\right\\}\\). In general, all\nprimitives will contribute to all basis functions\\(\\l"
        }
      ],
      "parent_section": "shark",
      "description": "One significant aspect of molecular integral evaluation is the type of\ncontraction that is present in a Gaussian basis set. The most general\ntype of basis set is met in the âgeneral contractionâ scheme. Here all\nprimitive Gaussian basis functions of a given angular momentum are\ncollected in a vector\\(\\left\\{\\phi  \\right\\}\\). In general, all\nprimitives will contribute to all basis functions\\(\\l"
    },
    {
      "name": "Task driversÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Task driversÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In traditional algorithms, quantum chemical programs frequently contain\nmany instances of nested loops over basis function shells, the integral\npackage is called and the integrals are âdigestedâ for a given task.\nWhile these steps are inevitable, programming them repeatedly is\nlaborious and error prone. In addition, improvements, say in the\nhandling of contractions or symmetry, need to impleme"
        }
      ],
      "parent_section": "shark",
      "description": "In traditional algorithms, quantum chemical programs frequently contain\nmany instances of nested loops over basis function shells, the integral\npackage is called and the integrals are âdigestedâ for a given task.\nWhile these steps are inevitable, programming them repeatedly is\nlaborious and error prone. In addition, improvements, say in the\nhandling of contractions or symmetry, need to impleme"
    },
    {
      "name": "SHARK User InterfaceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "SHARK User InterfaceÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "While SHARK is a large and complicated machinery, we have deliberately\nkept the interface as straightforward and simple as possible. There are\nonly a few flags that can be set that are explained below:"
        }
      ],
      "parent_section": "shark",
      "description": "While SHARK is a large and complicated machinery, we have deliberately\nkept the interface as straightforward and simple as possible. There are\nonly a few flags that can be set that are explained below:"
    },
    {
      "name": "More on Coordinate InputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: More on Coordinate InputÂ"
        }
      ],
      "parent_section": "coords",
      "description": "ORCA: More on Coordinate InputÂ"
    },
    {
      "name": "Fragment SpecificationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Fragment SpecificationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The atoms in the molecule can be assigned to certainfragments. This\nhelps to organize the output in the population analysis section, is used\nfor the fragment optimization feature, for the local energy\ndecomposition and for multi-level calculations. There are two options to\nassign atoms to fragments. The first option is to assign a given atom to\na given fragment by putting a(n)directly after the at"
        }
      ],
      "parent_section": "coords",
      "description": "The atoms in the molecule can be assigned to certainfragments. This\nhelps to organize the output in the population analysis section, is used\nfor the fragment optimization feature, for the local energy\ndecomposition and for multi-level calculations. There are two options to\nassign atoms to fragments. The first option is to assign a given atom to\na given fragment by putting a(n)directly after the at"
    },
    {
      "name": "Defining Geometry Parameters and Scanning Potential Energy SurfacesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Defining Geometry Parameters and Scanning Potential Energy SurfacesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA lets you define the coordinates of all atoms as functions of user\ndefined geometry parameters. By giving not only a value but a range of\nvalues (or a list of values) to this parameters potential energy\nsurfaces can be scanned. In this case the variableRunTypis\nautomatically changed toScan. The format for the parameter\nspecification is straightforward:"
        }
      ],
      "parent_section": "coords",
      "description": "ORCA lets you define the coordinates of all atoms as functions of user\ndefined geometry parameters. By giving not only a value but a range of\nvalues (or a list of values) to this parameters potential energy\nsurfaces can be scanned. In this case the variableRunTypis\nautomatically changed toScan. The format for the parameter\nspecification is straightforward:"
    },
    {
      "name": "Mixing internal and Cartesian coordinatesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Mixing internal and Cartesian coordinatesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In some cases it may be practical to define some atomic positions in\nCartesian and some in internal coordinates. This can be achieved by\nspecifying all coordinates in the*intblock: using â0 0 0â as\nreference atoms indicates Cartesian coordinates. Note that for the first\natom the flags are â1 1 1â, as â0 0 0â would be the normal values for\ninternal coordinates. Consider, for example, th"
        }
      ],
      "parent_section": "coords",
      "description": "In some cases it may be practical to define some atomic positions in\nCartesian and some in internal coordinates. This can be achieved by\nspecifying all coordinates in the*intblock: using â0 0 0â as\nreference atoms indicates Cartesian coordinates. Note that for the first\natom the flags are â1 1 1â, as â0 0 0â would be the normal values for\ninternal coordinates. Consider, for example, th"
    },
    {
      "name": "Inclusion of Point ChargesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Inclusion of Point ChargesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In some situations it is desirable to add point charges to the system.\nIn ORCA there are two mechanisms to add point-charges. If you only want\nto add a few point charges you can âmaskâ them as atoms as in the\nfollowing (nonsense) input:"
        }
      ],
      "parent_section": "coords",
      "description": "In some situations it is desirable to add point charges to the system.\nIn ORCA there are two mechanisms to add point-charges. If you only want\nto add a few point charges you can âmaskâ them as atoms as in the\nfollowing (nonsense) input:"
    },
    {
      "name": "Details on the numerical integration gridsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Details on the numerical integration gridsÂ"
        }
      ],
      "parent_section": "numint",
      "description": "ORCA: Details on the numerical integration gridsÂ"
    },
    {
      "name": "The angular grid schemeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The angular grid schemeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Instead of using a single angular grid throughout the whole atom, most\nschemes apply a so-called grid pruning in order to reduce the number of\ngrid points outside of the most important regions, as we do in ORCA. In\nthe current scheme, we split the atomic grids into five regions, using\nLebedev grids with the following number of points on each of those:"
        }
      ],
      "parent_section": "numint",
      "description": "Instead of using a single angular grid throughout the whole atom, most\nschemes apply a so-called grid pruning in order to reduce the number of\ngrid points outside of the most important regions, as we do in ORCA. In\nthe current scheme, we split the atomic grids into five regions, using\nLebedev grids with the following number of points on each of those:"
    },
    {
      "name": "The radial grid schemeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The radial grid schemeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The number of radial points (\\(n_r\\)) for a given atom is simply defined\nusing the equation first defined by Krack and KÃ¶ster:"
        }
      ],
      "parent_section": "numint",
      "description": "The number of radial points (\\(n_r\\)) for a given atom is simply defined\nusing the equation first defined by Krack and KÃ¶ster:"
    },
    {
      "name": "The DEFGRIDsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The DEFGRIDsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "With all that in mind, we can now present how the DEFGRIDs are built in\nterms of their AngularGrid scheme and IntAccs, which define the angular\nand radial parts of the atomic grids. More details can be found in\nRef.Â[383]."
        }
      ],
      "parent_section": "numint",
      "description": "With all that in mind, we can now present how the DEFGRIDs are built in\nterms of their AngularGrid scheme and IntAccs, which define the angular\nand radial parts of the atomic grids. More details can be found in\nRef.Â[383]."
    },
    {
      "name": "Other details and optionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Other details and optionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The new adaptive pruning.The current pruning scheme uses lower\ngrids close to the nucleus, and far away from the bonding region.\nHowever, if the basis set has polarized functions close to the nuclei,\nor diffuse Gaussians, this might not be sufficient."
        }
      ],
      "parent_section": "numint",
      "description": "The new adaptive pruning.The current pruning scheme uses lower\ngrids close to the nucleus, and far away from the bonding region.\nHowever, if the basis set has polarized functions close to the nuclei,\nor diffuse Gaussians, this might not be sufficient."
    },
    {
      "name": "SCF grid keyword listÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "SCF grid keyword listÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A complete description of the SCF grid options is given below. There are\nkeywords specific to the XC integration, COSX integration and a general\npart that applies to all:"
        }
      ],
      "parent_section": "numint",
      "description": "A complete description of the SCF grid options is given below. There are\nkeywords specific to the XC integration, COSX integration and a general\npart that applies to all:"
    },
    {
      "name": "Changing TD-DFT, CP-SCF and Hessian gridsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Changing TD-DFT, CP-SCF and Hessian gridsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "TD-DFT.The grids used in CIS or TD-DFT can be changed in their\nrespective block:"
        }
      ],
      "parent_section": "numint",
      "description": "TD-DFT.The grids used in CIS or TD-DFT can be changed in their\nrespective block:"
    },
    {
      "name": "When should I change from the default grids?Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "When should I change from the default grids?Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In general, the errors from the default grids are rather small and\nreasonable for most applications. After benchmarking against the GMTNK55\ntest set with the default !DEFGRID2, we found an error of about\\(0.01 \\pm 0.03\\)kcal/mol from DFT (compared to a reference grid), and\\(0.05 \\pm 0.10\\)kcal/mol for the COSX (compared to the analytical\nintegration). We also benchmarked geometries, excitation ene"
        }
      ],
      "parent_section": "numint",
      "description": "In general, the errors from the default grids are rather small and\nreasonable for most applications. After benchmarking against the GMTNK55\ntest set with the default !DEFGRID2, we found an error of about\\(0.01 \\pm 0.03\\)kcal/mol from DFT (compared to a reference grid), and\\(0.05 \\pm 0.10\\)kcal/mol for the COSX (compared to the analytical\nintegration). We also benchmarked geometries, excitation ene"
    },
    {
      "name": "Choice of Computational ModelÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Choice of Computational ModelÂ"
        }
      ],
      "parent_section": "model",
      "description": "ORCA: Choice of Computational ModelÂ"
    },
    {
      "name": "Features Common to All CalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Features Common to All CalculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The computational model is specified in the block%method. The\nfollowing choices exist:"
        }
      ],
      "parent_section": "model",
      "description": "The computational model is specified in the block%method. The\nfollowing choices exist:"
    },
    {
      "name": "Density Functional CalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Density Functional CalculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Density Functional CalculationsÂ"
        }
      ],
      "parent_section": "model",
      "description": "ORCA: Density Functional CalculationsÂ"
    },
    {
      "name": "Semiempirical MethodsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Semiempirical MethodsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The present version of ORCA has inherited the capability of doing\nsemiempirical calculations from the earlier versions. A number of\nmethods based on the âneglect of differential overlapâ[692,779]are currently implemented for\nenergies and analytic gradients (for geometry optimization)."
        }
      ],
      "parent_section": "model",
      "description": "The present version of ORCA has inherited the capability of doing\nsemiempirical calculations from the earlier versions. A number of\nmethods based on the âneglect of differential overlapâ[692,779]are currently implemented for\nenergies and analytic gradients (for geometry optimization)."
    },
    {
      "name": "Choice of Basis SetÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Choice of Basis SetÂ"
        }
      ],
      "parent_section": "basisset",
      "description": "ORCA: Choice of Basis SetÂ"
    },
    {
      "name": "Built-in Basis SetsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Built-in Basis SetsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The basis set is specified in the block%BASIS. Note that there are\nthree distinguished slots for auxiliary basis sets (AuxJ, AuxC and\nAuxJK) to be used with RI approximation. Which auxiliary basis slot is\nused in the actual program depends on the context. The AuxJ and AuxJK\nslots are used in the context of Fock matrix construction, whereas the\nAuxC slot is used for all other integral generation st"
        }
      ],
      "parent_section": "basisset",
      "description": "The basis set is specified in the block%BASIS. Note that there are\nthree distinguished slots for auxiliary basis sets (AuxJ, AuxC and\nAuxJK) to be used with RI approximation. Which auxiliary basis slot is\nused in the actual program depends on the context. The AuxJ and AuxJK\nslots are used in the context of Fock matrix construction, whereas the\nAuxC slot is used for all other integral generation st"
    },
    {
      "name": "Automatic generation of auxiliary basis setsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Automatic generation of auxiliary basis setsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "If no auxiliary basis set is available for your chosen orbital basis\nset, one can be generated automatically by ORCA using the keywordAutoAux. This is specified as any other fitting basis set: as a value\nto theAuxJ/AuxJK/AuxCvariables in the%basisblock or as a\nseparate keyword in the simple input line (in which case all three Aux\nslots are populated with identical fitting basis sets).AutoAuxcan\nal"
        }
      ],
      "parent_section": "basisset",
      "description": "If no auxiliary basis set is available for your chosen orbital basis\nset, one can be generated automatically by ORCA using the keywordAutoAux. This is specified as any other fitting basis set: as a value\nto theAuxJ/AuxJK/AuxCvariables in the%basisblock or as a\nseparate keyword in the simple input line (in which case all three Aux\nslots are populated with identical fitting basis sets).AutoAuxcan\nal"
    },
    {
      "name": "Assigning or Adding Basis Functions to an ElementÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Assigning or Adding Basis Functions to an ElementÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In order to assign a new basis set to a given element, use:"
        }
      ],
      "parent_section": "basisset",
      "description": "In order to assign a new basis set to a given element, use:"
    },
    {
      "name": "Assigning or Adding Basis Functions to Individual AtomsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Assigning or Adding Basis Functions to Individual AtomsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Sometimes you may want to not treat all carbon atoms with the same basis\nset but to assign a specific basis set to a specific atom in the\nmolecules. This is also possible in ORCA and takes place in the\ncoordinate section (%coords,*xyz, etc.). The format is the same as\ndescribed above. An example may help to make things clear:"
        }
      ],
      "parent_section": "basisset",
      "description": "Sometimes you may want to not treat all carbon atoms with the same basis\nset but to assign a specific basis set to a specific atom in the\nmolecules. This is also possible in ORCA and takes place in the\ncoordinate section (%coords,*xyz, etc.). The format is the same as\ndescribed above. An example may help to make things clear:"
    },
    {
      "name": "Assigning Basis Sets and ECPs to FragmentsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Assigning Basis Sets and ECPs to FragmentsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In multi-level or QM/QM calculations it may be convenient to assign\ndifferent basis sets to different fragments. This can be done with the\nkeywordsFragBasis,FragAuxJ,FragAuxJK,FragAuxC,FragCABS,\nandFragECPin the%basisblock, followed by the number of the\nfragment (numbering starts at 1!) and a standard basis set or ECP from\nthe ORCA library (see\nTablesÂTable 7.9andTable 4.2). Note that unlike theNe"
        }
      ],
      "parent_section": "basisset",
      "description": "In multi-level or QM/QM calculations it may be convenient to assign\ndifferent basis sets to different fragments. This can be done with the\nkeywordsFragBasis,FragAuxJ,FragAuxJK,FragAuxC,FragCABS,\nandFragECPin the%basisblock, followed by the number of the\nfragment (numbering starts at 1!) and a standard basis set or ECP from\nthe ORCA library (see\nTablesÂTable 7.9andTable 4.2). Note that unlike theNe"
    },
    {
      "name": "Reading Orbital and Auxiliary Basis Sets from a FileÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Reading Orbital and Auxiliary Basis Sets from a FileÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "By using the variablesGTOName,GTOAuxJName,GTOAuxJKName,GTOAuxCName, andGTOCABSName(GTOAuxNameis a synonym forGTOAuxJName) a basis set can be read from an ASCII file. In this way\nyou can construct or modify your favorite standard basis set and load it\neasily into the program."
        }
      ],
      "parent_section": "basisset",
      "description": "By using the variablesGTOName,GTOAuxJName,GTOAuxJKName,GTOAuxCName, andGTOCABSName(GTOAuxNameis a synonym forGTOAuxJName) a basis set can be read from an ASCII file. In this way\nyou can construct or modify your favorite standard basis set and load it\neasily into the program."
    },
    {
      "name": "Advanced Specification of Effective Core PotentialsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Advanced Specification of Effective Core PotentialsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Advanced Specification of Effective Core PotentialsÂ"
        }
      ],
      "parent_section": "basisset",
      "description": "ORCA: Advanced Specification of Effective Core PotentialsÂ"
    },
    {
      "name": "Embedding PotentialsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Embedding PotentialsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Computations on cluster models sometimes require the presence of\nembedding potentials in order to account for otherwise neglected\nrepulsive terms at the border[304]. In order to simplify\nthese kind of calculations with ORCA the ECP embedding can be\naccomplished quite easily:"
        }
      ],
      "parent_section": "basisset",
      "description": "Computations on cluster models sometimes require the presence of\nembedding potentials in order to account for otherwise neglected\nrepulsive terms at the border[304]. In order to simplify\nthese kind of calculations with ORCA the ECP embedding can be\naccomplished quite easily:"
    },
    {
      "name": "Linear DependenceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Linear DependenceÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The previous sections describe the assessment of a desired molecular\nbasis set from appropriately parametrized functions at various locations\nwithin the molecule (normally centered on atoms). The parametrization of\nthese functions is such that the chance for redundancy is minimal. Since\nhowever, one is limited to work with finite numerical precision, and\nfurthermore these parameters also depend on"
        }
      ],
      "parent_section": "basisset",
      "description": "The previous sections describe the assessment of a desired molecular\nbasis set from appropriately parametrized functions at various locations\nwithin the molecule (normally centered on atoms). The parametrization of\nthese functions is such that the chance for redundancy is minimal. Since\nhowever, one is limited to work with finite numerical precision, and\nfurthermore these parameters also depend on"
    },
    {
      "name": "Choice of Initial Guess and Restart of SCF CalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Choice of Initial Guess and Restart of SCF CalculationsÂ"
        }
      ],
      "parent_section": "initguess",
      "description": "ORCA: Choice of Initial Guess and Restart of SCF CalculationsÂ"
    },
    {
      "name": "AutoStart featureÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "AutoStart featureÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Older versions of ORCA always created a new GBW file at the beginning of\nthe run no matter whether a file of the same name existed or perhaps\ncontained orbitals. Now, in the case of single-point calculations the\nprogram automatically checks if a.gbwfile of the same name exists.\nIf yes, the program checks if it contains orbitals and all other\nnecessary information for a restart. If yes, the variabl"
        }
      ],
      "parent_section": "initguess",
      "description": "Older versions of ORCA always created a new GBW file at the beginning of\nthe run no matter whether a file of the same name existed or perhaps\ncontained orbitals. Now, in the case of single-point calculations the\nprogram automatically checks if a.gbwfile of the same name exists.\nIf yes, the program checks if it contains orbitals and all other\nnecessary information for a restart. If yes, the variabl"
    },
    {
      "name": "One Electron Matrix GuessÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "One Electron Matrix GuessÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The simplest guess is to diagonalize the one electron matrix to obtain\nstarting orbitals. This guess is very simple but usually also a disaster\nbecause it produces orbitals that are far too compact."
        }
      ],
      "parent_section": "initguess",
      "description": "The simplest guess is to diagonalize the one electron matrix to obtain\nstarting orbitals. This guess is very simple but usually also a disaster\nbecause it produces orbitals that are far too compact."
    },
    {
      "name": "Basis Set ProjectionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Basis Set ProjectionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The remaining guesses (may) need the projection of initial guess\norbitals onto the actual basis set. In ORCA there are two ways this can\nbe done.GuessModeFMatrixandGuessModeCMatrix. The results from\nthe two methods are usually rather similar. In certain casesGuessModeCMatrixmay be preferable.GuessModeFMatrixis simpler\nand faster. In short theFMatrixprojection defines an effective one\nelectron oper"
        }
      ],
      "parent_section": "initguess",
      "description": "The remaining guesses (may) need the projection of initial guess\norbitals onto the actual basis set. In ORCA there are two ways this can\nbe done.GuessModeFMatrixandGuessModeCMatrix. The results from\nthe two methods are usually rather similar. In certain casesGuessModeCMatrixmay be preferable.GuessModeFMatrixis simpler\nand faster. In short theFMatrixprojection defines an effective one\nelectron oper"
    },
    {
      "name": "PModel GuessÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "PModel GuessÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The PModel guess (chosen byGuessPModelin the%scfblock or simply\na keyword line with!PModel) is one that is usually considerably\nsuccessful. It consists of building and diagonalizing a KohnâSham\nmatrix with an electron density which consists of the superposition of\nspherical neutral atoms densities which are predetermined for both\nrelativistic and nonrelativistic methods. This guess is valid for "
        }
      ],
      "parent_section": "initguess",
      "description": "The PModel guess (chosen byGuessPModelin the%scfblock or simply\na keyword line with!PModel) is one that is usually considerably\nsuccessful. It consists of building and diagonalizing a KohnâSham\nmatrix with an electron density which consists of the superposition of\nspherical neutral atoms densities which are predetermined for both\nrelativistic and nonrelativistic methods. This guess is valid for "
    },
    {
      "name": "HÃ¼ckel and PAtom GuessesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "HÃ¼ckel and PAtom GuessesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The extended HÃ¼ckel guess proceeds by performing a minimal basis\nextended HÃ¼ckel calculation and projecting the MOs from this calculation\nonto the actual basis set using one of the two methods described above.\nThe minimal basis is the STO-3G basis set. The HÃ¼ckel guess may not be\nvery good because the STO-3G basis set is so poor. There is also\naccumulating evidence that the superposition of ato"
        }
      ],
      "parent_section": "initguess",
      "description": "The extended HÃ¼ckel guess proceeds by performing a minimal basis\nextended HÃ¼ckel calculation and projecting the MOs from this calculation\nonto the actual basis set using one of the two methods described above.\nThe minimal basis is the STO-3G basis set. The HÃ¼ckel guess may not be\nvery good because the STO-3G basis set is so poor. There is also\naccumulating evidence that the superposition of ato"
    },
    {
      "name": "Restarting SCF CalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Restarting SCF CalculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "To restart SCF calculations, it can be very helpful and time-saving to\nread in the orbital information of a previous calculation. To do this,\nspecify:"
        }
      ],
      "parent_section": "initguess",
      "description": "To restart SCF calculations, it can be very helpful and time-saving to\nread in the orbital information of a previous calculation. To do this,\nspecify:"
    },
    {
      "name": "Automatically Breaking of the Initial Guess SymmetryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Automatically Breaking of the Initial Guess SymmetryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Another simple way to break the initial guess symmetry for more trivial cases, is to simply use the keyword!GUESSMIX. This will automatically mix 50% of the alpha LUMO into the alpha HOMO. That is equivalent to a 45 degree rotation as done above and only for these orbitals. It might be useful when one wants an open-shell singlet and needs the alpha and beta orbitals to start differently."
        }
      ],
      "parent_section": "initguess",
      "description": "Another simple way to break the initial guess symmetry for more trivial cases, is to simply use the keyword!GUESSMIX. This will automatically mix 50% of the alpha LUMO into the alpha HOMO. That is equivalent to a 45 degree rotation as done above and only for these orbitals. It might be useful when one wants an open-shell singlet and needs the alpha and beta orbitals to start differently."
    },
    {
      "name": "Calculating only the energy of an input densityÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Calculating only the energy of an input densityÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In case you want to give the result of a previous SCF and recalculate the energy,\nor maybe some other property (like the MP2 energy) using that density without changing the orbitals,\nyou can use the flags!CALCGUESSENERGYNOITER."
        }
      ],
      "parent_section": "initguess",
      "description": "In case you want to give the result of a previous SCF and recalculate the energy,\nor maybe some other property (like the MP2 energy) using that density without changing the orbitals,\nyou can use the flags!CALCGUESSENERGYNOITER."
    },
    {
      "name": "SCF ConvergenceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: SCF ConvergenceÂ"
        }
      ],
      "parent_section": "scfconv",
      "description": "ORCA: SCF ConvergenceÂ"
    },
    {
      "name": "Convergence TolerancesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Convergence TolerancesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Before discussing how to converge a SCF calculation it should be defined\nwhat is meant by âconvergedâ. ORCA has a variety of options to control\nthe target precision of the energy and the wavefunction that can be\nselected in the%Â scfblock, or with a simple input line keyword that\nmerges the criterion label with âSCFâ, e.g.!Â StrongSCFor!Â VeryTightSCF:"
        }
      ],
      "parent_section": "scfconv",
      "description": "Before discussing how to converge a SCF calculation it should be defined\nwhat is meant by âconvergedâ. ORCA has a variety of options to control\nthe target precision of the energy and the wavefunction that can be\nselected in the%Â scfblock, or with a simple input line keyword that\nmerges the criterion label with âSCFâ, e.g.!Â StrongSCFor!Â VeryTightSCF:"
    },
    {
      "name": "Dynamic and Static DampingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Dynamic and Static DampingÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Damping is the oldest and simplest convergence aid. It was already\ninvented by Douglas Hartree when he did his famous atomic calculations.\nDamping consists of mixing the old density with the new density as:"
        }
      ],
      "parent_section": "scfconv",
      "description": "Damping is the oldest and simplest convergence aid. It was already\ninvented by Douglas Hartree when he did his famous atomic calculations.\nDamping consists of mixing the old density with the new density as:"
    },
    {
      "name": "Level ShiftingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Level ShiftingÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Level shifting is a frequently used technique. The basic idea is to\nshift the energies of the virtual orbitals such that after\ndiagonalization the occupied and virtual orbitals mix less strongly and\nthe calculation converges more smoothly towards the desired state. Also,\nlevel shifting should prevent flipping of electronic states in\nnear-degenerate cases. In a special context it has been shown by\n"
        }
      ],
      "parent_section": "scfconv",
      "description": "Level shifting is a frequently used technique. The basic idea is to\nshift the energies of the virtual orbitals such that after\ndiagonalization the occupied and virtual orbitals mix less strongly and\nthe calculation converges more smoothly towards the desired state. Also,\nlevel shifting should prevent flipping of electronic states in\nnear-degenerate cases. In a special context it has been shown by\n"
    },
    {
      "name": "Direct Inversion in Iterative Subspace (DIIS)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Direct Inversion in Iterative Subspace (DIIS)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The direct inversion in iterative subspace (DIIS) is a technique\nthat was invented by Pulay[702,703]. It has\nbecome thede factostandard in most modern electronic structure\nprograms, because DIIS is robust, efficient and easy to implement.\nBasically DIIS uses a criterion to judge how far a given trial density\nis from self-consistency. The commutator of the Fock and density\nmatrices [F,P] is a conve"
        }
      ],
      "parent_section": "scfconv",
      "description": "The direct inversion in iterative subspace (DIIS) is a technique\nthat was invented by Pulay[702,703]. It has\nbecome thede factostandard in most modern electronic structure\nprograms, because DIIS is robust, efficient and easy to implement.\nBasically DIIS uses a criterion to judge how far a given trial density\nis from self-consistency. The commutator of the Fock and density\nmatrices [F,P] is a conve"
    },
    {
      "name": "An alternative DIIS algorithm: KDIISÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "An alternative DIIS algorithm: KDIISÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "An alternative algorithm that makes use of the DIIS concept is called\nKDIIS (Kolmarâs DIIS[452,453]) in ORCA. The KDIIS algorithm is designed to bring the orbital\ngradient of any energy expression to zero using a combination of DIIS\nextrapolation and first order perturbation theory. Thus, the method is\ndiagonalization-free. In our hands it is superior to the standard DIIS\nalgorithm in many cases"
        }
      ],
      "parent_section": "scfconv",
      "description": "An alternative algorithm that makes use of the DIIS concept is called\nKDIIS (Kolmarâs DIIS[452,453]) in ORCA. The KDIIS algorithm is designed to bring the orbital\ngradient of any energy expression to zero using a combination of DIIS\nextrapolation and first order perturbation theory. Thus, the method is\ndiagonalization-free. In our hands it is superior to the standard DIIS\nalgorithm in many cases"
    },
    {
      "name": "Approximate Second Order SCF (SOSCF)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Approximate Second Order SCF (SOSCF)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "SOSCF is an approximately quadratically convergent variant of the SCF\nprocedure[264,608]. The theory is relatively\ninvolved and will not be described here. In short â SOSCF computes an\ninitial guess to the inverse orbital Hessian and then uses the BFGS\nformula in a recursive way to update orbital rotation angles. As\ninformation from a few iterations accumulates, the guess to the inverse\norbital "
        }
      ],
      "parent_section": "scfconv",
      "description": "SOSCF is an approximately quadratically convergent variant of the SCF\nprocedure[264,608]. The theory is relatively\ninvolved and will not be described here. In short â SOSCF computes an\ninitial guess to the inverse orbital Hessian and then uses the BFGS\nformula in a recursive way to update orbital rotation angles. As\ninformation from a few iterations accumulates, the guess to the inverse\norbital "
    },
    {
      "name": "Trust-Region Augmented Hessian (TRAH) SCFÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Trust-Region Augmented Hessian (TRAH) SCFÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The trust-region augmented Hessian (!Â TRAH)\napproach[64,349,381,735]should be used if the standard SCF\nsolver[264,608,703,704]DIIS+SOSCF fails or is expected to fail. TRAH-SCF should converge for\nany system. Convergence to the electronic ground state is also\nguaranteed because information of the electronic Hessian is exploited."
        }
      ],
      "parent_section": "scfconv",
      "description": "The trust-region augmented Hessian (!Â TRAH)\napproach[64,349,381,735]should be used if the standard SCF\nsolver[264,608,703,704]DIIS+SOSCF fails or is expected to fail. TRAH-SCF should converge for\nany system. Convergence to the electronic ground state is also\nguaranteed because information of the electronic Hessian is exploited."
    },
    {
      "name": "Finite Temperature HF/KS-DFTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Finite Temperature HF/KS-DFTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A finite temperature can be used to apply a Fermi-like occupation number\nsmearing over the orbitals of the system, which may sometimes help to\nget convergence of the SCF equations in near hopeless cases. Through the\nsmearing, the electrons are distributed according to Fermi statistics\namong the available orbitals. The âchemical potentialâ is found through\nthe condition that the total number of"
        }
      ],
      "parent_section": "scfconv",
      "description": "A finite temperature can be used to apply a Fermi-like occupation number\nsmearing over the orbitals of the system, which may sometimes help to\nget convergence of the SCF equations in near hopeless cases. Through the\nsmearing, the electrons are distributed according to Fermi statistics\namong the available orbitals. The âchemical potentialâ is found through\nthe condition that the total number of"
    },
    {
      "name": "Choice of Wavefunction and Integral HandlingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Choice of Wavefunction and Integral HandlingÂ"
        }
      ],
      "parent_section": "wavefunction",
      "description": "ORCA: Choice of Wavefunction and Integral HandlingÂ"
    },
    {
      "name": "Choice of Wavefunction TypeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Choice of Wavefunction TypeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The basic variable that controls the type of wavefunction to be computed\nis the variableHFTypin the%scfblock. If nothing is specified forHFTyp, the program will check the multiplicity given in the input: for\nclosed-shell molecules with multiplicity 1, RHF/RKS is assumed; for open\nshell molecules with multiplicity larger than 1, UHF/UKS is invoked.RHFwill lead to a spin restricted closed-shell type"
        }
      ],
      "parent_section": "wavefunction",
      "description": "The basic variable that controls the type of wavefunction to be computed\nis the variableHFTypin the%scfblock. If nothing is specified forHFTyp, the program will check the multiplicity given in the input: for\nclosed-shell molecules with multiplicity 1, RHF/RKS is assumed; for open\nshell molecules with multiplicity larger than 1, UHF/UKS is invoked.RHFwill lead to a spin restricted closed-shell type"
    },
    {
      "name": "ROHF OptionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "ROHF OptionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For ROHF\ncalculations[102,112,125,141,243,452,453,575,598]the program will try to figure out what type of open-shell situation is\npresent on the basis of the initial guess orbitals and their energies.\nMost âsimpleâ cases are well recognized, but sometimes a little help from\nthe user is needed."
        }
      ],
      "parent_section": "wavefunction",
      "description": "For ROHF\ncalculations[102,112,125,141,243,452,453,575,598]the program will try to figure out what type of open-shell situation is\npresent on the basis of the initial guess orbitals and their energies.\nMost âsimpleâ cases are well recognized, but sometimes a little help from\nthe user is needed."
    },
    {
      "name": "UHF Natural OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "UHF Natural OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The program can produce the UHF natural orbitals (UNOs). With these, the\nopen-shell wavefunction can be pictured conveniently. The syntax is\nsimple:"
        }
      ],
      "parent_section": "wavefunction",
      "description": "The program can produce the UHF natural orbitals (UNOs). With these, the\nopen-shell wavefunction can be pictured conveniently. The syntax is\nsimple:"
    },
    {
      "name": "Integral Handling (Conventional and Direct)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Integral Handling (Conventional and Direct)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "As the number of nonzero integrals grows very rapidly and reaches easily\nhundreds of millions even with medium sized basis sets in medium sized\nmolecules, storage of all integrals is not generally feasible. This\ndesperate situation prevented SCF calculations on larger molecules for\nquite some time, so that AlmlÃ¶f[19,20,21]made the\ninsightful suggestion to repeat the integral calculation, which wa"
        }
      ],
      "parent_section": "wavefunction",
      "description": "As the number of nonzero integrals grows very rapidly and reaches easily\nhundreds of millions even with medium sized basis sets in medium sized\nmolecules, storage of all integrals is not generally feasible. This\ndesperate situation prevented SCF calculations on larger molecules for\nquite some time, so that AlmlÃ¶f[19,20,21]made the\ninsightful suggestion to repeat the integral calculation, which wa"
    },
    {
      "name": "DeltaSCF: Converging to Arbitrary Single-Reference WavefunctionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: DeltaSCF: Converging to Arbitrary Single-Reference WavefunctionsÂ"
        }
      ],
      "parent_section": "deltascf",
      "description": "ORCA: DeltaSCF: Converging to Arbitrary Single-Reference WavefunctionsÂ"
    },
    {
      "name": "First Example: HOMO-LUMO Excited State of FormaldehydeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "First Example: HOMO-LUMO Excited State of FormaldehydeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Letâs begin by trying to converge and optimize to the first excited state of formaldehyde, starting from its regular planar structure:"
        }
      ],
      "parent_section": "deltascf",
      "description": "Letâs begin by trying to converge and optimize to the first excited state of formaldehyde, starting from its regular planar structure:"
    },
    {
      "name": "Core-ionized StatesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core-ionized StatesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Another big advantage of theDeltaSCFis the possibility to converge to core-excited and/or core-ionized states. We have a simple keyword to kick out electrons from any orbital, even the deep core ones:"
        }
      ],
      "parent_section": "deltascf",
      "description": "Another big advantage of theDeltaSCFis the possibility to converge to core-excited and/or core-ionized states. We have a simple keyword to kick out electrons from any orbital, even the deep core ones:"
    },
    {
      "name": "Diabatic CouplingsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Diabatic CouplingsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "DeltaSCFis also a quite accurate method to obtained diabatic couplings, which can later be used in Markus theory to compute electron transfer rates. These can be computed by calculating the energy difference between electron transfer states and using the Generalized Mulliken-Hush Approach (GMH). For more details please check for example this paper from the group of Blumberger[477]."
        }
      ],
      "parent_section": "deltascf",
      "description": "DeltaSCFis also a quite accurate method to obtained diabatic couplings, which can later be used in Markus theory to compute electron transfer rates. These can be computed by calculating the energy difference between electron transfer states and using the Generalized Mulliken-Hush Approach (GMH). For more details please check for example this paper from the group of Blumberger[477]."
    },
    {
      "name": "Full keyword listÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Full keyword listÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Here we present a complete list of options to be given under%SCFrelated toDeltaSCF:"
        }
      ],
      "parent_section": "deltascf",
      "description": "Here we present a complete list of options to be given under%SCFrelated toDeltaSCF:"
    },
    {
      "name": "CP-SCF OptionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: CP-SCF OptionsÂ"
        }
      ],
      "parent_section": "cpscf",
      "description": "ORCA: CP-SCF OptionsÂ"
    },
    {
      "name": "SCF Stability AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: SCF Stability AnalysisÂ"
        }
      ],
      "parent_section": "stabilityanalysis",
      "description": "ORCA: SCF Stability AnalysisÂ"
    },
    {
      "name": "Frozen Core OptionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Frozen Core OptionsÂ"
        }
      ],
      "parent_section": "frozencore",
      "description": "ORCA: Frozen Core OptionsÂ"
    },
    {
      "name": "The Second Order Many Body Pertubation Theory Module (MP2)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: The Second Order Many Body Pertubation Theory Module (MP2)Â"
        }
      ],
      "parent_section": "mp2",
      "description": "ORCA: The Second Order Many Body Pertubation Theory Module (MP2)Â"
    },
    {
      "name": "Standard MP2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Standard MP2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The standard (or full accuracy) MP2 module has two different branches.\nOne branch is used for energy calculations, the other for gradient\ncalculations."
        }
      ],
      "parent_section": "mp2",
      "description": "The standard (or full accuracy) MP2 module has two different branches.\nOne branch is used for energy calculations, the other for gradient\ncalculations."
    },
    {
      "name": "RI-MP2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "RI-MP2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The RI-MP2 module is of a straightforward nature. The program first\ntransforms the three-index integrals\\((ia|\n\\tilde{P})\\), where â\\(i\\)â is a occupied, â\\(a\\)â is a virtual MO and\nâ\\(\\tilde{P}\\)â is an auxiliary basis function that is orthogonalized\nagainst the Coulomb metric. These integrals are stored on disk, which is\nnot critical, even if the basis has several thousand functions."
        }
      ],
      "parent_section": "mp2",
      "description": "The RI-MP2 module is of a straightforward nature. The program first\ntransforms the three-index integrals\\((ia|\n\\tilde{P})\\), where â\\(i\\)â is a occupied, â\\(a\\)â is a virtual MO and\nâ\\(\\tilde{P}\\)â is an auxiliary basis function that is orthogonalized\nagainst the Coulomb metric. These integrals are stored on disk, which is\nnot critical, even if the basis has several thousand functions."
    },
    {
      "name": "âDouble-Hybridâ Density Functional TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "âDouble-Hybridâ Density Functional TheoryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A slightly more general form is met in the double-hybrid DFT gradient.\nThe theory is briefly described below."
        }
      ],
      "parent_section": "mp2",
      "description": "A slightly more general form is met in the double-hybrid DFT gradient.\nThe theory is briefly described below."
    },
    {
      "name": "Orbital Optimized MP2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Orbital Optimized MP2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The MP2 energy can be regarded as being stationary with respect to the\nMP2 amplitudes, since they can be considered as having been optimized\nthrough the minimization of the Hylleraas functional:"
        }
      ],
      "parent_section": "mp2",
      "description": "The MP2 energy can be regarded as being stationary with respect to the\nMP2 amplitudes, since they can be considered as having been optimized\nthrough the minimization of the Hylleraas functional:"
    },
    {
      "name": "Regularized MP2 and RI-MP2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Regularized MP2 and RI-MP2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Regularized MP2 is a variant of second-order Moller-Plesset theory (MP2) introduced\nby J. Shee, M. Loipersberger, A. Rettig, J. Lee, and M. Head-Gordon[791]that aims to improve its accuracy for systems with\\(\\pi\\)-driven dispersion\ninteractions and dative bonds in transition metal complexes. The approach\nachieves this by introducing a single-parameter, energy-gap dependent\nregularization that damp"
        }
      ],
      "parent_section": "mp2",
      "description": "Regularized MP2 is a variant of second-order Moller-Plesset theory (MP2) introduced\nby J. Shee, M. Loipersberger, A. Rettig, J. Lee, and M. Head-Gordon[791]that aims to improve its accuracy for systems with\\(\\pi\\)-driven dispersion\ninteractions and dative bonds in transition metal complexes. The approach\nachieves this by introducing a single-parameter, energy-gap dependent\nregularization that damp"
    },
    {
      "name": "RIJCOSX-RI-MP2 GradientsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "RIJCOSX-RI-MP2 GradientsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Additional grids are introduced for the RIJCOSX-MP2 gradient. They have\nsensible default settings and therefore do not usually require any\nintervention from the user. However, a number of expert options are\navailable, as described below."
        }
      ],
      "parent_section": "mp2",
      "description": "Additional grids are introduced for the RIJCOSX-MP2 gradient. They have\nsensible default settings and therefore do not usually require any\nintervention from the user. However, a number of expert options are\navailable, as described below."
    },
    {
      "name": "MP2 and RI-MP2 Second DerivativesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "MP2 and RI-MP2 Second DerivativesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Analytical second-order properties with the MP2, RI-MP2 and\ndouble-hybrid DFT methods are available in ORCA for calculations without\nfrozen core orbitals. The most expensive term in the second derivative calculations is the four-external contribution which can be evaluated either via an AO direct (default) or a semi-numerical Chain-of-Spheres approach. In case\nthat the latter approach is chosen, a"
        }
      ],
      "parent_section": "mp2",
      "description": "Analytical second-order properties with the MP2, RI-MP2 and\ndouble-hybrid DFT methods are available in ORCA for calculations without\nfrozen core orbitals. The most expensive term in the second derivative calculations is the four-external contribution which can be evaluated either via an AO direct (default) or a semi-numerical Chain-of-Spheres approach. In case\nthat the latter approach is chosen, a"
    },
    {
      "name": "RI-MP2 and Double-Hybrid DFT Response PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "RI-MP2 and Double-Hybrid DFT Response PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 5, both the electric (for the dipole polarizability)\nand the magnetic (for NMR shielding and the EPR g-tensor) field response\nas well as the nucleus-orbit response (hyperfine couplings\\(A_\\text{orb}\\)term) for RI-MP2 (and double-hybrid functionals) is\nhandled by a different implementation of the RI-MP2 second derivatives\nthan that used for geometric Hessian calculations\n(MP2 and"
        }
      ],
      "parent_section": "mp2",
      "description": "Starting from ORCA 5, both the electric (for the dipole polarizability)\nand the magnetic (for NMR shielding and the EPR g-tensor) field response\nas well as the nucleus-orbit response (hyperfine couplings\\(A_\\text{orb}\\)term) for RI-MP2 (and double-hybrid functionals) is\nhandled by a different implementation of the RI-MP2 second derivatives\nthan that used for geometric Hessian calculations\n(MP2 and"
    },
    {
      "name": "Local MP2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Local MP2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In analogy to the domain-based local pair natural orbital\ncoupled-cluster methods, there is also a local linear scaling version of\nMP2 (DLPNO-MP2) implemented in ORCA. Its default thresholds are chosen\nto reproduce about 99.9% of the total RI-MP2 correlation energy,\nresulting in an accuracy of a fraction of\\(1\\,\\text{kcal/mol}\\)for\nenergy differences. The theory has been described in the\nliteratur"
        }
      ],
      "parent_section": "mp2",
      "description": "In analogy to the domain-based local pair natural orbital\ncoupled-cluster methods, there is also a local linear scaling version of\nMP2 (DLPNO-MP2) implemented in ORCA. Its default thresholds are chosen\nto reproduce about 99.9% of the total RI-MP2 correlation energy,\nresulting in an accuracy of a fraction of\\(1\\,\\text{kcal/mol}\\)for\nenergy differences. The theory has been described in the\nliteratur"
    },
    {
      "name": "The Single Reference Correlation ModuleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: The Single Reference Correlation ModuleÂ"
        }
      ],
      "parent_section": "mdci",
      "description": "ORCA: The Single Reference Correlation ModuleÂ"
    },
    {
      "name": "TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "TheoryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We start from the full CI hierarchy in which the wavefunction is\nexpanded as:"
        }
      ],
      "parent_section": "mdci",
      "description": "We start from the full CI hierarchy in which the wavefunction is\nexpanded as:"
    },
    {
      "name": "Closed-Shell EquationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Closed-Shell EquationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Proceeding from spin-orbitals to the spatial orbitals of a closed-shell\ndeterminant leads to the actual working equations of this work. Saebo,\nMeyer and Pulay have exploited the generator state formalism to arrive\nat a set of highly efficient equations for the CISD problem[705]. A similar set of matrix formulated equations for the\nCCSD and QCISD cases has been discussed by Werner and co-workers[35"
        }
      ],
      "parent_section": "mdci",
      "description": "Proceeding from spin-orbitals to the spatial orbitals of a closed-shell\ndeterminant leads to the actual working equations of this work. Saebo,\nMeyer and Pulay have exploited the generator state formalism to arrive\nat a set of highly efficient equations for the CISD problem[705]. A similar set of matrix formulated equations for the\nCCSD and QCISD cases has been discussed by Werner and co-workers[35"
    },
    {
      "name": "Open-Shell EquationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Open-Shell EquationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We have used a non-redundant set of three spin cases (\\(\\alpha \\alpha\\),\\(\\beta \\beta\\),\\(\\alpha \\beta\\)) for which the doubles amplitudes are\noptimized separately. The equations in the spin-unrestricted formalism\nare straightforwardly obtained from the corresponding spin orbital\nequations by integrating out the spin. For implementing the unrestricted\nQCISD and CCSD method, we applied the same str"
        }
      ],
      "parent_section": "mdci",
      "description": "We have used a non-redundant set of three spin cases (\\(\\alpha \\alpha\\),\\(\\beta \\beta\\),\\(\\alpha \\beta\\)) for which the doubles amplitudes are\noptimized separately. The equations in the spin-unrestricted formalism\nare straightforwardly obtained from the corresponding spin orbital\nequations by integrating out the spin. For implementing the unrestricted\nQCISD and CCSD method, we applied the same str"
    },
    {
      "name": "Local correlationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Local correlationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "As described in previous sections of the manual, ORCA features the\nextremely powerful LPNO and DLPNO methods. âLPNOâ stands for âlocal pair\nnatural orbitalâ approximation and DLPNO for âdomain based LPNOâ. These\nmethods are designed to provide results as close as possible to the\ncanonical coupled-cluster results while gaining orders of magnitude of\nefficiency through a series of well-c"
        }
      ],
      "parent_section": "mdci",
      "description": "As described in previous sections of the manual, ORCA features the\nextremely powerful LPNO and DLPNO methods. âLPNOâ stands for âlocal pair\nnatural orbitalâ approximation and DLPNO for âdomain based LPNOâ. These\nmethods are designed to provide results as close as possible to the\ncanonical coupled-cluster results while gaining orders of magnitude of\nefficiency through a series of well-c"
    },
    {
      "name": "The singles Fock termÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The singles Fock termÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In most MDCI calculations, there is an intermediate, which resembles\nclosely to the SCF Fock matrix, and similar methods are available to\nefficiently calculate it. In the followings, a short discussion will be\ngiven of the so-called singles Fock term, which in the closed shell case\nhas the form"
        }
      ],
      "parent_section": "mdci",
      "description": "In most MDCI calculations, there is an intermediate, which resembles\nclosely to the SCF Fock matrix, and similar methods are available to\nefficiently calculate it. In the followings, a short discussion will be\ngiven of the so-called singles Fock term, which in the closed shell case\nhas the form"
    },
    {
      "name": "Use of the MDCI ModuleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Use of the MDCI ModuleÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The MDCI module is fairly easy to use. The flags for the âsimpleâ input\nlines have been described in sectionKeyword Lines. The detailed listing of options\nis found below:"
        }
      ],
      "parent_section": "mdci",
      "description": "The MDCI module is fairly easy to use. The flags for the âsimpleâ input\nlines have been described in sectionKeyword Lines. The detailed listing of options\nis found below:"
    },
    {
      "name": "The Complete Active Space Self-Consistent Field (CASSCF) ModuleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: The Complete Active Space Self-Consistent Field (CASSCF) ModuleÂ"
        }
      ],
      "parent_section": "casscf",
      "description": "ORCA: The Complete Active Space Self-Consistent Field (CASSCF) ModuleÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The complete active space self-consistent field (CASSCF) method is a\nspecial form of a multiconfigurational SCF method and can be thought of\nas an extension of the Hartree-Fock method. It is a very powerful method\nto study static correlation effects and a solid basis for MR-CI and\nMR-PT treatments. It can be applied to the ground state and excited\nstates or averages thereof. The implementation in "
        }
      ],
      "parent_section": "casscf",
      "description": "The complete active space self-consistent field (CASSCF) method is a\nspecial form of a multiconfigurational SCF method and can be thought of\nas an extension of the Hartree-Fock method. It is a very powerful method\nto study static correlation effects and a solid basis for MR-CI and\nMR-PT treatments. It can be applied to the ground state and excited\nstates or averages thereof. The implementation in "
    },
    {
      "name": "CASSCF DensitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "CASSCF DensitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The one-particle electron and spin density can be stored on disk using\nthe keyword!KeepDens. ORCA stores all densities in a container\n(.densitiesfile on disk), which can be used in conjunction withorca_plotto plot the charge and spin densities. Please check Sectionorca_plotfor more details on the\nprocedure. The state-specific densities will have a name postfix that\nreflects the root, multiplicity "
        }
      ],
      "parent_section": "casscf",
      "description": "The one-particle electron and spin density can be stored on disk using\nthe keyword!KeepDens. ORCA stores all densities in a container\n(.densitiesfile on disk), which can be used in conjunction withorca_plotto plot the charge and spin densities. Please check Sectionorca_plotfor more details on the\nprocedure. The state-specific densities will have a name postfix that\nreflects the root, multiplicity "
    },
    {
      "name": "CASSCF PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "CASSCF PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The CASSCF program is able to calculate UV transition, CD spectra, SOC,\nSSC, Zeeman splittings, EPR g-matrices and A-matrices (the latter\nimplemented in the same way as in the DCD-CAS(2) method[491]),\nmagnetization, magnetic susceptibility and MCD spectra. Note that the\nresults for the Fermi contact contribution to A will not be reliable if\nthe spin density is dominated by spin polarization, which"
        }
      ],
      "parent_section": "casscf",
      "description": "The CASSCF program is able to calculate UV transition, CD spectra, SOC,\nSSC, Zeeman splittings, EPR g-matrices and A-matrices (the latter\nimplemented in the same way as in the DCD-CAS(2) method[491]),\nmagnetization, magnetic susceptibility and MCD spectra. Note that the\nresults for the Fermi contact contribution to A will not be reliable if\nthe spin density is dominated by spin polarization, which"
    },
    {
      "name": "1- and 2-shell Abinitio Ligand Field TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "1- and 2-shell Abinitio Ligand Field TheoryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 5.0, ORCA features a 1- and 2-shell AILFT module.\nAILFT was originally developed for 1-shell d- and f- LFT problems[57,490]. In ORCA 5.0 an extenion to\n2-shell AILFT provides access to all common 1- and 2-shell AILFT\nproblems namely:"
        }
      ],
      "parent_section": "casscf",
      "description": "Starting from ORCA 5.0, ORCA features a 1- and 2-shell AILFT module.\nAILFT was originally developed for 1-shell d- and f- LFT problems[57,490]. In ORCA 5.0 an extenion to\n2-shell AILFT provides access to all common 1- and 2-shell AILFT\nproblems namely:"
    },
    {
      "name": "Core excited states with (C/R)ASCI/NEVPT2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core excited states with (C/R)ASCI/NEVPT2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 4.1, a CASCI/NEVPT2 protocol can be used to compute\ncore excited spectra, namely X-ray absorption (XAS) and resonant\ninelastic scattering (RIXS) spectra. RASCI calculations can also be\neasily specified."
        }
      ],
      "parent_section": "casscf",
      "description": "Starting from ORCA 4.1, a CASCI/NEVPT2 protocol can be used to compute\ncore excited spectra, namely X-ray absorption (XAS) and resonant\ninelastic scattering (RIXS) spectra. RASCI calculations can also be\neasily specified."
    },
    {
      "name": "CASCI-XESÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "CASCI-XESÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 5.0 likewise to RASCI-XES (see sectionX-ray Spectroscopy) orca features a\nCASCI-XES protocol."
        }
      ],
      "parent_section": "casscf",
      "description": "Starting from ORCA 5.0 likewise to RASCI-XES (see sectionX-ray Spectroscopy) orca features a\nCASCI-XES protocol."
    },
    {
      "name": "CASSCF Linear ResponseÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: CASSCF Linear ResponseÂ"
        }
      ],
      "parent_section": "casscfresp",
      "description": "ORCA: CASSCF Linear ResponseÂ"
    },
    {
      "name": "Input BlockÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Input BlockÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The input block%casrespis available for requesting the following options (given below with their default values):"
        }
      ],
      "parent_section": "casscfresp",
      "description": "The input block%casrespis available for requesting the following options (given below with their default values):"
    },
    {
      "name": "Technical NotesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Technical NotesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "It should be noted that CASSCF linear response uses the optimized CASSCF wavefunction as a starting point.\nThus, a%casscfblock with the appropriate inputs (seeComplete Active Space Self-Consistent Field Method) must be provided in the input.\nState-specific (SS-)CASSCF response is run on SS (NRoots1) CASSCF wavefunctions.\nIf the CASSCF wavefunction is state-averaged (SA), the response is run over t"
        }
      ],
      "parent_section": "casscfresp",
      "description": "It should be noted that CASSCF linear response uses the optimized CASSCF wavefunction as a starting point.\nThus, a%casscfblock with the appropriate inputs (seeComplete Active Space Self-Consistent Field Method) must be provided in the input.\nState-specific (SS-)CASSCF response is run on SS (NRoots1) CASSCF wavefunctions.\nIf the CASSCF wavefunction is state-averaged (SA), the response is run over t"
    },
    {
      "name": "Notes on PrintingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Notes on PrintingÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The information on the types of property integrals computed can be found in theORCAPROPERTYINTEGRALCALCULATIONSsection of the output file.\nTheorca_casscfrespoutput begins with the headerORCACASSCFRESPONSECALCULATION.\nAfter information about the types and number of perturbations, the calculation splits into the major types of perturbations: real and imaginary.\nAll response equations of the same typ"
        }
      ],
      "parent_section": "casscfresp",
      "description": "The information on the types of property integrals computed can be found in theORCAPROPERTYINTEGRALCALCULATIONSsection of the output file.\nTheorca_casscfrespoutput begins with the headerORCACASSCFRESPONSECALCULATION.\nAfter information about the types and number of perturbations, the calculation splits into the major types of perturbations: real and imaginary.\nAll response equations of the same typ"
    },
    {
      "name": "TroubleshootingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "TroubleshootingÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "If the%casrespblock is specified and the calculation does not run through the CASSCF Response section, then the properties requested are not second-derivatives and therefore do not require linear response equations to be solved.\nIf, however, the job aborts, watch for these possibilities:"
        }
      ],
      "parent_section": "casscfresp",
      "description": "If the%casrespblock is specified and the calculation does not run through the CASSCF Response section, then the properties requested are not second-derivatives and therefore do not require linear response equations to be solved.\nIf, however, the job aborts, watch for these possibilities:"
    },
    {
      "name": "Minimal Input FileÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Minimal Input FileÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The following is an overview of the blocks required for a property calculation with"
        }
      ],
      "parent_section": "casscfresp",
      "description": "The following is an overview of the blocks required for a property calculation with"
    },
    {
      "name": "Interface to SINGLE_ANISO moduleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Interface to SINGLE_ANISO moduleÂ"
        }
      ],
      "parent_section": "single aniso",
      "description": "ORCA: Interface to SINGLE_ANISO moduleÂ"
    },
    {
      "name": "General descriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General descriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "TheSINGLE_ANISOprogram allows the non-perturbative calculation of\neffective spin (pseudospin) Hamiltonians and static magnetic properties\nof mononuclear complexes and fragments on the basis of anab initio,\nincluding the spin-orbit interaction. As a starting point it uses the\nresults of aCASSCF/NEVPT2/SOCcalculation for the ground and several\nexcited spin-orbit multiplets."
        }
      ],
      "parent_section": "single aniso",
      "description": "TheSINGLE_ANISOprogram allows the non-perturbative calculation of\neffective spin (pseudospin) Hamiltonians and static magnetic properties\nof mononuclear complexes and fragments on the basis of anab initio,\nincluding the spin-orbit interaction. As a starting point it uses the\nresults of aCASSCF/NEVPT2/SOCcalculation for the ground and several\nexcited spin-orbit multiplets."
    },
    {
      "name": "RunningSINGLE_ANISOcalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "RunningSINGLE_ANISOcalculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "TheSINGLE_ANISOis, in principle, a stand-alone utility\n(otool_single_aniso) that can be called directly from the shell with\nits own input file, provided that theab initiodatafile is available:"
        }
      ],
      "parent_section": "single aniso",
      "description": "TheSINGLE_ANISOis, in principle, a stand-alone utility\n(otool_single_aniso) that can be called directly from the shell with\nits own input file, provided that theab initiodatafile is available:"
    },
    {
      "name": "Reference list of CASSCF/ANISO keywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Reference list of CASSCF/ANISO keywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The only required keyword forSINGLE_ANISOis theDATA, specifying\nthe name of the datafile containing theab initioinformation. The\nORCA interface includes this keyword automatically and therefore it is\nnot referenced here. All other keywords are extra and allow various\ncustomisation of the execution. For the computation of the EPR\\(g\\)-tensor, the only unknown variable forSINGLE_ANISOis the\ndimensio"
        }
      ],
      "parent_section": "single aniso",
      "description": "The only required keyword forSINGLE_ANISOis theDATA, specifying\nthe name of the datafile containing theab initioinformation. The\nORCA interface includes this keyword automatically and therefore it is\nnot referenced here. All other keywords are extra and allow various\ncustomisation of the execution. For the computation of the EPR\\(g\\)-tensor, the only unknown variable forSINGLE_ANISOis the\ndimensio"
    },
    {
      "name": "How to citeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "How to citeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We would appreciate if you cite the following papers in publications\nresulting from the use ofSINGLE_ANISO:"
        }
      ],
      "parent_section": "single aniso",
      "description": "We would appreciate if you cite the following papers in publications\nresulting from the use ofSINGLE_ANISO:"
    },
    {
      "name": "Interface to POLY_ANISO moduleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Interface to POLY_ANISO moduleÂ"
        }
      ],
      "parent_section": "poly aniso",
      "description": "ORCA: Interface to POLY_ANISO moduleÂ"
    },
    {
      "name": "General descriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General descriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ThePOLY_ANISOis a stand-alone utility allowing for a semi-ab\ninitiodescription of the (low-lying) electronic structure and magnetic\nproperties of polynuclear compounds. The model behind it is based on thelocalisednature of the magnetic orbitals (i.e. the\\(d\\)and\\(f\\)orbitals containing unpaired electrons). For many compounds of interest,\nthe localised character of the magnetic orbitals leads to ve"
        }
      ],
      "parent_section": "poly aniso",
      "description": "ThePOLY_ANISOis a stand-alone utility allowing for a semi-ab\ninitiodescription of the (low-lying) electronic structure and magnetic\nproperties of polynuclear compounds. The model behind it is based on thelocalisednature of the magnetic orbitals (i.e. the\\(d\\)and\\(f\\)orbitals containing unpaired electrons). For many compounds of interest,\nthe localised character of the magnetic orbitals leads to ve"
    },
    {
      "name": "FilesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "FilesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "POLY_ANISOis called independently of ORCA for now. In the future\nversions of ORCA  we will aim for a deeper integration, for a better\nexperience."
        }
      ],
      "parent_section": "poly aniso",
      "description": "POLY_ANISOis called independently of ORCA for now. In the future\nversions of ORCA  we will aim for a deeper integration, for a better\nexperience."
    },
    {
      "name": "List of keywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "List of keywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This section describes the keywords used to control thePOLY_ANISOinput file. Only two keywordsNNEQ,PAIR(andSYMMif the\npolynuclear cluster has symmetry) are mandatory for a minimal execution\nof the program, while the other keywords allow customisation of the\nexecution of thePOLY_ANISO."
        }
      ],
      "parent_section": "poly aniso",
      "description": "This section describes the keywords used to control thePOLY_ANISOinput file. Only two keywordsNNEQ,PAIR(andSYMMif the\npolynuclear cluster has symmetry) are mandatory for a minimal execution\nof the program, while the other keywords allow customisation of the\nexecution of thePOLY_ANISO."
    },
    {
      "name": "N-Electron Valence State Pertubation TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: N-Electron Valence State Pertubation TheoryÂ"
        }
      ],
      "parent_section": "nevpt2",
      "description": "ORCA: N-Electron Valence State Pertubation TheoryÂ"
    },
    {
      "name": "RI, RIJK and RIJCOSX ApproximationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "RI, RIJK and RIJCOSX ApproximationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Setting the RI approximation on the CASSCF level, will set the RI\noptions for NEVPT2 respectively. The three index integrals are computed\nand partially stored on disk. Three index integral with two internal\nlabels are kept in main memory. The two-electron integrals are assembled\non the fly. The auxiliary basis must be large enough to fit the\nintegrals appearing in the CASSCF orbital gradient/Hessi"
        }
      ],
      "parent_section": "nevpt2",
      "description": "Setting the RI approximation on the CASSCF level, will set the RI\noptions for NEVPT2 respectively. The three index integrals are computed\nand partially stored on disk. Three index integral with two internal\nlabels are kept in main memory. The two-electron integrals are assembled\non the fly. The auxiliary basis must be large enough to fit the\nintegrals appearing in the CASSCF orbital gradient/Hessi"
    },
    {
      "name": "Beyond the RI approximation: DLPNO-NEVPT2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Beyond the RI approximation: DLPNO-NEVPT2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For systems with more than 80 atoms, we recommend the recently developed\nDLPNO-NEVPT2.[344]It is a successful\ncombination of DLPNO strategy with the FIC-NEVPT2 method. As its single\nreference counterparts, DLPNO-NEVPT2 recovers 99.9% of the FIC-NEVPT2\ncorrelation energies even for large system. The input structure is\nsimilar to the parenting FIC-NEVPT2 method. Below you find an input\nexample for t"
        }
      ],
      "parent_section": "nevpt2",
      "description": "For systems with more than 80 atoms, we recommend the recently developed\nDLPNO-NEVPT2.[344]It is a successful\ncombination of DLPNO strategy with the FIC-NEVPT2 method. As its single\nreference counterparts, DLPNO-NEVPT2 recovers 99.9% of the FIC-NEVPT2\ncorrelation energies even for large system. The input structure is\nsimilar to the parenting FIC-NEVPT2 method. Below you find an input\nexample for t"
    },
    {
      "name": "Explicitly correlated NEVPT2: NEVPT2-F12 and DLPNO-NEVPT2-F12Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Explicitly correlated NEVPT2: NEVPT2-F12 and DLPNO-NEVPT2-F12Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Like in the single-reference MP2 theory, the NEVPT2 correlation energy\nconverges slowly with the basis set. Aside from basis set extrapolation,\nthe R12/F12 method are popular methods to reach the basis set limit. For\ncomparison of F12 and extrapolation techniques, we refer to the study of\nLiakos et al.[521]ORCA features an F12 correction\nfor the FIC-NEVPT2 wavefunction using the RI\napproximation.["
        }
      ],
      "parent_section": "nevpt2",
      "description": "Like in the single-reference MP2 theory, the NEVPT2 correlation energy\nconverges slowly with the basis set. Aside from basis set extrapolation,\nthe R12/F12 method are popular methods to reach the basis set limit. For\ncomparison of F12 and extrapolation techniques, we refer to the study of\nLiakos et al.[521]ORCA features an F12 correction\nfor the FIC-NEVPT2 wavefunction using the RI\napproximation.["
    },
    {
      "name": "Tackling large active CASSCF spacesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Tackling large active CASSCF spacesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Large active spaces (CAS(10,10) and more) require special attention as\nthe standard implementation involves the fourth order reduced density\nmatrix (4-RDM).[46]The storage of the latter can easily\nreach several gigabytes and thus cannot be kept in core memory. ORCA\nthus by default constructs and contracts the 4-RDM on the fly\n(D4Stepfly). Note that the program can be forced to keep the 4-RDM on\ndi"
        }
      ],
      "parent_section": "nevpt2",
      "description": "Large active spaces (CAS(10,10) and more) require special attention as\nthe standard implementation involves the fourth order reduced density\nmatrix (4-RDM).[46]The storage of the latter can easily\nreach several gigabytes and thus cannot be kept in core memory. ORCA\nthus by default constructs and contracts the 4-RDM on the fly\n(D4Stepfly). Note that the program can be forced to keep the 4-RDM on\ndi"
    },
    {
      "name": "Selecting or Specific States for NEVPT2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Selecting or Specific States for NEVPT2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA by default computes all states defined in the CASSCF block input\nwith the NEVPT2 approach. There are cases, where this is not desired and\nthe user wants to skip some of these states. The input mask ofSelectedRootsis equivalent to theweightskeyword in the %casscf\nblock: The enumerationSelectedRoots[0]refers to the numbering of the\nmultiplicity blocks and the respective roots defined in CASSCF."
        }
      ],
      "parent_section": "nevpt2",
      "description": "ORCA by default computes all states defined in the CASSCF block input\nwith the NEVPT2 approach. There are cases, where this is not desired and\nthe user wants to skip some of these states. The input mask ofSelectedRootsis equivalent to theweightskeyword in the %casscf\nblock: The enumerationSelectedRoots[0]refers to the numbering of the\nmultiplicity blocks and the respective roots defined in CASSCF."
    },
    {
      "name": "Unrelaxed Densities and Natural OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Unrelaxed Densities and Natural OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "With the FIC-NEVPT2 ansatz, it is possible to request state-specific\nunrelaxed densities"
        }
      ],
      "parent_section": "nevpt2",
      "description": "With the FIC-NEVPT2 ansatz, it is possible to request state-specific\nunrelaxed densities"
    },
    {
      "name": "State-averaged NEVPT2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "State-averaged NEVPT2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the definition of the Dyall Hamiltonian[238]the\nCASSCF orbitals are chosen to diagonalize the Fock operator\n(pseudo-canonicalized). Therefore, using a state-averaged CASSCF wave\nfunction, the NEVPT2 procedure involves the construction and\ndiagonalization of the âstate-specificâ Fock operators and is thus\nresulting in a unique set of orbitals for each state. This becomes\nquickly inefficient "
        }
      ],
      "parent_section": "nevpt2",
      "description": "In the definition of the Dyall Hamiltonian[238]the\nCASSCF orbitals are chosen to diagonalize the Fock operator\n(pseudo-canonicalized). Therefore, using a state-averaged CASSCF wave\nfunction, the NEVPT2 procedure involves the construction and\ndiagonalization of the âstate-specificâ Fock operators and is thus\nresulting in a unique set of orbitals for each state. This becomes\nquickly inefficient "
    },
    {
      "name": "Quasi-Degenerate SC-NEVPT2Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Quasi-Degenerate SC-NEVPT2Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "NEVPT2 as it is presented in the previous subsections follows the recipe\nof âdiagonalize and perturbâ. The 0th order wavefunction is determined\nby the diagonalization of the CAS-CI matrix. The space spanned by the\nCAS-CI vectors is often referred to as âmodel spaceâ. The subsequent\nperturbation theory is constructed based on the assumption that the\nstates under consideration are well descr"
        }
      ],
      "parent_section": "nevpt2",
      "description": "NEVPT2 as it is presented in the previous subsections follows the recipe\nof âdiagonalize and perturbâ. The 0th order wavefunction is determined\nby the diagonalization of the CAS-CI matrix. The space spanned by the\nCAS-CI vectors is often referred to as âmodel spaceâ. The subsequent\nperturbation theory is constructed based on the assumption that the\nstates under consideration are well descr"
    },
    {
      "name": "Complete Active Space Peturbation Theory : CASPT2 and CASPT2-KÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Complete Active Space Peturbation Theory : CASPT2 and CASPT2-KÂ"
        }
      ],
      "parent_section": "caspt2",
      "description": "ORCA: Complete Active Space Peturbation Theory : CASPT2 and CASPT2-KÂ"
    },
    {
      "name": "Dynamic Correlation Dressed CASÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Dynamic Correlation Dressed CASÂ"
        }
      ],
      "parent_section": "dcdcas2",
      "description": "ORCA: Dynamic Correlation Dressed CASÂ"
    },
    {
      "name": "Theory of Nonrelativistic DCD-CAS(2)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Theory of Nonrelativistic DCD-CAS(2)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The DCD-CAS(2) method is based on solving the eigenvalue problem of an\neffective Hamiltonian of the form"
        }
      ],
      "parent_section": "dcdcas2",
      "description": "The DCD-CAS(2) method is based on solving the eigenvalue problem of an\neffective Hamiltonian of the form"
    },
    {
      "name": "Treatment of spin-dependent effectsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Treatment of spin-dependent effectsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The theory so far is valid for a nonrelativistic or scalar-relativistic\nHamiltonian\\(H\\). If we modify it to a Hamiltonian\\(H+V\\), where\\(V\\)contains effects that are possibly spin-dependent, this leads us to a\ntheory[491]which has a similar form as QDPT with all CAS roots\nincluded. The form of the spin-dependent DCD-CAS(2) effective\nHamiltonian is"
        }
      ],
      "parent_section": "dcdcas2",
      "description": "The theory so far is valid for a nonrelativistic or scalar-relativistic\nHamiltonian\\(H\\). If we modify it to a Hamiltonian\\(H+V\\), where\\(V\\)contains effects that are possibly spin-dependent, this leads us to a\ntheory[491]which has a similar form as QDPT with all CAS roots\nincluded. The form of the spin-dependent DCD-CAS(2) effective\nHamiltonian is"
    },
    {
      "name": "List of keywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "List of keywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The following keywords can be used in conjunction with the DCD-CAS(2)\nmethod:"
        }
      ],
      "parent_section": "dcdcas2",
      "description": "The following keywords can be used in conjunction with the DCD-CAS(2)\nmethod:"
    },
    {
      "name": "Density Matrix Renormalization GroupÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Density Matrix Renormalization GroupÂ"
        }
      ],
      "parent_section": "dmrg",
      "description": "ORCA: Density Matrix Renormalization GroupÂ"
    },
    {
      "name": "Technical capabilitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Technical capabilitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Currently,BLOCKimplements the following"
        }
      ],
      "parent_section": "dmrg",
      "description": "Currently,BLOCKimplements the following"
    },
    {
      "name": "How to citeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "How to citeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We would appreciate if you cite the following papers in publications\nresulting from the use ofBLOCK:"
        }
      ],
      "parent_section": "dmrg",
      "description": "We would appreciate if you cite the following papers in publications\nresulting from the use ofBLOCK:"
    },
    {
      "name": "Overview of BLOCK input and calculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Overview of BLOCK input and calculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Within ORCA, theBLOCKprogram is accessed as part of the CASSCF\nmodule.BLOCKcan be run in two modes: CASCI mode (no orbital\noptimization) or CASSCF mode. To enable CASCI mode, setmaxiter1."
        }
      ],
      "parent_section": "dmrg",
      "description": "Within ORCA, theBLOCKprogram is accessed as part of the CASSCF\nmodule.BLOCKcan be run in two modes: CASCI mode (no orbital\noptimization) or CASSCF mode. To enable CASCI mode, setmaxiter1."
    },
    {
      "name": "Standard commandsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Standard commandsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Once the orbitals to correlate have been chosen, and the wavefunction\nsymmetries and quantum numbers are specified, the accuracy of the DMRG\ncalculation is governed by two parameters: the maximum number of\nrenormalized states\\(M\\); and, the order and localization of the\norbitals."
        }
      ],
      "parent_section": "dmrg",
      "description": "Once the orbitals to correlate have been chosen, and the wavefunction\nsymmetries and quantum numbers are specified, the accuracy of the DMRG\ncalculation is governed by two parameters: the maximum number of\nrenormalized states\\(M\\); and, the order and localization of the\norbitals."
    },
    {
      "name": "Appendix: Porphine\\(\\pi\\)-active space calculationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Appendix: Porphine\\(\\pi\\)-active space calculationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We provide a step-by-step basis on localizing the\\(\\pi\\)-orbitals of the\nporphine molecules and running a CASSCF-DMRG calculation on this system.\nIt will be important to obtain an initial set of orbitals, rotate the\norbitals which are going to be localized, localize them, and finally run\nthe CASSCF calculation. We will abbreviate the coordinates as\\(\\left[\\dots\\right]\\)after showing the coordinate"
        }
      ],
      "parent_section": "dmrg",
      "description": "We provide a step-by-step basis on localizing the\\(\\pi\\)-orbitals of the\nporphine molecules and running a CASSCF-DMRG calculation on this system.\nIt will be important to obtain an initial set of orbitals, rotate the\norbitals which are going to be localized, localize them, and finally run\nthe CASSCF calculation. We will abbreviate the coordinates as\\(\\left[\\dots\\right]\\)after showing the coordinate"
    },
    {
      "name": "Relativistic OptionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Relativistic OptionsÂ"
        }
      ],
      "parent_section": "relativistic",
      "description": "ORCA: Relativistic OptionsÂ"
    },
    {
      "name": "Approximate Relativistic HamiltoniansÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Approximate Relativistic HamiltoniansÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the relativistic domain, calculations are based on the one-electron,\nstationary Dirac equation in atomic units (rest mass subtracted)"
        }
      ],
      "parent_section": "relativistic",
      "description": "In the relativistic domain, calculations are based on the one-electron,\nstationary Dirac equation in atomic units (rest mass subtracted)"
    },
    {
      "name": "The Regular ApproximationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Regular ApproximationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the regular approximation,(7.166)is approximated by"
        }
      ],
      "parent_section": "relativistic",
      "description": "In the regular approximation,(7.166)is approximated by"
    },
    {
      "name": "The Douglas-Kroll-Hess MethodÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Douglas-Kroll-Hess MethodÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The Douglas-Kroll-Hess (DKH) method expands the exact relation(7.166)in the external potential V. In\nORCA the first- and second-order DKH methods are implemented. The\nfirst-order DKH Hamiltonian is given by"
        }
      ],
      "parent_section": "relativistic",
      "description": "The Douglas-Kroll-Hess (DKH) method expands the exact relation(7.166)in the external potential V. In\nORCA the first- and second-order DKH methods are implemented. The\nfirst-order DKH Hamiltonian is given by"
    },
    {
      "name": "Picture-Change EffectsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Picture-Change EffectsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Irrespective of which Hamiltonian has been used in the determination of\nthe wave function, the calculation of properties requires some special\ncare. This can be understood in two ways: First of all, we changed from\nthe ordinary SchrÃ¶dinger Hamiltonian to a more complicated Hamiltonian.\nAs properties are defined as derivatives of the energy, it is clear that\na new Hamiltonian will yield a new expr"
        }
      ],
      "parent_section": "relativistic",
      "description": "Irrespective of which Hamiltonian has been used in the determination of\nthe wave function, the calculation of properties requires some special\ncare. This can be understood in two ways: First of all, we changed from\nthe ordinary SchrÃ¶dinger Hamiltonian to a more complicated Hamiltonian.\nAs properties are defined as derivatives of the energy, it is clear that\na new Hamiltonian will yield a new expr"
    },
    {
      "name": "Finite Nucleus ModelÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Finite Nucleus ModelÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Composite particles like nuclei have, as opposed to elementary\nparticles, a certain spatial extent. While the point-charge\napproximation for nuclei is in general very good in nonrelativistic\ncalculations, in relativistic calculations it might lead to\nnon-negligible errors. A finite-nucleus model is available for all\ncalculations in the ORCA program package. It is accessible from the%relblock via"
        }
      ],
      "parent_section": "relativistic",
      "description": "Composite particles like nuclei have, as opposed to elementary\nparticles, a certain spatial extent. While the point-charge\napproximation for nuclei is in general very good in nonrelativistic\ncalculations, in relativistic calculations it might lead to\nnon-negligible errors. A finite-nucleus model is available for all\ncalculations in the ORCA program package. It is accessible from the%relblock via"
    },
    {
      "name": "Exact Two-Component Theory (X2C)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Exact Two-Component Theory (X2C)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The X2C implementation in ORCA closely follows that of Franzke, Weigend,\nand their coworkers, described in the references:[659](energy),[274](gradient),[276](EPR hyperfine coupling),[273](NMR spinâspin coupling),[272](NMR\nshielding). These are also consistent with the work of Gauss and\ncoworkers in refs:[165](gradient, electric properties),[166](Hessian),[167](NMR shielding). However, despite\nth"
        }
      ],
      "parent_section": "relativistic",
      "description": "The X2C implementation in ORCA closely follows that of Franzke, Weigend,\nand their coworkers, described in the references:[659](energy),[274](gradient),[276](EPR hyperfine coupling),[273](NMR spinâspin coupling),[272](NMR\nshielding). These are also consistent with the work of Gauss and\ncoworkers in refs:[165](gradient, electric properties),[166](Hessian),[167](NMR shielding). However, despite\nth"
    },
    {
      "name": "Basis Sets in Relativistic CalculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Basis Sets in Relativistic CalculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For relativistic calculations, special basis sets have been designed,\nboth as DKH and ZORA recontractions of the non-relativistic Ahlrichs\nbasis sets (in their all-electron versions) for elements up to Kr, and\nas purpose-built segmented all-electron relativistically contracted\n(SARC) basis sets for elements beyond Kr[62,641,642,643,644,729].\nTheir names are âZORA-â or âDKH-â followed by th"
        }
      ],
      "parent_section": "relativistic",
      "description": "For relativistic calculations, special basis sets have been designed,\nboth as DKH and ZORA recontractions of the non-relativistic Ahlrichs\nbasis sets (in their all-electron versions) for elements up to Kr, and\nas purpose-built segmented all-electron relativistically contracted\n(SARC) basis sets for elements beyond Kr[62,641,642,643,644,729].\nTheir names are âZORA-â or âDKH-â followed by th"
    },
    {
      "name": "Approximate Full CI Calculations in Subspace: ICE-CIÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Approximate Full CI Calculations in Subspace: ICE-CIÂ"
        }
      ],
      "parent_section": "iceci",
      "description": "ORCA: Approximate Full CI Calculations in Subspace: ICE-CIÂ"
    },
    {
      "name": "IntroductionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "IntroductionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In many circumstances, one would like to generate a wavefunction that is\nas close as possible to the full-CI result, but Full CI itself is out of\nthe question for computational reasons. Situations in which that may be\ndesirable include a) one wants to generate highly accurate energies for\nsmall molecules or b) one wants to sort out a number of low-lying states\nor c) one wants to run CASSCF calcula"
        }
      ],
      "parent_section": "iceci",
      "description": "In many circumstances, one would like to generate a wavefunction that is\nas close as possible to the full-CI result, but Full CI itself is out of\nthe question for computational reasons. Situations in which that may be\ndesirable include a) one wants to generate highly accurate energies for\nsmall molecules or b) one wants to sort out a number of low-lying states\nor c) one wants to run CASSCF calcula"
    },
    {
      "name": "The ICE-CI and CIPSI AlgorithmsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The ICE-CI and CIPSI AlgorithmsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The general idea of ICE-CI is straightforward: Consider a many-particle\nstate that has at least a sizeable contribution from a given\nconfiguration\\(\\mathrm{\\mathbf{n} }^{0}\\)(this is a set of occupation\nnumbers for the active orbitals that are\\(n_{p}^{0} =0,1\\,\\,or\\,\\,2\\)(\\(p \\quad =\\)any active orbital). By nature of the non-relativisitic\nHamiltonian only configurations that differ by at most two"
        }
      ],
      "parent_section": "iceci",
      "description": "The general idea of ICE-CI is straightforward: Consider a many-particle\nstate that has at least a sizeable contribution from a given\nconfiguration\\(\\mathrm{\\mathbf{n} }^{0}\\)(this is a set of occupation\nnumbers for the active orbitals that are\\(n_{p}^{0} =0,1\\,\\,or\\,\\,2\\)(\\(p \\quad =\\)any active orbital). By nature of the non-relativisitic\nHamiltonian only configurations that differ by at most two"
    },
    {
      "name": "A Simple Example CalculationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "A Simple Example CalculationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Let us look at a simple calculation on the water molecule:"
        }
      ],
      "parent_section": "iceci",
      "description": "Let us look at a simple calculation on the water molecule:"
    },
    {
      "name": "AccuracyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "AccuracyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The accuracy of the procedure is controlled by two parameters\nT\\(_{\\mathrm{gen} }\\)and T\\(_{\\mathrm{var} }\\)Since we have found that\nT\\(_{\\mathrm{var} } \\quad =\\)10\\(^{\\mathrm{-7} }\\)T\\(_{\\mathrm{gen} }\\)always provides converged results, this choice is the default. However,\nT\\(_{\\mathrm{var} }\\)can be set manually. It can be reduced considerably\nin order to speed up the calculations at the expens"
        }
      ],
      "parent_section": "iceci",
      "description": "The accuracy of the procedure is controlled by two parameters\nT\\(_{\\mathrm{gen} }\\)and T\\(_{\\mathrm{var} }\\)Since we have found that\nT\\(_{\\mathrm{var} } \\quad =\\)10\\(^{\\mathrm{-7} }\\)T\\(_{\\mathrm{gen} }\\)always provides converged results, this choice is the default. However,\nT\\(_{\\mathrm{var} }\\)can be set manually. It can be reduced considerably\nin order to speed up the calculations at the expens"
    },
    {
      "name": "Scaling behaviorÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Scaling behaviorÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ICE-CI will break the factorial scaling of the full CI problem and scale\npolynomially. The actual order of the polynomial scaling is system\ndependent and accuracy dependent. In order to provide some impression,\nconsider some calculations on linear polyene chains."
        }
      ],
      "parent_section": "iceci",
      "description": "ICE-CI will break the factorial scaling of the full CI problem and scale\npolynomially. The actual order of the polynomial scaling is system\ndependent and accuracy dependent. In order to provide some impression,\nconsider some calculations on linear polyene chains."
    },
    {
      "name": "Accuracy of the WavefunctionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Accuracy of the WavefunctionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The accuracy of the many particle wavefunction is not straightforward to\ncheck. A reasonable measure, however, is how well it converges towards\nthe exact result for one-electron expectation values. Since every\nexpectation value can be written in terms of natural orbitals of the\none-particle density as:"
        }
      ],
      "parent_section": "iceci",
      "description": "The accuracy of the many particle wavefunction is not straightforward to\ncheck. A reasonable measure, however, is how well it converges towards\nthe exact result for one-electron expectation values. Since every\nexpectation value can be written in terms of natural orbitals of the\none-particle density as:"
    },
    {
      "name": "Potential Energy SurfacesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Potential Energy SurfacesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "You can use ICE-CI to scan entire potential energy surfaces. In general,\nthe non-parallelity error along a potential energy surface is very\nsmall. Thus, ICE-CI yields consistent quality throughout the surface."
        }
      ],
      "parent_section": "iceci",
      "description": "You can use ICE-CI to scan entire potential energy surfaces. In general,\nthe non-parallelity error along a potential energy surface is very\nsmall. Thus, ICE-CI yields consistent quality throughout the surface."
    },
    {
      "name": "Excited StatesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Excited StatesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ICE-CI can be used to obtain some insight into excited states starting\nfrom no knowledge at all. Of course, the best was to start an excited\nstate calculation is to have some idea which configurations are\nimportant for the low-lying states of the system. If this is not the\ncase, an automated procedure is used. The program will first generate an\nâAufbauâ configuration using the orbitals that ar"
        }
      ],
      "parent_section": "iceci",
      "description": "ICE-CI can be used to obtain some insight into excited states starting\nfrom no knowledge at all. Of course, the best was to start an excited\nstate calculation is to have some idea which configurations are\nimportant for the low-lying states of the system. If this is not the\ncase, an automated procedure is used. The program will first generate an\nâAufbauâ configuration using the orbitals that ar"
    },
    {
      "name": "Tips and TricksÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Tips and TricksÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ICE-CI can be used very fruitfully together with, say, MP2 natural\norbitals. This usually results in results that are closer to full CI\nresults and at the same lead to more compact wavefunctions (it may be\ncalled nICE). The use of MP2 natural orbitals is requested by choosingUseMP2nattrueinside the %ice block. Alternatively, improved virtual\norbitals can be used (requested byUseIVOstrue). A compar"
        }
      ],
      "parent_section": "iceci",
      "description": "ICE-CI can be used very fruitfully together with, say, MP2 natural\norbitals. This usually results in results that are closer to full CI\nresults and at the same lead to more compact wavefunctions (it may be\ncalled nICE). The use of MP2 natural orbitals is requested by choosingUseMP2nattrueinside the %ice block. Alternatively, improved virtual\norbitals can be used (requested byUseIVOstrue). A compar"
    },
    {
      "name": "Large-scale approximate CASSCF: ICE-SCFÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Large-scale approximate CASSCF: ICE-SCFÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ICE-CI can be used as a replacement for the CI step in a CASSCF\nframework. In this way, much larger CASSCF calculations than previously\npossible can be envisioned. In using the ICE-CI in this way, the active\norbitals should be chosen as natural orbitals in order to ensure a\nproper canonicalization. In general, ICE-CI results will not be\ninvariant with respect to the choice of orbitals. However, in"
        }
      ],
      "parent_section": "iceci",
      "description": "ICE-CI can be used as a replacement for the CI step in a CASSCF\nframework. In this way, much larger CASSCF calculations than previously\npossible can be envisioned. In using the ICE-CI in this way, the active\norbitals should be chosen as natural orbitals in order to ensure a\nproper canonicalization. In general, ICE-CI results will not be\ninvariant with respect to the choice of orbitals. However, in"
    },
    {
      "name": "The entire input block explainedÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The entire input block explainedÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For completeness, the parameters that can be specified in the input\nblock are summarized below:"
        }
      ],
      "parent_section": "iceci",
      "description": "For completeness, the parameters that can be specified in the input\nblock are summarized below:"
    },
    {
      "name": "A Technical Note:orcacclibÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "A Technical Note:orcacclibÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "We should finally mention a technical aspect. The CI procedure in ICE-CI\nis based around the so-called one particle coupling coefficients"
        }
      ],
      "parent_section": "iceci",
      "description": "We should finally mention a technical aspect. The CI procedure in ICE-CI\nis based around the so-called one particle coupling coefficients"
    },
    {
      "name": "CI methods using generated codeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: CI methods using generated codeÂ"
        }
      ],
      "parent_section": "autoci",
      "description": "ORCA: CI methods using generated codeÂ"
    },
    {
      "name": "IntroductionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "IntroductionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "All the theories are obtained by the means of automated programming\nwithin the ORCA-AGE (Automated Generator Environment for ORCA).[474,500]The CI\nmodule reads in the SCF wavefunction and optimizes the coefficient of\nthe CI expansion. Conceptually, the module is similar toorca_mdci,\ntherefore the input and output do have a lot in common."
        }
      ],
      "parent_section": "autoci",
      "description": "All the theories are obtained by the means of automated programming\nwithin the ORCA-AGE (Automated Generator Environment for ORCA).[474,500]The CI\nmodule reads in the SCF wavefunction and optimizes the coefficient of\nthe CI expansion. Conceptually, the module is similar toorca_mdci,\ntherefore the input and output do have a lot in common."
    },
    {
      "name": "InputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "InputÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "All parameters applicable to the AUTOCI module are shown below."
        }
      ],
      "parent_section": "autoci",
      "description": "All parameters applicable to the AUTOCI module are shown below."
    },
    {
      "name": "Available PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Available PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The following single-reference methods are currently implemented in the AUTOCI."
        }
      ],
      "parent_section": "autoci",
      "description": "The following single-reference methods are currently implemented in the AUTOCI."
    },
    {
      "name": "Analytic Nuclear Gradients with AUTOCIÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Analytic Nuclear Gradients with AUTOCIÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Obtaining accurate geometries is crucial to computing molecular properties\naccurately. In order to perform geometry optimisations, the nuclear gradient\nis necessary and while this can easily be obtained using numerical finite\ndifference methods, it is also quite costly. More importantly,\nperhaps, is the fact that numeric derivatives tend to become unstable.\nTherefore, being able to evaluate analyt"
        }
      ],
      "parent_section": "autoci",
      "description": "Obtaining accurate geometries is crucial to computing molecular properties\naccurately. In order to perform geometry optimisations, the nuclear gradient\nis necessary and while this can easily be obtained using numerical finite\ndifference methods, it is also quite costly. More importantly,\nperhaps, is the fact that numeric derivatives tend to become unstable.\nTherefore, being able to evaluate analyt"
    },
    {
      "name": "AUTOCI Response Properties via Analytic DerivativesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "AUTOCI Response Properties via Analytic DerivativesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For single-reference methods (currently limited toCCSDandMP2), some response properties\ncould be calculated via taking the analytic derivative of the wavefunctions computed by AUTOCI."
        }
      ],
      "parent_section": "autoci",
      "description": "For single-reference methods (currently limited toCCSDandMP2), some response properties\ncould be calculated via taking the analytic derivative of the wavefunctions computed by AUTOCI."
    },
    {
      "name": "Fully Internally Contracted MRCIÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Fully Internally Contracted MRCIÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting point for any multireference approach is a reference\nwavefunction that consists of multiple determinants or configurations\nstate functions (CSFs). In many instances this is the complete active\nspace SCF (CASSCF) wavefunction. In the uncontracted MRCI approach, as\nimplemented in theorca_mrcimodule, the wavefunction is expanded in\nterms of excited CSFs that are generated by considering exci"
        }
      ],
      "parent_section": "autoci",
      "description": "Starting point for any multireference approach is a reference\nwavefunction that consists of multiple determinants or configurations\nstate functions (CSFs). In many instances this is the complete active\nspace SCF (CASSCF) wavefunction. In the uncontracted MRCI approach, as\nimplemented in theorca_mrcimodule, the wavefunction is expanded in\nterms of excited CSFs that are generated by considering exci"
    },
    {
      "name": "Fully Internally Contracted MRCCÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Fully Internally Contracted MRCCÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Several approaches have been taken towards extending CC theory to work with\ngenuinely multiconfigurational reference wave functionsÂ[538],\nyet none of these approaches has found widespread adoption. As of 2011,\nthe internally contracted MRCC theory has had a revival, with a rigorous\ntheoretical investigation of several approximations that also proved its\norbital invarianceÂ[249]and a first report "
        }
      ],
      "parent_section": "autoci",
      "description": "Several approaches have been taken towards extending CC theory to work with\ngenuinely multiconfigurational reference wave functionsÂ[538],\nyet none of these approaches has found widespread adoption. As of 2011,\nthe internally contracted MRCC theory has had a revival, with a rigorous\ntheoretical investigation of several approximations that also proved its\norbital invarianceÂ[249]and a first report "
    },
    {
      "name": "Geometry OptimizationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Geometry OptimizationÂ"
        }
      ],
      "parent_section": "geomopt",
      "description": "ORCA: Geometry OptimizationÂ"
    },
    {
      "name": "Input Options and General ConsiderationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Input Options and General ConsiderationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The use of the geometry optimization module is relatively\nstraightforward.[1]"
        }
      ],
      "parent_section": "geomopt",
      "description": "The use of the geometry optimization module is relatively\nstraightforward.[1]"
    },
    {
      "name": "Transition State OptimizationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Transition State OptimizationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "As transition state finder we implemented the well-established\neigenvector following algorithm using a P-RFO step as implemented by\nBaker[67]. This algorithm is a quasi-Newton like algorithm."
        }
      ],
      "parent_section": "geomopt",
      "description": "As transition state finder we implemented the well-established\neigenvector following algorithm using a P-RFO step as implemented by\nBaker[67]. This algorithm is a quasi-Newton like algorithm."
    },
    {
      "name": "Minimum Energy Crossing PointsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Minimum Energy Crossing PointsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The MECP optimization allows the user to optimize to structures where\ntwo different potential energy surfaces (PES1 and PES2) cross each\nother. In this optimization two conditions apply: the energy\\(E_{1}\\)of\nPES1 is minimized while at the same time the energy difference\\(\\left({ E_{1} -E_{2} } \\right)^{2}\\)of both surfaces is minimized. For\nthe implementation we follow in principle the suggestion"
        }
      ],
      "parent_section": "geomopt",
      "description": "The MECP optimization allows the user to optimize to structures where\ntwo different potential energy surfaces (PES1 and PES2) cross each\nother. In this optimization two conditions apply: the energy\\(E_{1}\\)of\nPES1 is minimized while at the same time the energy difference\\(\\left({ E_{1} -E_{2} } \\right)^{2}\\)of both surfaces is minimized. For\nthe implementation we follow in principle the suggestion"
    },
    {
      "name": "Conical IntersectionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Conical IntersectionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The minima in the conical intersection seam-space between two states\n(named here I and J) can be found by using regular geometry optimization\nalgorithms, except that the gradient to be optimized is[545]:"
        }
      ],
      "parent_section": "geomopt",
      "description": "The minima in the conical intersection seam-space between two states\n(named here I and J) can be found by using regular geometry optimization\nalgorithms, except that the gradient to be optimized is[545]:"
    },
    {
      "name": "Numerical GradientsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Numerical GradientsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "If you want to use numerical instead of analytic gradients you have to\nuse"
        }
      ],
      "parent_section": "geomopt",
      "description": "If you want to use numerical instead of analytic gradients you have to\nuse"
    },
    {
      "name": "ORCA as External OptimizerÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "ORCA as External OptimizerÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "If you want to make use of ORCAâs routines for optimization, TS\noptimization, NEB, IRC, GOAT, etc., but not use ORCAâs built-in electronic\nstructure methods, you can use the keyword:"
        }
      ],
      "parent_section": "geomopt",
      "description": "If you want to make use of ORCAâs routines for optimization, TS\noptimization, NEB, IRC, GOAT, etc., but not use ORCAâs built-in electronic\nstructure methods, you can use the keyword:"
    },
    {
      "name": "Gaussian as External OptimizerÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Gaussian as External OptimizerÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "To use the external optimizer from Gaussian in ORCA,\nthe following keywords were provided in the past:"
        }
      ],
      "parent_section": "geomopt",
      "description": "To use the external optimizer from Gaussian in ORCA,\nthe following keywords were provided in the past:"
    },
    {
      "name": "Frequency calculations - numerical and analyticalÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Frequency calculations - numerical and analyticalÂ"
        }
      ],
      "parent_section": "frequencies",
      "description": "ORCA: Frequency calculations - numerical and analyticalÂ"
    },
    {
      "name": "Restarting Numerical Frequency calculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Restarting Numerical Frequency calculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "To restart a numerical frequencies calculation, use:"
        }
      ],
      "parent_section": "frequencies",
      "description": "To restart a numerical frequencies calculation, use:"
    },
    {
      "name": "Spring forcesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Spring forcesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In order to control the distribution of the images along the path,\nspring forces are included to act between adjacent images, tangential to\nthe path[416],"
        }
      ],
      "parent_section": "frequencies",
      "description": "In order to control the distribution of the images along the path,\nspring forces are included to act between adjacent images, tangential to\nthe path[416],"
    },
    {
      "name": "Optimization and convergence of the NEB methodÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Optimization and convergence of the NEB methodÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The effective force used in a standard NEB calculations is the sum of\nthe atomic force component perpendicular to the path and the spring\nforce component parallel to the path,"
        }
      ],
      "parent_section": "frequencies",
      "description": "The effective force used in a standard NEB calculations is the sum of\nthe atomic force component perpendicular to the path and the spring\nforce component parallel to the path,"
    },
    {
      "name": "Climbing image NEBÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Climbing image NEBÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In order make the highest energy image converge more accurately to the\n(highest) energy maximum along the MEP, the climbing image variant of\nthe NEB method (CI-NEB) can be used.Â[385]In the CI-NEB\nmethod, the effective force\\(F^\\text{NEB}\\)acting on the climbing image\n(i.e.\\(i=\\text{ci}\\)) is transformed to:"
        }
      ],
      "parent_section": "frequencies",
      "description": "In order make the highest energy image converge more accurately to the\n(highest) energy maximum along the MEP, the climbing image variant of\nthe NEB method (CI-NEB) can be used.Â[385]In the CI-NEB\nmethod, the effective force\\(F^\\text{NEB}\\)acting on the climbing image\n(i.e.\\(i=\\text{ci}\\)) is transformed to:"
    },
    {
      "name": "Generation of the initial pathÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Generation of the initial pathÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "One of the most important aspects of any NEB or CI-NEB calculation is\nthe generation of the initial path between the reactant and product\nenergy minima (keyword:interpolation. The recommended method is the\nimage-dependent pair potential (IDPP) method[808]. An alternative\nand simpler method is linear interpolation in Cartesian coordinates. In\neither case, the user should always inspect the initial "
        }
      ],
      "parent_section": "frequencies",
      "description": "One of the most important aspects of any NEB or CI-NEB calculation is\nthe generation of the initial path between the reactant and product\nenergy minima (keyword:interpolation. The recommended method is the\nimage-dependent pair potential (IDPP) method[808]. An alternative\nand simpler method is linear interpolation in Cartesian coordinates. In\neither case, the user should always inspect the initial "
    },
    {
      "name": "Removal of translational and rotational degrees of freedomÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Removal of translational and rotational degrees of freedomÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For NEB and CI-NEB calculations of molecular systems it is important to\nproject out the six (or five in the case of linear molecules) degrees of\nfreedom corresponding to the global rotation and translation of the\nsystem. This can be done either at the start of a calculation or for\neach optimization step (keyword:quatern). For the latter, the\ncenter-of-geometry of each image is translated to origin"
        }
      ],
      "parent_section": "frequencies",
      "description": "For NEB and CI-NEB calculations of molecular systems it is important to\nproject out the six (or five in the case of linear molecules) degrees of\nfreedom corresponding to the global rotation and translation of the\nsystem. This can be done either at the start of a calculation or for\neach optimization step (keyword:quatern). For the latter, the\ncenter-of-geometry of each image is translated to origin"
    },
    {
      "name": "Reparametrization of the pathÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Reparametrization of the pathÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In some cases it may be beneficial to enable redistribution of the\nimages along the path every\\(N\\)iterations (i.e. analogous to the string\nmethod[240]) (keyword:reparam). The path is then interpolated\nusing either a linear or cubic polynomial fitted to both the coordinates\nand the tangent to the path, and the images are redistributed evenly\nalong the interpolated path. Both\\(N\\)and the type of in"
        }
      ],
      "parent_section": "frequencies",
      "description": "In some cases it may be beneficial to enable redistribution of the\nimages along the path every\\(N\\)iterations (i.e. analogous to the string\nmethod[240]) (keyword:reparam). The path is then interpolated\nusing either a linear or cubic polynomial fitted to both the coordinates\nand the tangent to the path, and the images are redistributed evenly\nalong the interpolated path. Both\\(N\\)and the type of in"
    },
    {
      "name": "Useful outputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Useful outputÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "After each iteration, the energy profile along the path is obtained by\nmaking a piecewise cubic polynomial interpolation using both the energy\nand the component of the atom force tangentinal to the\npath[384]. The interpolation can reveal important\ninformation about the MEP in locations between the intermediate images.\nThe interpolation is written to the file âinterpâ (see file:\nbasename.interp"
        }
      ],
      "parent_section": "frequencies",
      "description": "After each iteration, the energy profile along the path is obtained by\nmaking a piecewise cubic polynomial interpolation using both the energy\nand the component of the atom force tangentinal to the\npath[384]. The interpolation can reveal important\ninformation about the MEP in locations between the intermediate images.\nThe interpolation is written to the file âinterpâ (see file:\nbasename.interp"
    },
    {
      "name": "Important warning messagesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Important warning messagesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Some tests are carried out during the optimization in order to detect\nproblems on the fly. The angle between the two straight lines going\nthrough an image and its neighbors on each side is calculated. If the\nangle becomes large e.g. exceeding 90\\(^\\circ\\)the estimate of the\ntangent has likely become inaccurate and a better resolution of the path\nis required. If the angle is close to 180\\(^\\circ\\)t"
        }
      ],
      "parent_section": "frequencies",
      "description": "Some tests are carried out during the optimization in order to detect\nproblems on the fly. The angle between the two straight lines going\nthrough an image and its neighbors on each side is calculated. If the\nangle becomes large e.g. exceeding 90\\(^\\circ\\)the estimate of the\ntangent has likely become inaccurate and a better resolution of the path\nis required. If the angle is close to 180\\(^\\circ\\)t"
    },
    {
      "name": "Parallel executionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Parallel executionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "If the number of processes (NProcs) specified in the input is larger\nthan 1, NEB will automatically start up in multi-processes mode:"
        }
      ],
      "parent_section": "frequencies",
      "description": "If the number of processes (NProcs) specified in the input is larger\nthan 1, NEB will automatically start up in multi-processes mode:"
    },
    {
      "name": "zoomNEBÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "zoomNEBÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A preliminary version of the Zoom-NEB (Z-NEB) method has been included\nthis implementation, where the objective of the method is to locate a\nsaddle point more accurately with a better resolution compared to CI-NEB\ncalculations. The Z-NEB method is an automatic two step procedure, where\nin the first step a CI-NEB calculation is carried out to obtain a rough\nconvergence towards the MEP. Then, the re"
        }
      ],
      "parent_section": "frequencies",
      "description": "A preliminary version of the Zoom-NEB (Z-NEB) method has been included\nthis implementation, where the objective of the method is to locate a\nsaddle point more accurately with a better resolution compared to CI-NEB\ncalculations. The Z-NEB method is an automatic two step procedure, where\nin the first step a CI-NEB calculation is carried out to obtain a rough\nconvergence towards the MEP. Then, the re"
    },
    {
      "name": "NEB-TSÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "NEB-TSÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Probably the most efficient saddle point search methods are obtained\nwhen double ended methods (e.g. NEB) are combined with single ended\nmethods (e.g., eigenvector-following). In the current implementation, a\ncombination of EW-CI-NEB and EF P-RFO (eigenvector-following partitioned\nrational function optimization) methods is presented and referred to as\nthe NEB-TS methodÂ[4]."
        }
      ],
      "parent_section": "frequencies",
      "description": "Probably the most efficient saddle point search methods are obtained\nwhen double ended methods (e.g. NEB) are combined with single ended\nmethods (e.g., eigenvector-following). In the current implementation, a\ncombination of EW-CI-NEB and EF P-RFO (eigenvector-following partitioned\nrational function optimization) methods is presented and referred to as\nthe NEB-TS methodÂ[4]."
    },
    {
      "name": "FAST-NEB-TS and LOOSE-NEB-TSÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "FAST-NEB-TS and LOOSE-NEB-TSÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Since our first NEB-TS implementation, we investigated a lot more\nsettings and variants, seeÂ[4]. Based on those findings,\ntwo new algorithms and convergence threshold settings have been\nimplemented into ORCA. FAST-NEB-TS corresponds to the IDPP-TS in the\npaper, and LOOSE-NEB-TS corresponds to the actual NEB-TS defaults, which\nare defined in the paper. Both features, FAST- and LOOSE-NEB-TS, show\ns"
        }
      ],
      "parent_section": "frequencies",
      "description": "Since our first NEB-TS implementation, we investigated a lot more\nsettings and variants, seeÂ[4]. Based on those findings,\ntwo new algorithms and convergence threshold settings have been\nimplemented into ORCA. FAST-NEB-TS corresponds to the IDPP-TS in the\npaper, and LOOSE-NEB-TS corresponds to the actual NEB-TS defaults, which\nare defined in the paper. Both features, FAST- and LOOSE-NEB-TS, show\ns"
    },
    {
      "name": "NEB / NEB-TS and TD-DFTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "NEB / NEB-TS and TD-DFTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The NEB and NEB-TS algorithm now also works in combination with TD-DFT.\nThe input:"
        }
      ],
      "parent_section": "frequencies",
      "description": "The NEB and NEB-TS algorithm now also works in combination with TD-DFT.\nThe input:"
    },
    {
      "name": "Summary of KeywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Summary of KeywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The following keywords are available:"
        }
      ],
      "parent_section": "frequencies",
      "description": "The following keywords are available:"
    },
    {
      "name": "Excited States via RPA, CIS, TD-DFT and SF-TDAÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via RPA, CIS, TD-DFT and SF-TDAÂ"
        }
      ],
      "parent_section": "tddft",
      "description": "ORCA: Excited States via RPA, CIS, TD-DFT and SF-TDAÂ"
    },
    {
      "name": "General FeaturesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General FeaturesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The module is invoked with the block:"
        }
      ],
      "parent_section": "tddft",
      "description": "The module is invoked with the block:"
    },
    {
      "name": "Semiempirical MethodsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Semiempirical MethodsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The semiempirical INDO/S method is very suitable to calculate absorption\nspectra of medium sized to large organic and inorganic molecules. It has\nbeen parameterized by the late M. C. Zerner for optical spectroscopy and\nin my experience at least, it tends to work nicely for many systems.\nWith the semiempirical approach it is easy to calculate many states of\nlarge molecules. For example, consider th"
        }
      ],
      "parent_section": "tddft",
      "description": "The semiempirical INDO/S method is very suitable to calculate absorption\nspectra of medium sized to large organic and inorganic molecules. It has\nbeen parameterized by the late M. C. Zerner for optical spectroscopy and\nin my experience at least, it tends to work nicely for many systems.\nWith the semiempirical approach it is easy to calculate many states of\nlarge molecules. For example, consider th"
    },
    {
      "name": "Hartree-Fock WavefunctionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Hartree-Fock WavefunctionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "When applying the procedures outlined above to pure Hartree-Fock, one\nobtains the ârandom-phase approximationâ (RPA) or the CI singles (CIS)\nmodel (when effectively using the Tamm-Dancoff Approximation, TDA). In\ngeneral, RPA and CIS calculations do not lead to good agreement with\nexperimental excitation energies and errors of 1-5 eV are common.\nTherefore HF/CIS is mostly a qualitative tool or "
        }
      ],
      "parent_section": "tddft",
      "description": "When applying the procedures outlined above to pure Hartree-Fock, one\nobtains the ârandom-phase approximationâ (RPA) or the CI singles (CIS)\nmodel (when effectively using the Tamm-Dancoff Approximation, TDA). In\ngeneral, RPA and CIS calculations do not lead to good agreement with\nexperimental excitation energies and errors of 1-5 eV are common.\nTherefore HF/CIS is mostly a qualitative tool or "
    },
    {
      "name": "Non-Hybrid and Hybrid DFTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Non-Hybrid and Hybrid DFTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For DFT functionals there is the choice between the full TD-DFT (eq.(7.219)) treatment\nand the so-called Tamm-Dancoff approximation (TDA)."
        }
      ],
      "parent_section": "tddft",
      "description": "For DFT functionals there is the choice between the full TD-DFT (eq.(7.219)) treatment\nand the so-called Tamm-Dancoff approximation (TDA)."
    },
    {
      "name": "Collinear Spin-Flip TDA (SF-TD-DFT)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Collinear Spin-Flip TDA (SF-TD-DFT)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Another approach to obtain excited states via CIS/TD-DFT are the so\ncalled spin-flip methods (for a good review, please check ref[144]). The idea is to start from an UHF state, and\nthen âflipâ one of the alpha electrons to generate states with\\(MS_{SF} = MS_{UHF} - 1\\). In order to do that, we look for excitations\nfrom alpha-to-beta orbitals only, and that makes the A matrix from TDA\neven simp"
        }
      ],
      "parent_section": "tddft",
      "description": "Another approach to obtain excited states via CIS/TD-DFT are the so\ncalled spin-flip methods (for a good review, please check ref[144]). The idea is to start from an UHF state, and\nthen âflipâ one of the alpha electrons to generate states with\\(MS_{SF} = MS_{UHF} - 1\\). In order to do that, we look for excitations\nfrom alpha-to-beta orbitals only, and that makes the A matrix from TDA\neven simp"
    },
    {
      "name": "Including solvation effects via LR-CPCM theoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Including solvation effects via LR-CPCM theoryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The LR-CPCM theory, as developed by Cammi and Tomasi[134],\nis implemented for both energies and gradients of excited states. It is\nturned on by default, whenever CPCM is also requested for the ground\nstate."
        }
      ],
      "parent_section": "tddft",
      "description": "The LR-CPCM theory, as developed by Cammi and Tomasi[134],\nis implemented for both energies and gradients of excited states. It is\nturned on by default, whenever CPCM is also requested for the ground\nstate."
    },
    {
      "name": "Simplified TDA and TD-DFTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Simplified TDA and TD-DFTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA also supports calculations of excited states using the simplified\nTamm-Dancoff approach (sTDA) by S. Grimme[323]. The sTDA is\nparticularly suited to calculate absorption spectra of very large\nsystems. sTDA as well as the simplified time-dependent density\nfunctional theory (sTD-DFT)[69]approach require a\n(hybrid) DFT ground state calculation. For large systems, using\nrange-separated hybrid fun"
        }
      ],
      "parent_section": "tddft",
      "description": "ORCA also supports calculations of excited states using the simplified\nTamm-Dancoff approach (sTDA) by S. Grimme[323]. The sTDA is\nparticularly suited to calculate absorption spectra of very large\nsystems. sTDA as well as the simplified time-dependent density\nfunctional theory (sTD-DFT)[69]approach require a\n(hybrid) DFT ground state calculation. For large systems, using\nrange-separated hybrid fun"
    },
    {
      "name": "Double-hybrid functionals and Doubles CorrectionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Double-hybrid functionals and Doubles CorrectionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The program can compute a doubles correction to the CIS excitation\nenergies. The theory is due to Head-Gordon and\nco-workers.[371]The basic idea is to compute a perturbative\nestimate (inspired by EOM-CCSD theory) to the CIS excited states that is\ncompatible with the MP2 ground state energy. In many cases this is a\nsignificant improvement over CIS itself and comes at a reasonable cost\nsince the cor"
        }
      ],
      "parent_section": "tddft",
      "description": "The program can compute a doubles correction to the CIS excitation\nenergies. The theory is due to Head-Gordon and\nco-workers.[371]The basic idea is to compute a perturbative\nestimate (inspired by EOM-CCSD theory) to the CIS excited states that is\ncompatible with the MP2 ground state energy. In many cases this is a\nsignificant improvement over CIS itself and comes at a reasonable cost\nsince the cor"
    },
    {
      "name": "Natural Transition OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural Transition OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Results of TD-DFT or CIS calculations can be tedious to interprete as\nmany individual MO pairs may contribute to a given excited state. In\norder to facilitate the analysis while keeping the familiar picture of\nan excited state originating from essentially an electron being promoted\nfrom a donor orbital to an acceptor orbital, the concept of ânatural\ntransition orbitalsâ can be used."
        }
      ],
      "parent_section": "tddft",
      "description": "Results of TD-DFT or CIS calculations can be tedious to interprete as\nmany individual MO pairs may contribute to a given excited state. In\norder to facilitate the analysis while keeping the familiar picture of\nan excited state originating from essentially an electron being promoted\nfrom a donor orbital to an acceptor orbital, the concept of ânatural\ntransition orbitalsâ can be used."
    },
    {
      "name": "Computational AspectsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Computational AspectsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Computational AspectsÂ"
        }
      ],
      "parent_section": "tddft",
      "description": "ORCA: Computational AspectsÂ"
    },
    {
      "name": "Keyword ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Keyword ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Keyword ListÂ"
        }
      ],
      "parent_section": "tddft",
      "description": "ORCA: Keyword ListÂ"
    },
    {
      "name": "Excited States via ROCIS and DFT/ROCISÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via ROCIS and DFT/ROCISÂ"
        }
      ],
      "parent_section": "rocis",
      "description": "ORCA: Excited States via ROCIS and DFT/ROCISÂ"
    },
    {
      "name": "General UseÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General UseÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the present implementation theorca_rocismodule is only able to\nperform CIS calculations on top of a high-spin ROHF reference function.\nAll spins of the unpaired electrons have to be coupled ferrmoagnetically\nto give a total spin of\\(S = \\frac{1}{2}N\\), where\\(N\\)is the number of\nunpaired electrons. Other ROHF functions such as Zernerâs configuration\naveraged or spin averaged ROHF cannot be us"
        }
      ],
      "parent_section": "rocis",
      "description": "In the present implementation theorca_rocismodule is only able to\nperform CIS calculations on top of a high-spin ROHF reference function.\nAll spins of the unpaired electrons have to be coupled ferrmoagnetically\nto give a total spin of\\(S = \\frac{1}{2}N\\), where\\(N\\)is the number of\nunpaired electrons. Other ROHF functions such as Zernerâs configuration\naveraged or spin averaged ROHF cannot be us"
    },
    {
      "name": "Transition Metal L-Edges with ROCIS or DFT/ROCISÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Transition Metal L-Edges with ROCIS or DFT/ROCISÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Theorca_rocisprogram was designed to calculate transition metal\nL-edge spectra of large molecules as they are observed in X-ray\nabsorption spectroscopy (XAS). An L-edge results when an electron is\npromoted from the 2p shell of a transition metal ion into the valence d\nshell by an X-ray photon. Strong spin-orbit coupling in the 2p shell and\np-d coupling phenomena complicate the interpretation and e"
        }
      ],
      "parent_section": "rocis",
      "description": "Theorca_rocisprogram was designed to calculate transition metal\nL-edge spectra of large molecules as they are observed in X-ray\nabsorption spectroscopy (XAS). An L-edge results when an electron is\npromoted from the 2p shell of a transition metal ion into the valence d\nshell by an X-ray photon. Strong spin-orbit coupling in the 2p shell and\np-d coupling phenomena complicate the interpretation and e"
    },
    {
      "name": "Natural Transition Orbitals/ Natural Difference OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural Transition Orbitals/ Natural Difference OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Likewise to CIS and TD-DFT (sectionNatural Transition Orbitals) The nature of the\ncalculated excited states in ROCIS and DFT/ROCIS can be analyzed by\nusing the Natural Transition Orbitals (NTO) or Natural Difference\nOrbitals (NDO) machineries.[688]Note that:"
        }
      ],
      "parent_section": "rocis",
      "description": "Likewise to CIS and TD-DFT (sectionNatural Transition Orbitals) The nature of the\ncalculated excited states in ROCIS and DFT/ROCIS can be analyzed by\nusing the Natural Transition Orbitals (NTO) or Natural Difference\nOrbitals (NDO) machineries.[688]Note that:"
    },
    {
      "name": "Resonant Inelastic Scattering SpectroscopyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Resonant Inelastic Scattering SpectroscopyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Resonant Inelastic Scattering SpectroscopyÂ"
        }
      ],
      "parent_section": "rocis",
      "description": "ORCA: Resonant Inelastic Scattering SpectroscopyÂ"
    },
    {
      "name": "Core PNO-ROCIS, PNO-ROCIS/DFTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core PNO-ROCIS, PNO-ROCIS/DFTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "It has been shown recently[546]that it is possible to combine\nthe powerful machinery of the PNOs with the ROCIS and ROCIS/DFT methods\nto formulate the core PNO-ROCIS and PNO-ROCIS/DFT methods. The usage of\nPNOs here is somewhat unconventional since they are not used to treat\nelectron correlation effects in a state specific manner. Rather, the\nPNOs are used to identify the relevant part of the virt"
        }
      ],
      "parent_section": "rocis",
      "description": "It has been shown recently[546]that it is possible to combine\nthe powerful machinery of the PNOs with the ROCIS and ROCIS/DFT methods\nto formulate the core PNO-ROCIS and PNO-ROCIS/DFT methods. The usage of\nPNOs here is somewhat unconventional since they are not used to treat\nelectron correlation effects in a state specific manner. Rather, the\nPNOs are used to identify the relevant part of the virt"
    },
    {
      "name": "ROCIS Magnetic PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "ROCIS Magnetic PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Several magnetic properies are availiable in the ROCIS method Including\ng-tensors (G-Matrix), zero field splittings (ZFS), hyperfine couplings\n(HFCs) and electric field gradients (EFGs)."
        }
      ],
      "parent_section": "rocis",
      "description": "Several magnetic properies are availiable in the ROCIS method Including\ng-tensors (G-Matrix), zero field splittings (ZFS), hyperfine couplings\n(HFCs) and electric field gradients (EFGs)."
    },
    {
      "name": "Keyword ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Keyword ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Keyword ListÂ"
        }
      ],
      "parent_section": "rocis",
      "description": "ORCA: Keyword ListÂ"
    },
    {
      "name": "Excited States via MC-RPAÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via MC-RPAÂ"
        }
      ],
      "parent_section": "mcrpa",
      "description": "ORCA: Excited States via MC-RPAÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The starting point of response theory for variational wave functions\nlike CASSCF is the time-dependent (TD) SchrÃ¶dinger equation in its\nphase-isolated form[174]"
        }
      ],
      "parent_section": "mcrpa",
      "description": "The starting point of response theory for variational wave functions\nlike CASSCF is the time-dependent (TD) SchrÃ¶dinger equation in its\nphase-isolated form[174]"
    },
    {
      "name": "Detecting CASSCF InstabilitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Detecting CASSCF InstabilitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Selecting the right orbitals for the active space is not always an easy\ntask. A wrong selection may lead to convergence to excited states or\nsaddle points when minimizing the CASSCF energy. Such an instability in\nthe wave function can be detected by computing the lowest excitation\nenergy, i.e. the lowest root of the electronic Hessian with MC-RPA."
        }
      ],
      "parent_section": "mcrpa",
      "description": "Selecting the right orbitals for the active space is not always an easy\ntask. A wrong selection may lead to convergence to excited states or\nsaddle points when minimizing the CASSCF energy. Such an instability in\nthe wave function can be detected by computing the lowest excitation\nenergy, i.e. the lowest root of the electronic Hessian with MC-RPA."
    },
    {
      "name": "Natural Transition OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural Transition OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Natural transition orbitals[380,562](NTO) are\nobtained from a singular value decomposition of the MC-RPA\nground-to-excited state (f) transition density matrices\\(\\rho^{0\\to f}_{pq}\\). As for TD-DFT and ROCIS one obtains two sets of\norbitals for each state that describe the donation (occupied and active)\nand acceptance (active and virtual) of an electron in the electronic\ntransition. The orbital st"
        }
      ],
      "parent_section": "mcrpa",
      "description": "Natural transition orbitals[380,562](NTO) are\nobtained from a singular value decomposition of the MC-RPA\nground-to-excited state (f) transition density matrices\\(\\rho^{0\\to f}_{pq}\\). As for TD-DFT and ROCIS one obtains two sets of\norbitals for each state that describe the donation (occupied and active)\nand acceptance (active and virtual) of an electron in the electronic\ntransition. The orbital st"
    },
    {
      "name": "Computational AspectsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Computational AspectsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The code is intended to be used for medium-sized and larger open-shell\nmolecules. It has the same scaling as ORCAâs first-order CASSCF energy\nimplementation though a larger pre-factor as the computational cost grow\nâin principleâ linearly with the number of roots."
        }
      ],
      "parent_section": "mcrpa",
      "description": "The code is intended to be used for medium-sized and larger open-shell\nmolecules. It has the same scaling as ORCAâs first-order CASSCF energy\nimplementation though a larger pre-factor as the computational cost grow\nâin principleâ linearly with the number of roots."
    },
    {
      "name": "Keyword ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Keyword ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Keyword ListÂ"
        }
      ],
      "parent_section": "mcrpa",
      "description": "ORCA: Keyword ListÂ"
    },
    {
      "name": "Excited States via EOM-CCSDÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via EOM-CCSDÂ"
        }
      ],
      "parent_section": "eom",
      "description": "ORCA: Excited States via EOM-CCSDÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The EOM wave function is parametrized in the following manner"
        }
      ],
      "parent_section": "eom",
      "description": "The EOM wave function is parametrized in the following manner"
    },
    {
      "name": "Memory ManagementÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Memory ManagementÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The most important data coming from the coupled-cluster routine are the\nground state energy and wave function, and the molecular integrals. The\nintegrals are then used to create âdressedâ integral containers, which\nallows for an efficient factorization of the EOM equations, since these\ndressed quantities do not change during the calculation. Most of these\nare written on disk, with the possible"
        }
      ],
      "parent_section": "eom",
      "description": "The most important data coming from the coupled-cluster routine are the\nground state energy and wave function, and the molecular integrals. The\nintegrals are then used to create âdressedâ integral containers, which\nallows for an efficient factorization of the EOM equations, since these\ndressed quantities do not change during the calculation. Most of these\nare written on disk, with the possible"
    },
    {
      "name": "Initial GuessÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Initial GuessÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The present initial guess in the RHF EOM implementation consists of\nconstructing a CIS Hamiltonian of a certain dimension, and diagonalizing\nit. The roots are preselected based on the energetic ordering of the\ndiagonal elements of the Hamiltonian. In the UHF case, the guess is\nconstructed from the solutions of a UHF CIS calculation. The number of\nroots in the initial guess is determined as 20 time"
        }
      ],
      "parent_section": "eom",
      "description": "The present initial guess in the RHF EOM implementation consists of\nconstructing a CIS Hamiltonian of a certain dimension, and diagonalizing\nit. The roots are preselected based on the energetic ordering of the\ndiagonal elements of the Hamiltonian. In the UHF case, the guess is\nconstructed from the solutions of a UHF CIS calculation. The number of\nroots in the initial guess is determined as 20 time"
    },
    {
      "name": "Hamiltonian ConstructionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Hamiltonian ConstructionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The Hamiltonian construction begins by calling the sigma routines. In\nthe case of the closed-shell code, the logical variablesUseEOMOptSandUseEOMOptDchoose the routines to be used in the evaluation of the\nsingles and doubles sigma vectors, respectively. If true, the optimized\nsigma routine, using dressed integrals, will be used. This should not be\nchanged, the option is there mainly for debugging "
        }
      ],
      "parent_section": "eom",
      "description": "The Hamiltonian construction begins by calling the sigma routines. In\nthe case of the closed-shell code, the logical variablesUseEOMOptSandUseEOMOptDchoose the routines to be used in the evaluation of the\nsingles and doubles sigma vectors, respectively. If true, the optimized\nsigma routine, using dressed integrals, will be used. This should not be\nchanged, the option is there mainly for debugging "
    },
    {
      "name": "Solution of the (Nonsymmetric) EigenproblemÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Solution of the (Nonsymmetric) EigenproblemÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Following the construction of the Hamiltonian, a nonsymmetric\neigensolver is called. In this case, it is possible to have complex\neigenvalues. In practice, this is rarely the case, and indicates a\nproblem of some kind. A warning will be given if this happens, however,\none may get away with this if it only happens in an isolated iteration\nstep."
        }
      ],
      "parent_section": "eom",
      "description": "Following the construction of the Hamiltonian, a nonsymmetric\neigensolver is called. In this case, it is possible to have complex\neigenvalues. In practice, this is rarely the case, and indicates a\nproblem of some kind. A warning will be given if this happens, however,\none may get away with this if it only happens in an isolated iteration\nstep."
    },
    {
      "name": "Convergence, Restart, Preconditioning and Subspace ExpansionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Convergence, Restart, Preconditioning and Subspace ExpansionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Convergence is signaled once a residual square norm based criteria is\nfulfilled. This criteria is determined by theCheckEachRootkeyword.\nIf it is true (default), the convergence of the residual square norm of\neach root is checked separately. This is due to the fact that different\nroots converge at a different rate. Once a root is converged, no new\ntrial vectors will be generated, belonging to that"
        }
      ],
      "parent_section": "eom",
      "description": "Convergence is signaled once a residual square norm based criteria is\nfulfilled. This criteria is determined by theCheckEachRootkeyword.\nIf it is true (default), the convergence of the residual square norm of\neach root is checked separately. This is due to the fact that different\nroots converge at a different rate. Once a root is converged, no new\ntrial vectors will be generated, belonging to that"
    },
    {
      "name": "Properties in the RHF EOM implementationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Properties in the RHF EOM implementationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The only property that can be calculated with the current RHF EOM\nimplementation is the transition moment. It is calculated as a CI-like\nexpectation value, as proposed by Stanton and Bartlett. The right and\nleft transition density are defined as"
        }
      ],
      "parent_section": "eom",
      "description": "The only property that can be calculated with the current RHF EOM\nimplementation is the transition moment. It is calculated as a CI-like\nexpectation value, as proposed by Stanton and Bartlett. The right and\nleft transition density are defined as"
    },
    {
      "name": "Some tips and tricks for EOM-CC calculationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Some tips and tricks for EOM-CC calculationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Some tips and tricks for EOM-CC calculationÂ"
        }
      ],
      "parent_section": "eom",
      "description": "ORCA: Some tips and tricks for EOM-CC calculationÂ"
    },
    {
      "name": "Excited States via STEOM-CCSDÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via STEOM-CCSDÂ"
        }
      ],
      "parent_section": "steom",
      "description": "ORCA: Excited States via STEOM-CCSDÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the standard EOM-CC method, the transformed Hamiltonian is\ndiagonalized over a singles and doubles space to obtain ionized,\nattached, or excited states of the reference state. In STEOM-CC, one\nperforms a second similarity transformation"
        }
      ],
      "parent_section": "steom",
      "description": "In the standard EOM-CC method, the transformed Hamiltonian is\ndiagonalized over a singles and doubles space to obtain ionized,\nattached, or excited states of the reference state. In STEOM-CC, one\nperforms a second similarity transformation"
    },
    {
      "name": "Selection of Active spaceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Selection of Active spaceÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The results of a STEOM-CC calculation depend upon the number of roots\nselected as active in the EOMIP and EOMEA calculations. In ORCA, they\nare chosen automatically, by using state-averaged CIS natural transition\norbitals (NTO). By default, the number of roots included in this initial\nCIS computation is equal to the number of roots requested in STEOM\n(NRoots). However, this can be modified setting"
        }
      ],
      "parent_section": "steom",
      "description": "The results of a STEOM-CC calculation depend upon the number of roots\nselected as active in the EOMIP and EOMEA calculations. In ORCA, they\nare chosen automatically, by using state-averaged CIS natural transition\norbitals (NTO). By default, the number of roots included in this initial\nCIS computation is equal to the number of roots requested in STEOM\n(NRoots). However, this can be modified setting"
    },
    {
      "name": "Active space selection using TD-DFT densitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Active space selection using TD-DFT densitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Instead of using a CIS calculation for selected the Active Space roots,\na TD-DFT based one can also be considered. Be aware that using DFT\nKohn-Sham orbitals for computing the CCSD GS energy can lead to some\ninstabilities and give incorrect results."
        }
      ],
      "parent_section": "steom",
      "description": "Instead of using a CIS calculation for selected the Active Space roots,\na TD-DFT based one can also be considered. Be aware that using DFT\nKohn-Sham orbitals for computing the CCSD GS energy can lead to some\ninstabilities and give incorrect results."
    },
    {
      "name": "The reliability of the calculated excitation energyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The reliability of the calculated excitation energyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The excitation energy for any states calculated in STEOM-CC are only\nreliable when the dominant excitation for that states are confined\nwithin the active space. This can be verified from the percentage active\ncharacter of the calculated states, ana posterioridiagnostic which is\ndefined as"
        }
      ],
      "parent_section": "steom",
      "description": "The excitation energy for any states calculated in STEOM-CC are only\nreliable when the dominant excitation for that states are confined\nwithin the active space. This can be verified from the percentage active\ncharacter of the calculated states, ana posterioridiagnostic which is\ndefined as"
    },
    {
      "name": "Removal of IP and EA states with double excitation characterÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Removal of IP and EA states with double excitation characterÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "To obtain accurate results with STEOM-CCSD, only the\\(\\hat{S}\\)amplitudes corresponding to the states dominated by single excitations\nshould be included in the second similarity transformation. This is\nensured in ORCA in two ways. First, the root following (FollowCIS) is\nactivated by default so that it converges to the states dominated by\nsingly excited guess vectors. This avoids the calculation o"
        }
      ],
      "parent_section": "steom",
      "description": "To obtain accurate results with STEOM-CCSD, only the\\(\\hat{S}\\)amplitudes corresponding to the states dominated by single excitations\nshould be included in the second similarity transformation. This is\nensured in ORCA in two ways. First, the root following (FollowCIS) is\nactivated by default so that it converges to the states dominated by\nsingly excited guess vectors. This avoids the calculation o"
    },
    {
      "name": "Transition and difference densitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Transition and difference densitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "At the end of a STEOM computation, it is possible to store the final\neigenvectors in a file âjob.cisâ, in analogy with what is done for CIS\nand TD-DFT computations. This file can be obtained by settingDoStoreSTEOMtruein the input. This file can then be processed byorca_plotto obtain the difference and / or the transition densities."
        }
      ],
      "parent_section": "steom",
      "description": "At the end of a STEOM computation, it is possible to store the final\neigenvectors in a file âjob.cisâ, in analogy with what is done for CIS\nand TD-DFT computations. This file can be obtained by settingDoStoreSTEOMtruein the input. This file can then be processed byorca_plotto obtain the difference and / or the transition densities."
    },
    {
      "name": "PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The dipolar and transition moments (as well as the oscillator strength)\ncan be computed within the STEOM module using different kinds of\napproximations. Please cite our paper on these corrected STEOM\ntransition densities[297]! Starting from ORCA 5,\nnew defaults (DoSimpleDensfalse) are used that are much better\nthan the previous CIS-like approximation, and the full option is of\nCC3-like quality."
        }
      ],
      "parent_section": "steom",
      "description": "The dipolar and transition moments (as well as the oscillator strength)\ncan be computed within the STEOM module using different kinds of\napproximations. Please cite our paper on these corrected STEOM\ntransition densities[297]! Starting from ORCA 5,\nnew defaults (DoSimpleDensfalse) are used that are much better\nthan the previous CIS-like approximation, and the full option is of\nCC3-like quality."
    },
    {
      "name": "Solvation (Experimental)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Solvation (Experimental)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In STEOM-CCSD, the excitation energies and densities can be corrected\nusing the CPCM solvation scheme in ORCA."
        }
      ],
      "parent_section": "steom",
      "description": "In STEOM-CCSD, the excitation energies and densities can be corrected\nusing the CPCM solvation scheme in ORCA."
    },
    {
      "name": "Spin-Orbit Coupling (Experimental)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Spin-Orbit Coupling (Experimental)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "You can compute the spin-orbit coupling between singlet and triplets\nstates in STEOM-CCSD using the keywordSTEOMSOCtrue.\nPlease note that all SOC matrix elements and properties are currently\ncomputed from theright vector only!"
        }
      ],
      "parent_section": "steom",
      "description": "You can compute the spin-orbit coupling between singlet and triplets\nstates in STEOM-CCSD using the keywordSTEOMSOCtrue.\nPlease note that all SOC matrix elements and properties are currently\ncomputed from theright vector only!"
    },
    {
      "name": "Core excitationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core excitationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The STEOM-CCSD (and bt-PNO-STEOM-CCSD) method can also be used to\ncompute the K-edge core-excitation energy of molecules. SeeCore-Excitationfor more details."
        }
      ],
      "parent_section": "steom",
      "description": "The STEOM-CCSD (and bt-PNO-STEOM-CCSD) method can also be used to\ncompute the K-edge core-excitation energy of molecules. SeeCore-Excitationfor more details."
    },
    {
      "name": "Transient absorptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Transient absorptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Transient absorption spectra can be computed using the keywordDoTranstrue. TheIRootkeyword will select the\ntargeted excited state."
        }
      ],
      "parent_section": "steom",
      "description": "Transient absorption spectra can be computed using the keywordDoTranstrue. TheIRootkeyword will select the\ntargeted excited state."
    },
    {
      "name": "Excited States via IH-FSMR-CCSDÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via IH-FSMR-CCSDÂ"
        }
      ],
      "parent_section": "ihfsmr",
      "description": "ORCA: Excited States via IH-FSMR-CCSDÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "FSMRCC is originally based on an effective Hamiltonian (EH). The basic\nidea of EH theory is to obtain some selective eigenvalues of the\nHamiltonian operator from the total eigenvalue spectrum. For this\npurpose, the entire configuration space is divided into a model and an\nouter space with projection operators\\(P_{M}\\)and\\(Q_{M}\\), respectively\n(seeFig. 7.38). The diagonalization of the EH takes ca"
        }
      ],
      "parent_section": "ihfsmr",
      "description": "FSMRCC is originally based on an effective Hamiltonian (EH). The basic\nidea of EH theory is to obtain some selective eigenvalues of the\nHamiltonian operator from the total eigenvalue spectrum. For this\npurpose, the entire configuration space is divided into a model and an\nouter space with projection operators\\(P_{M}\\)and\\(Q_{M}\\), respectively\n(seeFig. 7.38). The diagonalization of the EH takes ca"
    },
    {
      "name": "PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The transition properties can be calculated using a simple CIS-like\nformulation, employing the converged IH-FSMR-CC eigenvectors. The\ntransition moments are computed by default in an IH-FSMR-CCSD\ncalculation."
        }
      ],
      "parent_section": "ihfsmr",
      "description": "The transition properties can be calculated using a simple CIS-like\nformulation, employing the converged IH-FSMR-CC eigenvectors. The\ntransition moments are computed by default in an IH-FSMR-CCSD\ncalculation."
    },
    {
      "name": "Solvation CorrectionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Solvation CorrectionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Solvent effects can be approximated by a simple perturbative correction\nto the IH-FSMR-CCSD via"
        }
      ],
      "parent_section": "ihfsmr",
      "description": "Solvent effects can be approximated by a simple perturbative correction\nto the IH-FSMR-CCSD via"
    },
    {
      "name": "Excited States using PNO-based coupled clusterÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States using PNO-based coupled clusterÂ"
        }
      ],
      "parent_section": "dleom",
      "description": "ORCA: Excited States using PNO-based coupled clusterÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The back transformation of the ground state DLPNO-CCSD amplitudes to the\nvirtual space involves three steps. The\\(T\\)amplitudes in the PNO basis\nare first converted into the PAO basis, then subsequently to the atomic\norbital (AO) basis, and finally to the canonical MO\nbasis[234]. For example, in the closed-shell case, we have"
        }
      ],
      "parent_section": "dleom",
      "description": "The back transformation of the ground state DLPNO-CCSD amplitudes to the\nvirtual space involves three steps. The\\(T\\)amplitudes in the PNO basis\nare first converted into the PAO basis, then subsequently to the atomic\norbital (AO) basis, and finally to the canonical MO\nbasis[234]. For example, in the closed-shell case, we have"
    },
    {
      "name": "Reference State EnergyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Reference State EnergyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Here, it should be noted that the reference energy for PNO-based\nEOM-CCSD or STEOM-CCSD is slightly different from that printed for a\nconverged ground state DLPNO-CCSD calculation, as it includes the\nperturbative correction for different truncated quantities."
        }
      ],
      "parent_section": "dleom",
      "description": "Here, it should be noted that the reference energy for PNO-based\nEOM-CCSD or STEOM-CCSD is slightly different from that printed for a\nconverged ground state DLPNO-CCSD calculation, as it includes the\nperturbative correction for different truncated quantities."
    },
    {
      "name": "Use of Local OrbitalsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Use of Local OrbitalsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The use of local orbitals makes it difficult to follow a particular\nguess vector in the Davidson digonalization process in EOM-CC and\nSTEOM-CC. Therefore, it is advisable to recanonicalize the occupied\norbitals after the ground state DLPNO-CCSD calculation by setting\nDoRECAN to true (i.e. only relevant for the closed-shell RHF\nimplementation). It should be noted that the recanonicalization does no"
        }
      ],
      "parent_section": "dleom",
      "description": "The use of local orbitals makes it difficult to follow a particular\nguess vector in the Davidson digonalization process in EOM-CC and\nSTEOM-CC. Therefore, it is advisable to recanonicalize the occupied\norbitals after the ground state DLPNO-CCSD calculation by setting\nDoRECAN to true (i.e. only relevant for the closed-shell RHF\nimplementation). It should be noted that the recanonicalization does no"
    },
    {
      "name": "Some tips and tricks for bt-PNO calculationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Some tips and tricks for bt-PNO calculationsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Some tips and tricks for bt-PNO calculationsÂ"
        }
      ],
      "parent_section": "dleom",
      "description": "ORCA: Some tips and tricks for bt-PNO calculationsÂ"
    },
    {
      "name": "Excited States via DLPNO-STEOM-CCSDÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Excited States via DLPNO-STEOM-CCSDÂ"
        }
      ],
      "parent_section": "dlpno-steom",
      "description": "ORCA: Excited States via DLPNO-STEOM-CCSDÂ"
    },
    {
      "name": "PNO dressing (experimental keyword)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "PNO dressing (experimental keyword)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In STEOM-DLPNO-CCSD method most of the steps are done using the powerful\nPNO approximation except the last one corresponding to the STEOM-CCSD\ncalculation itself. In the canonical version of the dressing (default in\nORCA) all the amplitudes previously computed at the PNO level are\nrecanonicalized which increases the calculation cost.PNO dressing uses\nsome of the PNO intermediates to reduce the dre"
        }
      ],
      "parent_section": "dlpno-steom",
      "description": "In STEOM-DLPNO-CCSD method most of the steps are done using the powerful\nPNO approximation except the last one corresponding to the STEOM-CCSD\ncalculation itself. In the canonical version of the dressing (default in\nORCA) all the amplitudes previously computed at the PNO level are\nrecanonicalized which increases the calculation cost.PNO dressing uses\nsome of the PNO intermediates to reduce the dre"
    },
    {
      "name": "Keywords from STEOM-CCSDÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Keywords from STEOM-CCSDÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Most of the keywords from STEOM-CCSD can be used within the DLPNO\nversion, except for core excitation. More information on theExcited States via STEOM-CCSDsection."
        }
      ],
      "parent_section": "dlpno-steom",
      "description": "Most of the keywords from STEOM-CCSD can be used within the DLPNO\nversion, except for core excitation. More information on theExcited States via STEOM-CCSDsection."
    },
    {
      "name": "Tips and TricksÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Tips and TricksÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "As written in the typical calculation section of the manual we would\nrecommend this input for standard organic molecules."
        }
      ],
      "parent_section": "dlpno-steom",
      "description": "As written in the typical calculation section of the manual we would\nrecommend this input for standard organic molecules."
    },
    {
      "name": "Core-level spectroscopy with coupled cluster methodsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Core-level spectroscopy with coupled cluster methodsÂ"
        }
      ],
      "parent_section": "eomcore",
      "description": "ORCA: Core-level spectroscopy with coupled cluster methodsÂ"
    },
    {
      "name": "Core-ionizationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core-ionizationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "One can obtain core-ionized states if one calculates a large no of\nroots. The ORCA implementation of IP-EOM-CCSD, however, allows one to\ndirectly target the ionization from the core-orbitals. A typical\nIP-EOM-CCSD input file for the acetic acid will look like"
        }
      ],
      "parent_section": "eomcore",
      "description": "One can obtain core-ionized states if one calculates a large no of\nroots. The ORCA implementation of IP-EOM-CCSD, however, allows one to\ndirectly target the ionization from the core-orbitals. A typical\nIP-EOM-CCSD input file for the acetic acid will look like"
    },
    {
      "name": "Core-ExcitationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Core-ExcitationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The STEOM-CCSD approach provides an efficient and accurate way to do the\nK-edge core-excitation spectroscopy. A typical input file for the\nSTEOM-CCSD will look like"
        }
      ],
      "parent_section": "eomcore",
      "description": "The STEOM-CCSD approach provides an efficient and accurate way to do the\nK-edge core-excitation spectroscopy. A typical input file for the\nSTEOM-CCSD will look like"
    },
    {
      "name": "The Multireference Correlation ModuleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: The Multireference Correlation ModuleÂ"
        }
      ],
      "parent_section": "mrci",
      "description": "ORCA: The Multireference Correlation ModuleÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A number ofuncontractedmultireference approaches are implemented\nin ORCA and reside in theorca_mrcimodule. All of these approaches\nstart with a reference wavefunction that consists of multiple\nconfigurations (orbital occupation patterns). The reference wavefunction\ndefined in therefsubblock can be a complete active space (CAS),\nrestricted active space (RAS) or an arbitrary list of configurations.\n"
        }
      ],
      "parent_section": "mrci",
      "description": "A number ofuncontractedmultireference approaches are implemented\nin ORCA and reside in theorca_mrcimodule. All of these approaches\nstart with a reference wavefunction that consists of multiple\nconfigurations (orbital occupation patterns). The reference wavefunction\ndefined in therefsubblock can be a complete active space (CAS),\nrestricted active space (RAS) or an arbitrary list of configurations.\n"
    },
    {
      "name": "Properties Calculation Using the SOC SubmoduleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Properties Calculation Using the SOC SubmoduleÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Properties Calculation Using the SOC SubmoduleÂ"
        }
      ],
      "parent_section": "mrci",
      "description": "ORCA: Properties Calculation Using the SOC SubmoduleÂ"
    },
    {
      "name": "Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) TheoryÂ"
        }
      ],
      "parent_section": "mreom",
      "description": "ORCA: Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) TheoryÂ"
    },
    {
      "name": "The Steps Required to Run an MR-EOM CalculationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Steps Required to Run an MR-EOM CalculationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "To illustrate the various steps required in a typical MR-EOM\ncalculation, we will consider the calculation of the excitation energies\nof the neutral Fe atom at the MR-EOM-T|T\\(^{\\dagger}\\)|SXD|U-h-v level of\ntheory."
        }
      ],
      "parent_section": "mreom",
      "description": "To illustrate the various steps required in a typical MR-EOM\ncalculation, we will consider the calculation of the excitation energies\nof the neutral Fe atom at the MR-EOM-T|T\\(^{\\dagger}\\)|SXD|U-h-v level of\ntheory."
    },
    {
      "name": "Perturbative MR-EOM-PTÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Perturbative MR-EOM-PTÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The MR-EOMPT approach was developed for situations where the full\naccuracy of the iterative MR-EOMCC method is not required. It performs\non par with other multireference perturbation theories such as\nfic-NEVPT2 and does not have the convergence difficulties with the\\(\\hat T\\)and\\(\\hat S,\\hat X,\\hat D\\)amplitudes like its iterative parent\nmethod as these amplitudes are computed in a non-iterative f"
        }
      ],
      "parent_section": "mreom",
      "description": "The MR-EOMPT approach was developed for situations where the full\naccuracy of the iterative MR-EOMCC method is not required. It performs\non par with other multireference perturbation theories such as\nfic-NEVPT2 and does not have the convergence difficulties with the\\(\\hat T\\)and\\(\\hat S,\\hat X,\\hat D\\)amplitudes like its iterative parent\nmethod as these amplitudes are computed in a non-iterative f"
    },
    {
      "name": "General Description of the ProgramÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General Description of the ProgramÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The program input comprises the following information: (1) model and\nspecification of the model parameters characterizing the electronic\nstructure of a molecule, as well as lineshape factors; (2) spectral\nranges and resolution for simulations; (3) specification of vibrational\ntransitions for rR excitation profile and spectra generation; (4)\ncertain algorithm-selecting options depending on the mode"
        }
      ],
      "parent_section": "asa.general",
      "description": "The program input comprises the following information: (1) model and\nspecification of the model parameters characterizing the electronic\nstructure of a molecule, as well as lineshape factors; (2) spectral\nranges and resolution for simulations; (3) specification of vibrational\ntransitions for rR excitation profile and spectra generation; (4)\ncertain algorithm-selecting options depending on the mode"
    },
    {
      "name": "Spectral Simulation Procedures: Input Structure and Model ParametersÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Spectral Simulation Procedures: Input Structure and Model ParametersÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Spectral Simulation Procedures: Input Structure and Model ParametersÂ"
        }
      ],
      "parent_section": "asa.general",
      "description": "ORCA: Spectral Simulation Procedures: Input Structure and Model ParametersÂ"
    },
    {
      "name": "Fitting of Experimental SpectraÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Fitting of Experimental SpectraÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Fitting of Experimental SpectraÂ"
        }
      ],
      "parent_section": "asa.general",
      "description": "ORCA: Fitting of Experimental SpectraÂ"
    },
    {
      "name": "One Photon SpectroscopyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: One Photon SpectroscopyÂ"
        }
      ],
      "parent_section": "ops",
      "description": "ORCA: One Photon SpectroscopyÂ"
    },
    {
      "name": "General DescriptionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General DescriptionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduced in Orca 6.0, the One Photon Spectroscopy (OPS) tool now takes charge of computing one-photon absorption (OPA), emission (OPE), and natural electric circular dichroism (ECD) intensities.\nIn each of these processes, the intensity of the spectrum (\\(I(\\omega)\\)) resulting from a transition between an initial state\\(I\\)and a final state\\(J\\)is determined by the square modulus of the transit"
        }
      ],
      "parent_section": "ops",
      "description": "Introduced in Orca 6.0, the One Photon Spectroscopy (OPS) tool now takes charge of computing one-photon absorption (OPA), emission (OPE), and natural electric circular dichroism (ECD) intensities.\nIn each of these processes, the intensity of the spectrum (\\(I(\\omega)\\)) resulting from a transition between an initial state\\(I\\)and a final state\\(J\\)is determined by the square modulus of the transit"
    },
    {
      "name": "Light-matter interaction approachesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Light-matter interaction approachesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Expressions for\\(\\hat{H}_1\\)can be derived from different theoretical perspectives. For instructional purposes, a classical electrodynamic approach is adopted here. By representing light classically through a vector potential (\\(\\textbf{A}\\)) and a scalar potential (\\(\\phi = 0\\)), the radiation can be integrated into the Hamiltonian that models the molecular system."
        }
      ],
      "parent_section": "ops",
      "description": "Expressions for\\(\\hat{H}_1\\)can be derived from different theoretical perspectives. For instructional purposes, a classical electrodynamic approach is adopted here. By representing light classically through a vector potential (\\(\\textbf{A}\\)) and a scalar potential (\\(\\phi = 0\\)), the radiation can be integrated into the Hamiltonian that models the molecular system."
    },
    {
      "name": "Natural electric circular dichroismÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural electric circular dichroismÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the case of ECD modeling, intensity is determined by computing the difference between two absorption spectra: one acquired using left-circularly polarized light and the other utilizing right-circularly polarized light."
        }
      ],
      "parent_section": "ops",
      "description": "In the case of ECD modeling, intensity is determined by computing the difference between two absorption spectra: one acquired using left-circularly polarized light and the other utilizing right-circularly polarized light."
    },
    {
      "name": "SOC and SSC corrected spectrumÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "SOC and SSC corrected spectrumÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "All the OPS keywords and tables listed above are available for the cases in which spin-orbit coupling and spin-spin coupling effects are taken into account by a QDPT formulation\n(when the method is available in the selected ORCA module). In those cases, ORCA 6.0 does not provide symmetry after the relativistic correction; therefore,\\(C_1\\)group symmetry transitions are reported.\nAdditionally, the "
        }
      ],
      "parent_section": "ops",
      "description": "All the OPS keywords and tables listed above are available for the cases in which spin-orbit coupling and spin-spin coupling effects are taken into account by a QDPT formulation\n(when the method is available in the selected ORCA module). In those cases, ORCA 6.0 does not provide symmetry after the relativistic correction; therefore,\\(C_1\\)group symmetry transitions are reported.\nAdditionally, the "
    },
    {
      "name": "OPS Full list of keywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "OPS Full list of keywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The folowing list of keywords may be included directly in the correcponding module block to trigger OPS compute the corresponding intensities."
        }
      ],
      "parent_section": "ops",
      "description": "The folowing list of keywords may be included directly in the correcponding module block to trigger OPS compute the corresponding intensities."
    },
    {
      "name": "NotesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "NotesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "NotesÂ"
        }
      ],
      "parent_section": "ops",
      "description": "ORCA: NotesÂ"
    },
    {
      "name": "Magnetic properties through Quasi Degenerate Perturbation TheoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Magnetic properties through Quasi Degenerate Perturbation TheoryÂ"
        }
      ],
      "parent_section": "qdpt magnetic properties",
      "description": "ORCA: Magnetic properties through Quasi Degenerate Perturbation TheoryÂ"
    },
    {
      "name": "Quasi Degenerate Perturbation Theory (QDPT) in a nutshellÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Quasi Degenerate Perturbation Theory (QDPT) in a nutshellÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Quasi Degenerate Perturbation Theory offers a versatile and accurate approach to\nto a number of magnetic properties for basically every wavefunction based excited\nstates method."
        }
      ],
      "parent_section": "qdpt magnetic properties",
      "description": "Quasi Degenerate Perturbation Theory offers a versatile and accurate approach to\nto a number of magnetic properties for basically every wavefunction based excited\nstates method."
    },
    {
      "name": "Magnetic properties through the Effective HamiltonianÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Magnetic properties through the Effective HamiltonianÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Since both the energies and the wavefunction of the low-lying\nspin-orbit states are available, the effective Hamiltonian theory can be\nused to extract EPR parameters such as the full G,  Zero Field Splitting (ZFS)\nand hyperfine A tensors."
        }
      ],
      "parent_section": "qdpt magnetic properties",
      "description": "Since both the energies and the wavefunction of the low-lying\nspin-orbit states are available, the effective Hamiltonian theory can be\nused to extract EPR parameters such as the full G,  Zero Field Splitting (ZFS)\nand hyperfine A tensors."
    },
    {
      "name": "Organization of QDPT Magnetic Properties ComputationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Organization of QDPT Magnetic Properties ComputationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 6.0 the calculation of the magnetic properties through the\nQuasi Degenerate Perturbation Theory (QDPT) in all available correlation type modules is unified\nand simplified. Following the general architecture design of ORCA 6.0 the computation\nof all the involved magnetic properties are centrally performed by a driver data structure called the QDPT Driver.\nThe Driver takes into ac"
        }
      ],
      "parent_section": "qdpt magnetic properties",
      "description": "Starting from ORCA 6.0 the calculation of the magnetic properties through the\nQuasi Degenerate Perturbation Theory (QDPT) in all available correlation type modules is unified\nand simplified. Following the general architecture design of ORCA 6.0 the computation\nof all the involved magnetic properties are centrally performed by a driver data structure called the QDPT Driver.\nThe Driver takes into ac"
    },
    {
      "name": "Simulation of (Magnetic) Circular Dichroism and Absorption SpectraÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Simulation of (Magnetic) Circular Dichroism and Absorption SpectraÂ"
        }
      ],
      "parent_section": "mcd",
      "description": "ORCA: Simulation of (Magnetic) Circular Dichroism and Absorption SpectraÂ"
    },
    {
      "name": "General description of the programÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General description of the programÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA can now simulate optical spectra that include spin-orbit coupling\ncontributions at all levels of theory by using a common implementation.[269]"
        }
      ],
      "parent_section": "mcd",
      "description": "ORCA can now simulate optical spectra that include spin-orbit coupling\ncontributions at all levels of theory by using a common implementation.[269]"
    },
    {
      "name": "Running and analyzing MCD calculations in TDDFT moduleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Running and analyzing MCD calculations in TDDFT moduleÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A minimum input to compute the Magnetic Circular Dichroism (MCD) requires\nsetting the keyword DoMCD to true and to include an intensity for the\nexternal magnetic field B (in Gauss). An example input for the TD-DFT module\nis as follows:"
        }
      ],
      "parent_section": "mcd",
      "description": "A minimum input to compute the Magnetic Circular Dichroism (MCD) requires\nsetting the keyword DoMCD to true and to include an intensity for the\nexternal magnetic field B (in Gauss). An example input for the TD-DFT module\nis as follows:"
    },
    {
      "name": "Running MCD calculations in other modulesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Running MCD calculations in other modulesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The MCD implementation can also be used in other modules such as\nSTEOM-CCSD, CAS, ROCIS, and MRCI (see the input file examples given\nbelow) by using the same keywords as those described for the TDDFT module.\nIn the case of CAS, ROCIS, and MR-CI modules, it is necessary to include\nthe keywordNewMCDTrue; otherwise, the previous MCD implementation\nwill be called instead."
        }
      ],
      "parent_section": "mcd",
      "description": "The MCD implementation can also be used in other modules such as\nSTEOM-CCSD, CAS, ROCIS, and MRCI (see the input file examples given\nbelow) by using the same keywords as those described for the TDDFT module.\nIn the case of CAS, ROCIS, and MR-CI modules, it is necessary to include\nthe keywordNewMCDTrue; otherwise, the previous MCD implementation\nwill be called instead."
    },
    {
      "name": "List of related keywordsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "List of related keywordsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "List of related keywordsÂ"
        }
      ],
      "parent_section": "mcd",
      "description": "ORCA: List of related keywordsÂ"
    },
    {
      "name": "More on the Excited State Dynamics moduleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: More on the Excited State Dynamics moduleÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: More on the Excited State Dynamics moduleÂ"
    },
    {
      "name": "Absorption and Emission Rates and SpectrumÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Absorption and Emission Rates and SpectrumÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Absorption and Emission Rates and SpectrumÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Absorption and Emission Rates and SpectrumÂ"
    },
    {
      "name": "Intersystem crossing ratesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Intersystem crossing ratesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Intersystem crossing ratesÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Intersystem crossing ratesÂ"
    },
    {
      "name": "Resonant Raman SpectrumÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Resonant Raman SpectrumÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Resonant Raman SpectrumÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Resonant Raman SpectrumÂ"
    },
    {
      "name": "Circular Polarized SpectroscopiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Circular Polarized SpectroscopiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Circular Polarized SpectroscopiesÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Circular Polarized SpectroscopiesÂ"
    },
    {
      "name": "Magnetic Circular DichroismÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Magnetic Circular DichroismÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Magnetic Circular DichroismÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Magnetic Circular DichroismÂ"
    },
    {
      "name": "Complete Keyword List for the ESD ModuleÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Complete Keyword List for the ESD ModuleÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Complete Keyword List for the ESD ModuleÂ"
        }
      ],
      "parent_section": "esd",
      "description": "ORCA: Complete Keyword List for the ESD ModuleÂ"
    },
    {
      "name": "More details on the ORCA DOCKERÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: More details on the ORCA DOCKERÂ"
        }
      ],
      "parent_section": "docker",
      "description": "ORCA: More details on the ORCA DOCKERÂ"
    },
    {
      "name": "Underlying theoryÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Underlying theoryÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The basic idea behind the DOCKER is to use a type of swarm intelligence[787]to find local minima for where theHOSTwould best be positioned, based on the energies and gradients of a given Potential Energy Surface (PES)."
        }
      ],
      "parent_section": "docker",
      "description": "The basic idea behind the DOCKER is to use a type of swarm intelligence[787]to find local minima for where theHOSTwould best be positioned, based on the energies and gradients of a given Potential Energy Surface (PES)."
    },
    {
      "name": "Looking Deeper into the OutputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Looking Deeper into the OutputÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The details related to the grid and the swarm optimization can be found on the output, here is one example taken from the water dimer example from the earlier section:"
        }
      ],
      "parent_section": "docker",
      "description": "The details related to the grid and the swarm optimization can be found on the output, here is one example taken from the water dimer example from the earlier section:"
    },
    {
      "name": "The final stepsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The final stepsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "After the evolution step, a total of\\(max(sqrt(PopSize),5)\\)structures are taken from the set of solutions for a final full optimization. The output looks like:"
        }
      ],
      "parent_section": "docker",
      "description": "After the evolution step, a total of\\(max(sqrt(PopSize),5)\\)structures are taken from the set of solutions for a final full optimization. The output looks like:"
    },
    {
      "name": "General TipsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "General TipsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "General TipsÂ"
        }
      ],
      "parent_section": "docker",
      "description": "ORCA: General TipsÂ"
    },
    {
      "name": "Complete Keyword ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Complete Keyword ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Complete Keyword ListÂ"
        }
      ],
      "parent_section": "docker",
      "description": "ORCA: Complete Keyword ListÂ"
    },
    {
      "name": "More on the ORCA SOLVATORÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: More on the ORCA SOLVATORÂ"
        }
      ],
      "parent_section": "solvator",
      "description": "ORCA: More on the ORCA SOLVATORÂ"
    },
    {
      "name": "The Simpler Stochastic ModeÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Simpler Stochastic ModeÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "TheCLUSTERMODESTOCHASTIC, as the name suggests, uses random trial and error to assign the placing of the solvents. Well, it is actually more complicated than that."
        }
      ],
      "parent_section": "solvator",
      "description": "TheCLUSTERMODESTOCHASTIC, as the name suggests, uses random trial and error to assign the placing of the solvents. Well, it is actually more complicated than that."
    },
    {
      "name": "Adding Explicit Solvents with the DockerÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Adding Explicit Solvents with the DockerÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Adding Explicit Solvents with the DockerÂ"
        }
      ],
      "parent_section": "solvator",
      "description": "ORCA: Adding Explicit Solvents with the DockerÂ"
    },
    {
      "name": "Controlling True RandomnessÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Controlling True RandomnessÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Both these algorithms are intrinsically dependent on random numbers, but ORCA sets a fixed random seed such that the same results are always obtained on the same machine if calculations are repeated."
        }
      ],
      "parent_section": "solvator",
      "description": "Both these algorithms are intrinsically dependent on random numbers, but ORCA sets a fixed random seed such that the same results are always obtained on the same machine if calculations are repeated."
    },
    {
      "name": "Vacuum SearchÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Vacuum SearchÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "One option that might come in handy under certain conditions is to use the SOLVATOR to add the explicit solvent based on the implicit solvation information, but actuallynotuse any implicit solvation while trying to place them."
        }
      ],
      "parent_section": "solvator",
      "description": "One option that might come in handy under certain conditions is to use the SOLVATOR to add the explicit solvent based on the implicit solvation information, but actuallynotuse any implicit solvation while trying to place them."
    },
    {
      "name": "Complete Keyword ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Complete Keyword ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Complete Keyword ListÂ"
        }
      ],
      "parent_section": "solvator",
      "description": "ORCA: Complete Keyword ListÂ"
    },
    {
      "name": "Ab initioMolecular Dynamics SimulationsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Ab initioMolecular Dynamics SimulationsÂ"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Ab initioMolecular Dynamics SimulationsÂ"
    },
    {
      "name": "Changes in ORCA 5.0Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Changes in ORCA 5.0Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Changes in ORCA 5.0Â"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Changes in ORCA 5.0Â"
    },
    {
      "name": "Changes in ORCA 4.2 (Aug 2019)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Changes in ORCA 4.2 (Aug 2019)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Changes in ORCA 4.2 (Aug 2019)Â"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Changes in ORCA 4.2 (Aug 2019)Â"
    },
    {
      "name": "Changes in ORCA 4.1 (Dec 2018)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Changes in ORCA 4.1 (Dec 2018)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Changes in ORCA 4.1 (Dec 2018)Â"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Changes in ORCA 4.1 (Dec 2018)Â"
    },
    {
      "name": "Input FormatÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Input FormatÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The molecular dynamics module is activated by specifying âMDâ in the\nsimple input line. The actual MD input which describes the simulation\nfollows in the â%mdâ section at some later position in the input file.\nThe contents of this section will subsequently be referred to as âMD\ninputâ."
        }
      ],
      "parent_section": "moldyn",
      "description": "The molecular dynamics module is activated by specifying âMDâ in the\nsimple input line. The actual MD input which describes the simulation\nfollows in the â%mdâ section at some later position in the input file.\nThe contents of this section will subsequently be referred to as âMD\ninputâ."
    },
    {
      "name": "Discussion of FeaturesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Discussion of FeaturesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Discussion of FeaturesÂ"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Discussion of FeaturesÂ"
    },
    {
      "name": "Command ListÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Command ListÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In the following, an alphabetical list of all commands currently known\nto the MD module is given. The description of each command starts with a\nsmall box which contains the commandâs name and a table of arguments and\nmodifiers. The last-but-one column in the table specifies the type of\neach argument. Possible types are âIntegerâ, âRealâ, âStringâ, and\nâKeywordâ. In the latter cas"
        }
      ],
      "parent_section": "moldyn",
      "description": "In the following, an alphabetical list of all commands currently known\nto the MD module is given. The description of each command starts with a\nsmall box which contains the commandâs name and a table of arguments and\nmodifiers. The last-but-one column in the table specifies the type of\neach argument. Possible types are âIntegerâ, âRealâ, âStringâ, and\nâKeywordâ. In the latter cas"
    },
    {
      "name": "Command OverviewÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Command OverviewÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Command OverviewÂ"
        }
      ],
      "parent_section": "moldyn",
      "description": "ORCA: Command OverviewÂ"
    },
    {
      "name": "Scientific BackgroundÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Scientific BackgroundÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In this section, some of the methods and algorithms used within ORCAâs MD\nmodule are described in some more depth, with a focus on the scientific\nbackground."
        }
      ],
      "parent_section": "moldyn",
      "description": "In this section, some of the methods and algorithms used within ORCAâs MD\nmodule are described in some more depth, with a focus on the scientific\nbackground."
    },
    {
      "name": "Fast Multipole MethodÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Fast Multipole MethodÂ"
        }
      ],
      "parent_section": "fmm",
      "description": "ORCA: Fast Multipole MethodÂ"
    },
    {
      "name": "The Octree hierarchyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Octree hierarchyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "There exists a lot of detailed and pedagogical literature on the subject (we recommend for instance[49]and[377]). In the following we will only describe the main parameters."
        }
      ],
      "parent_section": "fmm",
      "description": "There exists a lot of detailed and pedagogical literature on the subject (we recommend for instance[49]and[377]). In the following we will only describe the main parameters."
    },
    {
      "name": "Approximation of the Far Field interactionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Approximation of the Far Field interactionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "In a space of origin O(0,0,0), let P (\\(\\textbf{r}_P\\)) be the center of a charge distribution (e.g. a Gaussian overlap or a distribution of point charges). Letâs consider a point A in the vicinity of P, such that A = (q\\(_A\\);\\(\\textbf{r}_A\\)), with q\\(_A\\)the charge of a point charge or q\\(_A = -1\\)if we consider a Gaussian overlap. In that case, the charge would indeed be the one of the elect"
        }
      ],
      "parent_section": "fmm",
      "description": "In a space of origin O(0,0,0), let P (\\(\\textbf{r}_P\\)) be the center of a charge distribution (e.g. a Gaussian overlap or a distribution of point charges). Letâs consider a point A in the vicinity of P, such that A = (q\\(_A\\);\\(\\textbf{r}_A\\)), with q\\(_A\\)the charge of a point charge or q\\(_A = -1\\)if we consider a Gaussian overlap. In that case, the charge would indeed be the one of the elect"
    },
    {
      "name": "The âVeryâ Fast Multipole Method (VFMM)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The âVeryâ Fast Multipole Method (VFMM)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Due to the recursive scheme between levels, the FF felt in the center of a box is built by only calculating interactions with the LFF boxes at every level. The evaluation of\\(V^{LFF}\\)becomes the bottleneck of the algorithm. To accelerate it, an option has been implemented in which different MAM truncation parameters will be used for all the (>189) boxes in the LFF area. This option FMMQMMMM_DoVFM"
        }
      ],
      "parent_section": "fmm",
      "description": "Due to the recursive scheme between levels, the FF felt in the center of a box is built by only calculating interactions with the LFF boxes at every level. The evaluation of\\(V^{LFF}\\)becomes the bottleneck of the algorithm. To accelerate it, an option has been implemented in which different MAM truncation parameters will be used for all the (>189) boxes in the LFF area. This option FMMQMMMM_DoVFM"
    },
    {
      "name": "Recommended inputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Recommended inputÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Whenever there is an electrostatic embedding, for systems containing more than 10,000 point charges (ECM) or MM atoms (QMMM), it is recommended to turn on the FMM in order to accelerate the calculation of the electrostatic potential. However, when using heavy parallelization with more than 24 processors, the impact of enabling the Fast Multipole Method (FMM) may be negligible for small embedding s"
        }
      ],
      "parent_section": "fmm",
      "description": "Whenever there is an electrostatic embedding, for systems containing more than 10,000 point charges (ECM) or MM atoms (QMMM), it is recommended to turn on the FMM in order to accelerate the calculation of the electrostatic potential. However, when using heavy parallelization with more than 24 processors, the impact of enabling the Fast Multipole Method (FMM) may be negligible for small embedding s"
    },
    {
      "name": "Some examplesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Some examplesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Call the recommanded FMM parameters through the keyword line:"
        }
      ],
      "parent_section": "fmm",
      "description": "Call the recommanded FMM parameters through the keyword line:"
    },
    {
      "name": "Implicit Solvation ModelsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Implicit Solvation ModelsÂ"
        }
      ],
      "parent_section": "solvationmodels",
      "description": "ORCA: Implicit Solvation ModelsÂ"
    },
    {
      "name": "The Conductor-like Polarizable Continuum Model (C-PCM)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Conductor-like Polarizable Continuum Model (C-PCM)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The conductor-like polarizable continuum model (C-PCM) is an\nimplementation of the conductor-like apparent surface charge methods. In\nthese models the solute is placed in a cavity of roughly molecular\nshape. The solvent reaction field is described by apparent polarization\ncharges on the cavity surface, which are in turn determined by the\nsolute. These charges can be treated as punctual (point char"
        }
      ],
      "parent_section": "solvationmodels",
      "description": "The conductor-like polarizable continuum model (C-PCM) is an\nimplementation of the conductor-like apparent surface charge methods. In\nthese models the solute is placed in a cavity of roughly molecular\nshape. The solvent reaction field is described by apparent polarization\ncharges on the cavity surface, which are in turn determined by the\nsolute. These charges can be treated as punctual (point char"
    },
    {
      "name": "The Conductor-like Screening Solvation Model (COSMO)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Conductor-like Screening Solvation Model (COSMO)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The Conductor-like Screening Solvation Model (COSMO)Â"
        }
      ],
      "parent_section": "solvationmodels",
      "description": "ORCA: The Conductor-like Screening Solvation Model (COSMO)Â"
    },
    {
      "name": "The SMD Solvation ModelÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The SMD Solvation ModelÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The SMD solvation model has been proposed by the Cramer and Truhlar\ngroups,[559]and is based on the quantum mechanical charge\ndensity of a solute molecule interacting with a continuum description of\nthe solvent. In the model the full solute electron density is used\nwithout defining partial atomic charges and the solvent is not\nrepresented explicitly but rather as a dielectric medium with the\nsurfa"
        }
      ],
      "parent_section": "solvationmodels",
      "description": "The SMD solvation model has been proposed by the Cramer and Truhlar\ngroups,[559]and is based on the quantum mechanical charge\ndensity of a solute molecule interacting with a continuum description of\nthe solvent. In the model the full solute electron density is used\nwithout defining partial atomic charges and the solvent is not\nrepresented explicitly but rather as a dielectric medium with the\nsurfa"
    },
    {
      "name": "Dynamic Radii Adjustment for Continuum Solvation (DRACO)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Dynamic Radii Adjustment for Continuum Solvation (DRACO)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The DRACO scheme is an approach that improves the performance of implicit solvation models, in particular\nthe accuracy of the calculated solvation free energies.[689]It is based on a dynamic scaling of the\noriginal static radii used to describe the atoms/spheres that define the cavity of the solute."
        }
      ],
      "parent_section": "solvationmodels",
      "description": "The DRACO scheme is an approach that improves the performance of implicit solvation models, in particular\nthe accuracy of the calculated solvation free energies.[689]It is based on a dynamic scaling of the\noriginal static radii used to describe the atoms/spheres that define the cavity of the solute."
    },
    {
      "name": "OpenCOSMO-RSÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "OpenCOSMO-RSÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA is interfaced to openCOSMO-RS,[293,542]an open source implementation of the COSMO-RS model.[447,448]This model is widely used in both academia and industry to predict fluid phase thermodynamics."
        }
      ],
      "parent_section": "solvationmodels",
      "description": "ORCA is interfaced to openCOSMO-RS,[293,542]an open source implementation of the COSMO-RS model.[447,448]This model is widely used in both academia and industry to predict fluid phase thermodynamics."
    },
    {
      "name": "Implicit Solvation in Coupled-Cluster MethodsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Implicit Solvation in Coupled-Cluster MethodsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The coupled-cluster Lagrangian,\\(\\mathcal{L}\\), for a system implicitly\nsolvated reads as\nfollows,[133,142,285]"
        }
      ],
      "parent_section": "solvationmodels",
      "description": "The coupled-cluster Lagrangian,\\(\\mathcal{L}\\), for a system implicitly\nsolvated reads as\nfollows,[133,142,285]"
    },
    {
      "name": "Calculation of PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Calculation of PropertiesÂ"
        }
      ],
      "parent_section": "properties",
      "description": "ORCA: Calculation of PropertiesÂ"
    },
    {
      "name": "Electric PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Electric PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Calculation of first order (electric dipole and quadrupole\nmoments) and second order (polarizabilities) electric properties can be requested\nin the%elpropinput block. The second order properties can be\ncalculated through the solution of the CP-SCF (seeCP-SCF Options)\nor CP-CASSCF (seeCASSCF Linear Response) equations. Details are\nshown below:"
        }
      ],
      "parent_section": "properties",
      "description": "Calculation of first order (electric dipole and quadrupole\nmoments) and second order (polarizabilities) electric properties can be requested\nin the%elpropinput block. The second order properties can be\ncalculated through the solution of the CP-SCF (seeCP-SCF Options)\nor CP-CASSCF (seeCASSCF Linear Response) equations. Details are\nshown below:"
    },
    {
      "name": "The Spin-Orbit Coupling OperatorÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "The Spin-Orbit Coupling OperatorÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Several variants of spin-orbit coupling operators can be used for\nproperty calculations[611]. They are based on effective\npotential and mean-field approaches, and have various parameters that\ncan be selected via the%relblock. Note that the SOMF operator\ndepends on the density matrix, so the operator itself can differ for\nexample between a CASSCF and an MRCI calculation."
        }
      ],
      "parent_section": "properties",
      "description": "Several variants of spin-orbit coupling operators can be used for\nproperty calculations[611]. They are based on effective\npotential and mean-field approaches, and have various parameters that\ncan be selected via the%relblock. Note that the SOMF operator\ndepends on the density matrix, so the operator itself can differ for\nexample between a CASSCF and an MRCI calculation."
    },
    {
      "name": "EPR and NMR propertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "EPR and NMR propertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Calculation of EPR and NMR response properties can be requested in\nthe%eprnmrinput block. The individual flags are given below."
        }
      ],
      "parent_section": "properties",
      "description": "Calculation of EPR and NMR response properties can be requested in\nthe%eprnmrinput block. The individual flags are given below."
    },
    {
      "name": "Paramagnetic NMR shielding tensorsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Paramagnetic NMR shielding tensorsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For systems with spin\\(S>0\\), the nuclear shielding contains a\ncontribution which arises from the paramagnetism of the unpaired\nelectrons.[1]This contribution is temperature-dependent and is called\nthe âparamagnetic shieldingâ (\\(\\boldsymbol{\\sigma}^\\mathrm{p}\\)). It adds\nto the temperature-indendent contribution to the shielding, also called\nthe âorbitalâ contribution:"
        }
      ],
      "parent_section": "properties",
      "description": "For systems with spin\\(S>0\\), the nuclear shielding contains a\ncontribution which arises from the paramagnetism of the unpaired\nelectrons.[1]This contribution is temperature-dependent and is called\nthe âparamagnetic shieldingâ (\\(\\boldsymbol{\\sigma}^\\mathrm{p}\\)). It adds\nto the temperature-indendent contribution to the shielding, also called\nthe âorbitalâ contribution:"
    },
    {
      "name": "Calculating properties from existing densitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Calculating properties from existing densitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Occasionally, one may calculate a density matrix using an expensive\ncorrelated method such as CCSD and realize afterwards that a certain\nproperty such as the quadrupole moment or a hyperfine coupling constant\n(HFCC) is also required. Rather than start the whole calculation from\nscratch, one may wish to use the existing density matrix to calculate\nthe properties. For this purpose, we have experimen"
        }
      ],
      "parent_section": "properties",
      "description": "Occasionally, one may calculate a density matrix using an expensive\ncorrelated method such as CCSD and realize afterwards that a certain\nproperty such as the quadrupole moment or a hyperfine coupling constant\n(HFCC) is also required. Rather than start the whole calculation from\nscratch, one may wish to use the existing density matrix to calculate\nthe properties. For this purpose, we have experimen"
    },
    {
      "name": "Local Energy DecompositionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Local Energy DecompositionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The DLPNO-CCSD(T) method provides very accurate relative energies and\nallows to successfully predict many chemical phenomena. In order to\nfacilitate the interpretation of coupled cluster results, we have\ndeveloped the Local Energy Decomposition (LED)\nanalysisÂ[33,105,768],\nwhich permit to divide the total DLPNO-CCSD(T) energy (including the\nreference energy) into physically meaningful contribution"
        }
      ],
      "parent_section": "properties",
      "description": "The DLPNO-CCSD(T) method provides very accurate relative energies and\nallows to successfully predict many chemical phenomena. In order to\nfacilitate the interpretation of coupled cluster results, we have\ndeveloped the Local Energy Decomposition (LED)\nanalysisÂ[33,105,768],\nwhich permit to divide the total DLPNO-CCSD(T) energy (including the\nreference energy) into physically meaningful contribution"
    },
    {
      "name": "Natural Bond Orbital (NBO) AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Natural Bond Orbital (NBO) AnalysisÂ"
        }
      ],
      "parent_section": "nbo",
      "description": "ORCA: Natural Bond Orbital (NBO) AnalysisÂ"
    },
    {
      "name": "NBO DeletionsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "NBO DeletionsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "An advanced feature, which has been implemented via the ORCA-NBO\ninterface, is the possibility of using deletions."
        }
      ],
      "parent_section": "nbo",
      "description": "An advanced feature, which has been implemented via the ORCA-NBO\ninterface, is the possibility of using deletions."
    },
    {
      "name": "NBO for Post-HF DensitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "NBO for Post-HF DensitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "NBO analysis can be performed on all methods producing a density. In\nsome methods the density generation has to be specified explictly, e. g.\nfor MP2 calculations this would be:"
        }
      ],
      "parent_section": "nbo",
      "description": "NBO analysis can be performed on all methods producing a density. In\nsome methods the density generation has to be specified explictly, e. g.\nfor MP2 calculations this would be:"
    },
    {
      "name": "Natural Chemical Shielding Analysis (NCS)Â",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural Chemical Shielding Analysis (NCS)Â ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "For closed-shell calculations of NMR chemical shielding at the SCF level\n(see sectionsNMR Chemical ShiftsandEPR and NMR properties), the NCS analysis can be\nrequested by addingNCSto theNBOKEYLIST. TheNCSkeyword accepts\nthe argumentsU,I,CSA,XYZ, andMOto analyze the\nâunperturbedâ, âinducedâ, anisotropic, Cartesian, and canonical MO\ncontributions to the shielding tensors, respectively, as wel"
        }
      ],
      "parent_section": "nbo",
      "description": "For closed-shell calculations of NMR chemical shielding at the SCF level\n(see sectionsNMR Chemical ShiftsandEPR and NMR properties), the NCS analysis can be\nrequested by addingNCSto theNBOKEYLIST. TheNCSkeyword accepts\nthe argumentsU,I,CSA,XYZ, andMOto analyze the\nâunperturbedâ, âinducedâ, anisotropic, Cartesian, and canonical MO\ncontributions to the shielding tensors, respectively, as wel"
    },
    {
      "name": "Population Analyses and Control of OutputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Population Analyses and Control of OutputÂ"
        }
      ],
      "parent_section": "population",
      "description": "ORCA: Population Analyses and Control of OutputÂ"
    },
    {
      "name": "Controlling OutputÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Controlling OutputÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The arrayPrintallows the control of output. The general way of\nassigning elements ofPrintis:"
        }
      ],
      "parent_section": "population",
      "description": "The arrayPrintallows the control of output. The general way of\nassigning elements ofPrintis:"
    },
    {
      "name": "Mulliken Population AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Mulliken Population AnalysisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The Mulliken population analysis[599]is, despite all its\nknown considerable weaknesses, the standard in most quantum chemical\nprograms. It partitions the total density using the assignment of basis\nfunctions to given atoms in the molecules and the basis function\noverlap. If the total charge density is written as\\(\\rho \\left({ \\vec{r} } \\right)\\)and the total number of electrons is\\(N\\)we have:"
        }
      ],
      "parent_section": "population",
      "description": "The Mulliken population analysis[599]is, despite all its\nknown considerable weaknesses, the standard in most quantum chemical\nprograms. It partitions the total density using the assignment of basis\nfunctions to given atoms in the molecules and the basis function\noverlap. If the total charge density is written as\\(\\rho \\left({ \\vec{r} } \\right)\\)and the total number of electrons is\\(N\\)we have:"
    },
    {
      "name": "LÃwdin Population AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "LÃwdin Population AnalysisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The LÃ¶wdin analysis[840]is somewhat more straightforward\nthan the Mulliken analysis. In the LÃ¶wdin method one changes to a basis\nwhere all overlap integrals vanish. This is accomplished via LÃ¶wdins\nsymmetric orthogonalization matrix\\(\\mathrm{\\mathbf{S} }^{-1/2}\\). Using\nthis transformation matrix the new basis functions are multicentered but\nare in a least square sense as similar as possible to"
        }
      ],
      "parent_section": "population",
      "description": "The LÃ¶wdin analysis[840]is somewhat more straightforward\nthan the Mulliken analysis. In the LÃ¶wdin method one changes to a basis\nwhere all overlap integrals vanish. This is accomplished via LÃ¶wdins\nsymmetric orthogonalization matrix\\(\\mathrm{\\mathbf{S} }^{-1/2}\\). Using\nthis transformation matrix the new basis functions are multicentered but\nare in a least square sense as similar as possible to"
    },
    {
      "name": "Mayer Population AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Mayer Population AnalysisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Mayers bonding analysis[568,569,570,571]is\nanother creative attempt to define chemically useful indices. The Mayer\natomic charge is identical to the Mulliken charge. The Mayer bond order\nis defined as:"
        }
      ],
      "parent_section": "population",
      "description": "Mayers bonding analysis[568,569,570,571]is\nanother creative attempt to define chemically useful indices. The Mayer\natomic charge is identical to the Mulliken charge. The Mayer bond order\nis defined as:"
    },
    {
      "name": "Natural Population AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Natural Population AnalysisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A popular and useful method for population analysis is the natural\npopulation analysis due to Weinhold and co-workers. It is implemented in\nthe NBO interface."
        }
      ],
      "parent_section": "population",
      "description": "A popular and useful method for population analysis is the natural\npopulation analysis due to Weinhold and co-workers. It is implemented in\nthe NBO interface."
    },
    {
      "name": "Local Spin AnalysisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Local Spin AnalysisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "It is common practice in various areas of chemistry to think about the\ninteraction of open-shell systems in terms of local spin states. For\nexample, in dimeric or oligomeric transition metal clusters, the\nâexchange couplingâ between open shell ions that exist locally in\nhigh-spin states is a much studied phenomenon. Diradicals would be\ntypical systems in organic chemistry that show this phenom"
        }
      ],
      "parent_section": "population",
      "description": "It is common practice in various areas of chemistry to think about the\ninteraction of open-shell systems in terms of local spin states. For\nexample, in dimeric or oligomeric transition metal clusters, the\nâexchange couplingâ between open shell ions that exist locally in\nhigh-spin states is a much studied phenomenon. Diradicals would be\ntypical systems in organic chemistry that show this phenom"
    },
    {
      "name": "UNO Orbital PrintingÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "UNO Orbital PrintingÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The analysis of UNOâs can be controlled similarly. The flags together\nwith their default values are shown below:"
        }
      ],
      "parent_section": "population",
      "description": "The analysis of UNOâs can be controlled similarly. The flags together\nwith their default values are shown below:"
    },
    {
      "name": "Hirshfeld ChargesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Hirshfeld ChargesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The partitioning method by Hirshfeld is one of the most used approaches in\nthe so-called atoms in molecules (AIM) methods.[394]In this case, the AIM density\nof atom A,\\(\\rho_A(\\vec{r})\\)is written as:"
        }
      ],
      "parent_section": "population",
      "description": "The partitioning method by Hirshfeld is one of the most used approaches in\nthe so-called atoms in molecules (AIM) methods.[394]In this case, the AIM density\nof atom A,\\(\\rho_A(\\vec{r})\\)is written as:"
    },
    {
      "name": "MBIS ChargesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "MBIS ChargesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The Minimal Basis Iterative Stockholder (MBIS) method is a variant of the Hirshfeld method.[870]The idea behind this approach is that the pro-atomic density\\(\\rho_A^0(\\vec{r})\\)is expanded\nin a minimal set of atom-centered s-type Slater functions\\(\\rho_{Ai}^0(\\vec{r})\\):"
        }
      ],
      "parent_section": "population",
      "description": "The Minimal Basis Iterative Stockholder (MBIS) method is a variant of the Hirshfeld method.[870]The idea behind this approach is that the pro-atomic density\\(\\rho_A^0(\\vec{r})\\)is expanded\nin a minimal set of atom-centered s-type Slater functions\\(\\rho_{Ai}^0(\\vec{r})\\):"
    },
    {
      "name": "Orbital and Density PlotsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Orbital and Density PlotsÂ"
        }
      ],
      "parent_section": "plots",
      "description": "ORCA: Orbital and Density PlotsÂ"
    },
    {
      "name": "Contour PlotsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Contour PlotsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The contour plots are controlled via the following variables"
        }
      ],
      "parent_section": "plots",
      "description": "The contour plots are controlled via the following variables"
    },
    {
      "name": "Surface PlotsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Surface PlotsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Surface PlotsÂ"
        }
      ],
      "parent_section": "plots",
      "description": "ORCA: Surface PlotsÂ"
    },
    {
      "name": "Utility ProgramsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Utility ProgramsÂ"
        }
      ],
      "parent_section": "utilities",
      "description": "ORCA: Utility ProgramsÂ"
    },
    {
      "name": "orca_mapspcÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_mapspcÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This utility program is used to turn calculated spectra into a format\nthat can be plotted with standard graphics programs. The usage is simple\n(for output examples see for example sectionsSemiempirical Methods,IR Spectra,Raman SpectraandResonant Inelastic Scattering Spectroscopy):"
        }
      ],
      "parent_section": "utilities",
      "description": "This utility program is used to turn calculated spectra into a format\nthat can be plotted with standard graphics programs. The usage is simple\n(for output examples see for example sectionsSemiempirical Methods,IR Spectra,Raman SpectraandResonant Inelastic Scattering Spectroscopy):"
    },
    {
      "name": "orca_chelpgÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_chelpgÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This program calculates CHELPG atomic charges according to Breneman and\nWiberg[124]. The atomic charges are fitted to reproduce the\nelectrostatic potential on a regular grid around the molecule, while\nconstraining the sum of all atomic charges to the moleculeâs total\ncharge. An additional constraint can be added, so the CHELPG charges\nalso reproduce the total dipole moment of the molecule."
        }
      ],
      "parent_section": "utilities",
      "description": "This program calculates CHELPG atomic charges according to Breneman and\nWiberg[124]. The atomic charges are fitted to reproduce the\nelectrostatic potential on a regular grid around the molecule, while\nconstraining the sum of all atomic charges to the moleculeâs total\ncharge. An additional constraint can be added, so the CHELPG charges\nalso reproduce the total dipole moment of the molecule."
    },
    {
      "name": "orca_pltvibÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_pltvibÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This program is used in conjunction with gOpenMol (or xmol) to produce\nanimations or plots of vibrational modes following a frequency run. The\nusage is again simple and described in sectionAnimation of Vibrational Modestogether with a short\ndescription of how to produce these plots in gOpenMol."
        }
      ],
      "parent_section": "utilities",
      "description": "This program is used in conjunction with gOpenMol (or xmol) to produce\nanimations or plots of vibrational modes following a frequency run. The\nusage is again simple and described in sectionAnimation of Vibrational Modestogether with a short\ndescription of how to produce these plots in gOpenMol."
    },
    {
      "name": "orca_vibÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_vibÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This is a small âstandaloneâ program to perform vibrational analysis.\nThe idea is that the user has some control over things like the atomic\nmasses that enter the prediction of vibrational frequencies but are\nindependent of the electronic structure calculation as such."
        }
      ],
      "parent_section": "utilities",
      "description": "This is a small âstandaloneâ program to perform vibrational analysis.\nThe idea is that the user has some control over things like the atomic\nmasses that enter the prediction of vibrational frequencies but are\nindependent of the electronic structure calculation as such."
    },
    {
      "name": "orca_locÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_locÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Localization is a widely used technique nowadays. By defining different\nfunctionals, various localization methods are established. The most\nfavorable localization methods are developed by Foster-Boys and\nPipek-Mezey. In ORCA  there are four different localization methods\navailable, the Pipek-Mezey method (PM), the Foster-Boys method (FB), the\nintrinsic atomic orbitals (IAO) based PM method and the"
        }
      ],
      "parent_section": "utilities",
      "description": "Localization is a widely used technique nowadays. By defining different\nfunctionals, various localization methods are established. The most\nfavorable localization methods are developed by Foster-Boys and\nPipek-Mezey. In ORCA  there are four different localization methods\navailable, the Pipek-Mezey method (PM), the Foster-Boys method (FB), the\nintrinsic atomic orbitals (IAO) based PM method and the"
    },
    {
      "name": "orca_blockfÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_blockfÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This utility program allows the canonicalization of orbitals (.gbw file)\nfor arbitrary subspaces. With canonicalization we refer to the block\ndiagonalization of the Fock matrix. Note that the necessary Fock matrix\nmust be generated and be available on disk prior callingorca_blockf.\nThe program is described in sectionLocal Zero-Field Splitting, where the Local ZFS\ndecomposition is discussed."
        }
      ],
      "parent_section": "utilities",
      "description": "This utility program allows the canonicalization of orbitals (.gbw file)\nfor arbitrary subspaces. With canonicalization we refer to the block\ndiagonalization of the Fock matrix. Note that the necessary Fock matrix\nmust be generated and be available on disk prior callingorca_blockf.\nThe program is described in sectionLocal Zero-Field Splitting, where the Local ZFS\ndecomposition is discussed."
    },
    {
      "name": "orca_plotÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_plotÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Orca_plot is a utility program that can be used to generate 2D and 3D\ngraphics of various types of orbitals and densities during an ORCA run.\nIt can in principle called in two ways:"
        }
      ],
      "parent_section": "utilities",
      "description": "Orca_plot is a utility program that can be used to generate 2D and 3D\ngraphics of various types of orbitals and densities during an ORCA run.\nIt can in principle called in two ways:"
    },
    {
      "name": "orca_2mkl: Old Molekel as well as Molden inputsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_2mkl: Old Molekel as well as Molden inputsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This little utility program can be used to convert gbw files into mkl\nfiles which are of ASCII format. This is useful since molekel can read\nthese files and use them for plotting and the like. The contents of the\nmkl file is roughly the same as the gbw file (except for the internal\nflags of ORCA) but this is an ASCII file which can also be read for\nexample by your own programs. It would therefore "
        }
      ],
      "parent_section": "utilities",
      "description": "This little utility program can be used to convert gbw files into mkl\nfiles which are of ASCII format. This is useful since molekel can read\nthese files and use them for plotting and the like. The contents of the\nmkl file is roughly the same as the gbw file (except for the internal\nflags of ORCA) but this is an ASCII file which can also be read for\nexample by your own programs. It would therefore "
    },
    {
      "name": "orca_2aimÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_2aimÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This utility program reads a.gbwfile and creates a.wfnand.wfxfile that can be used for topological analysis of the electron density\nby other programs. This works for open-shell and closed-shell wave\nfunctions. The usage is very simple â just typeAIMin the simple\ninput line of your input file, or use"
        }
      ],
      "parent_section": "utilities",
      "description": "This utility program reads a.gbwfile and creates a.wfnand.wfxfile that can be used for topological analysis of the electron density\nby other programs. This works for open-shell and closed-shell wave\nfunctions. The usage is very simple â just typeAIMin the simple\ninput line of your input file, or use"
    },
    {
      "name": "orca_vpotÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_vpotÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This program calculates the electrostatic potential at a given set of\nuser defined points. It can be used with either an input file or in\ninteractive mode. It needs four arguments:"
        }
      ],
      "parent_section": "utilities",
      "description": "This program calculates the electrostatic potential at a given set of\nuser defined points. It can be used with either an input file or in\ninteractive mode. It needs four arguments:"
    },
    {
      "name": "orca_eulerÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_eulerÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This utility program is used to calculate the relative orientation\nbetween calculated hyperfine coupling (HFC)/nuclear quadrupole coupling\n(NQC) tensors and a reference tensor (the calculated molecular\ng-/D-tensor). Theorca_eulerprogram is run by default in an ORCA job\nafter the calculation of HFCs or NQCs, if g- or D-tensor are also\ncalculated in the same job. The utility program can also be run "
        }
      ],
      "parent_section": "utilities",
      "description": "This utility program is used to calculate the relative orientation\nbetween calculated hyperfine coupling (HFC)/nuclear quadrupole coupling\n(NQC) tensors and a reference tensor (the calculated molecular\ng-/D-tensor). Theorca_eulerprogram is run by default in an ORCA job\nafter the calculation of HFCs or NQCs, if g- or D-tensor are also\ncalculated in the same job. The utility program can also be run "
    },
    {
      "name": "orca_exportbasisÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_exportbasisÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A small utility program to print out the basis sets used by ORCA. Its\nusage requires at least the name of the basis set, as specified in the\nsimple input line of ORCA. Additional parameters like an ECP basis set,\na list of specific atoms or the name of an ouput file are accepted. The\noutput is stored in ASCII format, it can be inspected and modified. The\nuser can choose to print the basis sets in "
        }
      ],
      "parent_section": "utilities",
      "description": "A small utility program to print out the basis sets used by ORCA. Its\nusage requires at least the name of the basis set, as specified in the\nsimple input line of ORCA. Additional parameters like an ECP basis set,\na list of specific atoms or the name of an ouput file are accepted. The\noutput is stored in ASCII format, it can be inspected and modified. The\nuser can choose to print the basis sets in "
    },
    {
      "name": "orca_ecaÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_ecaÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "This utility program makes use of the calculated exchange coupling\nconstants to compute relative energies of all possible spin states\nthrough diagonalization of spin Hamiltonian. The absolute and relative\nenergies of the spin states are printed in the*.enand*.en0files\nrespectively. The on-site spin expectation values are also printed in a*.spfile.The following example calculates the spin ladder fo"
        }
      ],
      "parent_section": "utilities",
      "description": "This utility program makes use of the calculated exchange coupling\nconstants to compute relative energies of all possible spin states\nthrough diagonalization of spin Hamiltonian. The absolute and relative\nenergies of the spin states are printed in the*.enand*.en0files\nrespectively. The on-site spin expectation values are also printed in a*.spfile.The following example calculates the spin ladder fo"
    },
    {
      "name": "orca_pnmrÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_pnmrÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "orca_pnmrcalculates the paramagnetic contribution to the NMR\nshielding tensor from EPR\\(g\\),\\(A\\), and\\(D\\)tensors (see SectionParamagnetic NMR shielding tensorsfor theoretical\nbackground). It is a standalone program which you can invoke on the\ncommand line after the main ORCA calculation has finished.\nAlternatively, it can read user-provided\\(g\\)/\\(A\\)/\\(D\\)tensors from an\ninput file (option-i). "
        }
      ],
      "parent_section": "utilities",
      "description": "orca_pnmrcalculates the paramagnetic contribution to the NMR\nshielding tensor from EPR\\(g\\),\\(A\\), and\\(D\\)tensors (see SectionParamagnetic NMR shielding tensorsfor theoretical\nbackground). It is a standalone program which you can invoke on the\ncommand line after the main ORCA calculation has finished.\nAlternatively, it can read user-provided\\(g\\)/\\(A\\)/\\(D\\)tensors from an\ninput file (option-i). "
    },
    {
      "name": "orca_lftÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_lftÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Starting from ORCA 5.0, ORCA features a standalone multiplet program\ncalled orca_lft."
        }
      ],
      "parent_section": "utilities",
      "description": "Starting from ORCA 5.0, ORCA features a standalone multiplet program\ncalled orca_lft."
    },
    {
      "name": "orca_crystalprepÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "orca_crystalprepÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA 5.0 fetures a utility program that can process crystallographic\nfiles (.cif) or .xyz supercell files and produce proper inputs for the\nembedded cluster calculations It is named orca_crystalprep tool."
        }
      ],
      "parent_section": "utilities",
      "description": "ORCA 5.0 fetures a utility program that can process crystallographic\nfiles (.cif) or .xyz supercell files and produce proper inputs for the\nembedded cluster calculations It is named orca_crystalprep tool."
    },
    {
      "name": "Compound MethodsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Compound MethodsÂ"
        }
      ],
      "parent_section": "compound",
      "description": "ORCA: Compound MethodsÂ"
    },
    {
      "name": "CommandsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "CommandsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Below is a list of all available commands available inCompound"
        }
      ],
      "parent_section": "compound",
      "description": "Below is a list of all available commands available inCompound"
    },
    {
      "name": "List of known PropertiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "List of known PropertiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The name and a sort explanation of all the known variables that can be\nautomatically recovered, from the property file, are given in the next\ntable"
        }
      ],
      "parent_section": "compound",
      "description": "The name and a sort explanation of all the known variables that can be\nautomatically recovered, from the property file, are given in the next\ntable"
    },
    {
      "name": "List of known Simple input commandsÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "List of known Simple input commandsÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The name and a sort explanation of all compound protocols that are know\nthrough the simple input line, are given in the next table. The syntax\nis always:"
        }
      ],
      "parent_section": "compound",
      "description": "The name and a sort explanation of all compound protocols that are know\nthrough the simple input line, are given in the next table. The syntax\nis always:"
    },
    {
      "name": "Compound ExamplesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Compound ExamplesÂ"
        }
      ],
      "parent_section": "compound examples",
      "description": "ORCA: Compound ExamplesÂ"
    },
    {
      "name": "IntroductionÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "IntroductionÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "A library of compound scripts exist in page https://github.com/ORCAQuantumChemistry/CompoundScripts ."
        }
      ],
      "parent_section": "compound examples",
      "description": "A library of compound scripts exist in page https://github.com/ORCAQuantumChemistry/CompoundScripts ."
    },
    {
      "name": "Hello WorldÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Hello WorldÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "New JobÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "New JobÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "High AccuracyÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "High AccuracyÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "ScanÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "ScanÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "Numerical polarizabilitiesÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Numerical polarizabilitiesÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "Iterative optimizationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Iterative optimizationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "Gradient extrapolationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Gradient extrapolationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "BSSE OptimizationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "BSSE OptimizationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "Umbrella scriptÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Umbrella scriptÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "Multi referenceÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Multi referenceÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "GoToÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "GoToÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Introduction"
        }
      ],
      "parent_section": "compound examples",
      "description": "Introduction"
    },
    {
      "name": "orca_2jsonÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: orca_2jsonÂ"
        }
      ],
      "parent_section": "orca 2json",
      "description": "ORCA: orca_2jsonÂ"
    },
    {
      "name": "Export ORCA dataÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Export ORCA dataÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The program reads information like geometries, basis sets, MOs etc.\nstored in the.gbwfile or other equivalent ones as.uno,.mp2nat,.qroetc. and calculates integrals to export them in JSON standard\noutput formats. For density information the.densitiesfile must also\nbe available. The program is called as a standalone via command line."
        }
      ],
      "parent_section": "orca 2json",
      "description": "The program reads information like geometries, basis sets, MOs etc.\nstored in the.gbwfile or other equivalent ones as.uno,.mp2nat,.qroetc. and calculates integrals to export them in JSON standard\noutput formats. For density information the.densitiesfile must also\nbe available. The program is called as a standalone via command line."
    },
    {
      "name": "Configuration fileÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Configuration fileÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The data stored in the json file can be configured more individually.\nSome information like atom information, geometry and charge are always\nwritten in the outputfile (seeBasic Information). Other data can be requested via keywords in a\nJSON-formatted configuration file that either exists for every ORCA\noutput file or for all files in a directory. Without these configuration\nfilesALLavailable data"
        }
      ],
      "parent_section": "orca 2json",
      "description": "The data stored in the json file can be configured more individually.\nSome information like atom information, geometry and charge are always\nwritten in the outputfile (seeBasic Information). Other data can be requested via keywords in a\nJSON-formatted configuration file that either exists for every ORCA\noutput file or for all files in a directory. Without these configuration\nfilesALLavailable data"
    },
    {
      "name": "Available informationÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Available informationÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Available informationÂ"
        }
      ],
      "parent_section": "orca 2json",
      "description": "ORCA: Available informationÂ"
    },
    {
      "name": "Import JSON data into ORCAÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "Import JSON data into ORCAÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "Some information like geometry, basis set and Molecular orbitals stored in the json\nformat written by orca_2json can be used to create a new gbw-file to be\nspecified as an orbital file in the orca input. The program is called as\na standalone via command line."
        }
      ],
      "parent_section": "orca 2json",
      "description": "Some information like geometry, basis set and Molecular orbitals stored in the json\nformat written by orca_2json can be used to create a new gbw-file to be\nspecified as an orbital file in the orca input. The program is called as\na standalone via command line."
    },
    {
      "name": "Property FileÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "! / %block ... END",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "ORCA: Property FileÂ"
        }
      ],
      "parent_section": "property file",
      "description": "ORCA: Property FileÂ"
    },
    {
      "name": "txt formatÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "txt formatÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "After any ORCA calculation a property file is created with the extension.property.txt. The file is a text file and one can read it and edit it with any available text editor. Below we will analyze the syntax of the file."
        }
      ],
      "parent_section": "property file",
      "description": "After any ORCA calculation a property file is created with the extension.property.txt. The file is a text file and one can read it and edit it with any available text editor. Below we will analyze the syntax of the file."
    },
    {
      "name": "JSON formatÂ",
      "software": "ORCA",
      "paradigm": "MIXED",
      "syntax_template": "JSON formatÂ ...",
      "arguments": [
        {
          "name": "options",
          "dtype": "STRING",
          "default_value": null,
          "unit": null,
          "description": "The property file can be also produced in a JSON format. Internally this happens through transformation of thetxt formatto JSON format. There are two ways to create a JSON property file."
        }
      ],
      "parent_section": "property file",
      "description": "The property file can be also produced in a JSON format. Internally this happens through transformation of thetxt formatto JSON format. There are two ways to create a JSON property file."
    }
  ],
  "basis_sets": [
    {
      "name": "STO-3G",
      "syntax": "STO-3G",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "MINIS",
      "syntax": "MINIS",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "SV",
      "syntax": "SV",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "SV(P)",
      "syntax": "SV(P)",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "SVP",
      "syntax": "SVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-SV(P)",
      "syntax": "def2-SV(P)",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-SVP",
      "syntax": "def2-SVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-SVPD",
      "syntax": "def2-SVPD",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-TZVP",
      "syntax": "def2-TZVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-TZVPD",
      "syntax": "def2-TZVPD",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-TZVPP",
      "syntax": "def2-TZVPP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-TZVPPD",
      "syntax": "def2-TZVPPD",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-QZVP",
      "syntax": "def2-QZVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-QZVPD",
      "syntax": "def2-QZVPD",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-QZVPP",
      "syntax": "def2-QZVPP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-QZVPPD",
      "syntax": "def2-QZVPPD",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-mSVP",
      "syntax": "def2-mSVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-mTZVP",
      "syntax": "def2-mTZVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-mTZVPP",
      "syntax": "def2-mTZVPP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "cc-pVDZ",
      "syntax": "cc-pVDZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "cc-pVTZ",
      "syntax": "cc-pVTZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "cc-pVQZ",
      "syntax": "cc-pVQZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "cc-pV5Z",
      "syntax": "cc-pV5Z",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "aug-cc-pVDZ",
      "syntax": "aug-cc-pVDZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "aug-cc-pVTZ",
      "syntax": "aug-cc-pVTZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "aug-cc-pVQZ",
      "syntax": "aug-cc-pVQZ",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-31G",
      "syntax": "6-31G",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-31G*",
      "syntax": "6-31G*",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-31G**",
      "syntax": "6-31G**",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-311G",
      "syntax": "6-311G",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-311G*",
      "syntax": "6-311G*",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "6-311G**",
      "syntax": "6-311G**",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "ma-def2-SVP",
      "syntax": "ma-def2-SVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "ma-def2-TZVP",
      "syntax": "ma-def2-TZVP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "ANO-RCC",
      "syntax": "ANO-RCC",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "def2-ECP",
      "syntax": "def2-ECP",
      "category": null,
      "description": "ORCA basis set",
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    }
  ],
  "methods": [
    {
      "name": "HF",
      "type": "HF",
      "syntax": "! HF",
      "description": "Hartree-Fock",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "B3LYP",
      "type": "DFT",
      "syntax": "! B3LYP",
      "description": "Hybrid GGA",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "PBE",
      "type": "DFT",
      "syntax": "! PBE",
      "description": "GGA",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "PBE0",
      "type": "DFT",
      "syntax": "! PBE0",
      "description": "Hybrid GGA",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "M06-2X",
      "type": "DFT",
      "syntax": "! M06-2X",
      "description": "Meta-hybrid GGA",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "wB97X-D",
      "type": "DFT",
      "syntax": "! wB97X-D",
      "description": "Range-separated hybrid with dispersion",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "MP2",
      "type": "post-HF",
      "syntax": "! MP2",
      "description": "Second-order Moller-Plesset",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "CCSD",
      "type": "post-HF",
      "syntax": "! CCSD",
      "description": "Coupled cluster singles and doubles",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "CCSD(T)",
      "type": "post-HF",
      "syntax": "! CCSD(T)",
      "description": "CCSD with perturbative triples",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "CASSCF",
      "type": "multiconfig",
      "syntax": "! CASSCF",
      "description": "Complete active space SCF",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    },
    {
      "name": "DLPNO-CCSD(T)",
      "type": "post-HF",
      "syntax": "! DLPNO-CCSD(T)",
      "description": "Domain-based local CCSD(T)",
      "aliases": [],
      "source_url": "https://www.faccts.de/docs/orca/6.0/manual"
    }
  ]
}